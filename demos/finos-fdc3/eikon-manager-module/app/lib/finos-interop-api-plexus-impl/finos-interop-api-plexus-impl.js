(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.PlexusPlatformFactory = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}

},{}],2:[function(require,module,exports){
"use strict";

/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};

},{}],3:[function(require,module,exports){
"use strict";
module.exports = codegen;

/**
 * Begins generating a function.
 * @memberof util
 * @param {string[]} functionParams Function parameter names
 * @param {string} [functionName] Function name if not anonymous
 * @returns {Codegen} Appender that appends code to the function's body
 */
function codegen(functionParams, functionName) {

    /* istanbul ignore if */
    if (typeof functionParams === "string") {
        functionName = functionParams;
        functionParams = undefined;
    }

    var body = [];

    /**
     * Appends code to the function's body or finishes generation.
     * @typedef Codegen
     * @type {function}
     * @param {string|Object.<string,*>} [formatStringOrScope] Format string or, to finish the function, an object of additional scope variables, if any
     * @param {...*} [formatParams] Format parameters
     * @returns {Codegen|Function} Itself or the generated function if finished
     * @throws {Error} If format parameter counts do not match
     */

    function Codegen(formatStringOrScope) {
        // note that explicit array handling below makes this ~50% faster

        // finish the function
        if (typeof formatStringOrScope !== "string") {
            var source = toString();
            if (codegen.verbose)
                console.log("codegen: " + source); // eslint-disable-line no-console
            source = "return " + source;
            if (formatStringOrScope) {
                var scopeKeys   = Object.keys(formatStringOrScope),
                    scopeParams = new Array(scopeKeys.length + 1),
                    scopeValues = new Array(scopeKeys.length),
                    scopeOffset = 0;
                while (scopeOffset < scopeKeys.length) {
                    scopeParams[scopeOffset] = scopeKeys[scopeOffset];
                    scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
                }
                scopeParams[scopeOffset] = source;
                return Function.apply(null, scopeParams).apply(null, scopeValues); // eslint-disable-line no-new-func
            }
            return Function(source)(); // eslint-disable-line no-new-func
        }

        // otherwise append to body
        var formatParams = new Array(arguments.length - 1),
            formatOffset = 0;
        while (formatOffset < formatParams.length)
            formatParams[formatOffset] = arguments[++formatOffset];
        formatOffset = 0;
        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
            var value = formatParams[formatOffset++];
            switch ($1) {
                case "d": case "f": return String(Number(value));
                case "i": return String(Math.floor(value));
                case "j": return JSON.stringify(value);
                case "s": return String(value);
            }
            return "%";
        });
        if (formatOffset !== formatParams.length)
            throw Error("parameter count mismatch");
        body.push(formatStringOrScope);
        return Codegen;
    }

    function toString(functionNameOverride) {
        return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
    }

    Codegen.toString = toString;
    return Codegen;
}

/**
 * Begins generating a function.
 * @memberof util
 * @function codegen
 * @param {string} [functionName] Function name if not anonymous
 * @returns {Codegen} Appender that appends code to the function's body
 * @variation 2
 */

/**
 * When set to `true`, codegen will log generated code to console. Useful for debugging.
 * @name util.codegen.verbose
 * @type {boolean}
 */
codegen.verbose = false;

},{}],4:[function(require,module,exports){
"use strict";
module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};

},{}],5:[function(require,module,exports){
"use strict";
module.exports = fetch;

var asPromise = require("@protobufjs/aspromise"),
    inquire   = require("@protobufjs/inquire");

var fs = inquire("fs");

/**
 * Node-style callback as used by {@link util.fetch}.
 * @typedef FetchCallback
 * @type {function}
 * @param {?Error} error Error, if any, otherwise `null`
 * @param {string} [contents] File contents, if there hasn't been an error
 * @returns {undefined}
 */

/**
 * Options as used by {@link util.fetch}.
 * @typedef FetchOptions
 * @type {Object}
 * @property {boolean} [binary=false] Whether expecting a binary response
 * @property {boolean} [xhr=false] If `true`, forces the use of XMLHttpRequest
 */

/**
 * Fetches the contents of a file.
 * @memberof util
 * @param {string} filename File path or url
 * @param {FetchOptions} options Fetch options
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 */
function fetch(filename, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = {};
    } else if (!options)
        options = {};

    if (!callback)
        return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this

    // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.
    if (!options.xhr && fs && fs.readFile)
        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
            return err && typeof XMLHttpRequest !== "undefined"
                ? fetch.xhr(filename, options, callback)
                : err
                ? callback(err)
                : callback(null, options.binary ? contents : contents.toString("utf8"));
        });

    // use the XHR version otherwise.
    return fetch.xhr(filename, options, callback);
}

/**
 * Fetches the contents of a file.
 * @name util.fetch
 * @function
 * @param {string} path File path or url
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 * @variation 2
 */

/**
 * Fetches the contents of a file.
 * @name util.fetch
 * @function
 * @param {string} path File path or url
 * @param {FetchOptions} [options] Fetch options
 * @returns {Promise<string|Uint8Array>} Promise
 * @variation 3
 */

/**/
fetch.xhr = function fetch_xhr(filename, options, callback) {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange /* works everywhere */ = function fetchOnReadyStateChange() {

        if (xhr.readyState !== 4)
            return undefined;

        // local cors security errors return status 0 / empty string, too. afaik this cannot be
        // reliably distinguished from an actually empty file for security reasons. feel free
        // to send a pull request if you are aware of a solution.
        if (xhr.status !== 0 && xhr.status !== 200)
            return callback(Error("status " + xhr.status));

        // if binary data is expected, make sure that some sort of array is returned, even if
        // ArrayBuffers are not supported. the binary string fallback, however, is unsafe.
        if (options.binary) {
            var buffer = xhr.response;
            if (!buffer) {
                buffer = [];
                for (var i = 0; i < xhr.responseText.length; ++i)
                    buffer.push(xhr.responseText.charCodeAt(i) & 255);
            }
            return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
        }
        return callback(null, xhr.responseText);
    };

    if (options.binary) {
        // ref: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data#Receiving_binary_data_in_older_browsers
        if ("overrideMimeType" in xhr)
            xhr.overrideMimeType("text/plain; charset=x-user-defined");
        xhr.responseType = "arraybuffer";
    }

    xhr.open("GET", filename);
    xhr.send();
};

},{"@protobufjs/aspromise":1,"@protobufjs/inquire":7}],6:[function(require,module,exports){
"use strict";

module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}

},{}],7:[function(require,module,exports){
"use strict";
module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}

},{}],8:[function(require,module,exports){
"use strict";

/**
 * A minimal path module to resolve Unix, Windows and URL paths alike.
 * @memberof util
 * @namespace
 */
var path = exports;

var isAbsolute =
/**
 * Tests if the specified path is absolute.
 * @param {string} path Path to test
 * @returns {boolean} `true` if path is absolute
 */
path.isAbsolute = function isAbsolute(path) {
    return /^(?:\/|\w+:)/.test(path);
};

var normalize =
/**
 * Normalizes the specified path.
 * @param {string} path Path to normalize
 * @returns {string} Normalized path
 */
path.normalize = function normalize(path) {
    path = path.replace(/\\/g, "/")
               .replace(/\/{2,}/g, "/");
    var parts    = path.split("/"),
        absolute = isAbsolute(path),
        prefix   = "";
    if (absolute)
        prefix = parts.shift() + "/";
    for (var i = 0; i < parts.length;) {
        if (parts[i] === "..") {
            if (i > 0 && parts[i - 1] !== "..")
                parts.splice(--i, 2);
            else if (absolute)
                parts.splice(i, 1);
            else
                ++i;
        } else if (parts[i] === ".")
            parts.splice(i, 1);
        else
            ++i;
    }
    return prefix + parts.join("/");
};

/**
 * Resolves the specified include path against the specified origin path.
 * @param {string} originPath Path to the origin file
 * @param {string} includePath Include path relative to origin path
 * @param {boolean} [alreadyNormalized=false] `true` if both paths are already known to be normalized
 * @returns {string} Path to the include file
 */
path.resolve = function resolve(originPath, includePath, alreadyNormalized) {
    if (!alreadyNormalized)
        includePath = normalize(includePath);
    if (isAbsolute(includePath))
        return includePath;
    if (!alreadyNormalized)
        originPath = normalize(originPath);
    return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
};

},{}],9:[function(require,module,exports){
"use strict";
module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}

},{}],10:[function(require,module,exports){
"use strict";

/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};

},{}],11:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],12:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.map');
module.exports = require('../modules/_core').Map;

},{"../modules/_core":22,"../modules/es6.map":76,"../modules/es6.object.to-string":77,"../modules/es6.string.iterator":78,"../modules/web.dom.iterable":79}],13:[function(require,module,exports){
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],14:[function(require,module,exports){
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./_wks')('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) require('./_hide')(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

},{"./_hide":33,"./_wks":73}],15:[function(require,module,exports){
module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

},{}],16:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":39}],17:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-absolute-index":65,"./_to-iobject":67,"./_to-length":68}],18:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":19,"./_wks":73}],19:[function(require,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],20:[function(require,module,exports){
'use strict';
var dP = require('./_object-dp').f;
var create = require('./_object-create');
var redefineAll = require('./_redefine-all');
var ctx = require('./_ctx');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var $iterDefine = require('./_iter-define');
var step = require('./_iter-step');
var setSpecies = require('./_set-species');
var DESCRIPTORS = require('./_descriptors');
var fastKey = require('./_meta').fastKey;
var validate = require('./_validate-collection');
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

},{"./_an-instance":15,"./_ctx":23,"./_descriptors":25,"./_for-of":30,"./_iter-define":42,"./_iter-step":44,"./_meta":47,"./_object-create":48,"./_object-dp":49,"./_redefine-all":57,"./_set-species":60,"./_validate-collection":72}],21:[function(require,module,exports){
'use strict';
var global = require('./_global');
var $export = require('./_export');
var redefine = require('./_redefine');
var redefineAll = require('./_redefine-all');
var meta = require('./_meta');
var forOf = require('./_for-of');
var anInstance = require('./_an-instance');
var isObject = require('./_is-object');
var fails = require('./_fails');
var $iterDetect = require('./_iter-detect');
var setToStringTag = require('./_set-to-string-tag');
var inheritIfRequired = require('./_inherit-if-required');

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

},{"./_an-instance":15,"./_export":28,"./_fails":29,"./_for-of":30,"./_global":31,"./_inherit-if-required":36,"./_is-object":39,"./_iter-detect":43,"./_meta":47,"./_redefine":58,"./_redefine-all":57,"./_set-to-string-tag":61}],22:[function(require,module,exports){
var core = module.exports = { version: '2.5.7' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],23:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":13}],24:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],25:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":29}],26:[function(require,module,exports){
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":31,"./_is-object":39}],27:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],28:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var hide = require('./_hide');
var redefine = require('./_redefine');
var ctx = require('./_ctx');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_core":22,"./_ctx":23,"./_global":31,"./_hide":33,"./_redefine":58}],29:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],30:[function(require,module,exports){
var ctx = require('./_ctx');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var anObject = require('./_an-object');
var toLength = require('./_to-length');
var getIterFn = require('./core.get-iterator-method');
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;

},{"./_an-object":16,"./_ctx":23,"./_is-array-iter":38,"./_iter-call":40,"./_to-length":68,"./core.get-iterator-method":74}],31:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],32:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],33:[function(require,module,exports){
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":25,"./_object-dp":49,"./_property-desc":56}],34:[function(require,module,exports){
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":31}],35:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":25,"./_dom-create":26,"./_fails":29}],36:[function(require,module,exports){
var isObject = require('./_is-object');
var setPrototypeOf = require('./_set-proto').set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};

},{"./_is-object":39,"./_set-proto":59}],37:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":19}],38:[function(require,module,exports){
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":45,"./_wks":73}],39:[function(require,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],40:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"./_an-object":16}],41:[function(require,module,exports){
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_hide":33,"./_object-create":48,"./_property-desc":56,"./_set-to-string-tag":61,"./_wks":73}],42:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_export":28,"./_hide":33,"./_iter-create":41,"./_iterators":45,"./_library":46,"./_object-gpo":52,"./_redefine":58,"./_set-to-string-tag":61,"./_wks":73}],43:[function(require,module,exports){
var ITERATOR = require('./_wks')('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

},{"./_wks":73}],44:[function(require,module,exports){
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],45:[function(require,module,exports){
module.exports = {};

},{}],46:[function(require,module,exports){
module.exports = false;

},{}],47:[function(require,module,exports){
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !require('./_fails')(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"./_fails":29,"./_has":32,"./_is-object":39,"./_object-dp":49,"./_uid":71}],48:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":16,"./_dom-create":26,"./_enum-bug-keys":27,"./_html":34,"./_object-dps":50,"./_shared-key":62}],49:[function(require,module,exports){
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":16,"./_descriptors":25,"./_ie8-dom-define":35,"./_to-primitive":70}],50:[function(require,module,exports){
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_an-object":16,"./_descriptors":25,"./_object-dp":49,"./_object-keys":54}],51:[function(require,module,exports){
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_descriptors":25,"./_has":32,"./_ie8-dom-define":35,"./_object-pie":55,"./_property-desc":56,"./_to-iobject":67,"./_to-primitive":70}],52:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":32,"./_shared-key":62,"./_to-object":69}],53:[function(require,module,exports){
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_array-includes":17,"./_has":32,"./_shared-key":62,"./_to-iobject":67}],54:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_enum-bug-keys":27,"./_object-keys-internal":53}],55:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;

},{}],56:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],57:[function(require,module,exports){
var redefine = require('./_redefine');
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};

},{"./_redefine":58}],58:[function(require,module,exports){
var global = require('./_global');
var hide = require('./_hide');
var has = require('./_has');
var SRC = require('./_uid')('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

require('./_core').inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

},{"./_core":22,"./_global":31,"./_has":32,"./_hide":33,"./_uid":71}],59:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object');
var anObject = require('./_an-object');
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

},{"./_an-object":16,"./_ctx":23,"./_is-object":39,"./_object-gopd":51}],60:[function(require,module,exports){
'use strict';
var global = require('./_global');
var dP = require('./_object-dp');
var DESCRIPTORS = require('./_descriptors');
var SPECIES = require('./_wks')('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};

},{"./_descriptors":25,"./_global":31,"./_object-dp":49,"./_wks":73}],61:[function(require,module,exports){
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_has":32,"./_object-dp":49,"./_wks":73}],62:[function(require,module,exports){
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":63,"./_uid":71}],63:[function(require,module,exports){
var core = require('./_core');
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: require('./_library') ? 'pure' : 'global',
  copyright: '© 2018 Denis Pushkarev (zloirock.ru)'
});

},{"./_core":22,"./_global":31,"./_library":46}],64:[function(require,module,exports){
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_defined":24,"./_to-integer":66}],65:[function(require,module,exports){
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":66}],66:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],67:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_defined":24,"./_iobject":37}],68:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":66}],69:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":24}],70:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":39}],71:[function(require,module,exports){
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],72:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

},{"./_is-object":39}],73:[function(require,module,exports){
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_global":31,"./_shared":63,"./_uid":71}],74:[function(require,module,exports){
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":18,"./_core":22,"./_iterators":45,"./_wks":73}],75:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":14,"./_iter-define":42,"./_iter-step":44,"./_iterators":45,"./_to-iobject":67}],76:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var MAP = 'Map';

// 23.1 Map Objects
module.exports = require('./_collection')(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

},{"./_collection":21,"./_collection-strong":20,"./_validate-collection":72}],77:[function(require,module,exports){
'use strict';
// 19.1.3.6 Object.prototype.toString()
var classof = require('./_classof');
var test = {};
test[require('./_wks')('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  require('./_redefine')(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}

},{"./_classof":18,"./_redefine":58,"./_wks":73}],78:[function(require,module,exports){
'use strict';
var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"./_iter-define":42,"./_string-at":64}],79:[function(require,module,exports){
var $iterators = require('./es6.array.iterator');
var getKeys = require('./_object-keys');
var redefine = require('./_redefine');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var wks = require('./_wks');
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}

},{"./_global":31,"./_hide":33,"./_iterators":45,"./_object-keys":54,"./_redefine":58,"./_wks":73,"./es6.array.iterator":75}],80:[function(require,module,exports){
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    define(factory);
  } else if (typeof module === 'object' && module.exports) {
    module.exports = factory();
  } else {
    root.prefix = factory(root);
  }
}(this, function (root) {
  'use strict';

  var merge = function merge(target) {
    var i = 1;
    var length = arguments.length;
    var key;
    for (; i < length; i++) {
      for (key in arguments[i]) {
        if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
          target[key] = arguments[i][key];
        }
      }
    }
    return target;
  };

  var defaults = {
    template: '[%t] %l:',
    timestampFormatter: function (date) {
      return date.toTimeString().replace(/.*(\d{2}:\d{2}:\d{2}).*/, '$1');
    },
    levelFormatter: function (level) {
      return level.toUpperCase();
    },
    nameFormatter: function (name) {
      return name || 'root';
    }
  };

  var loglevel;
  var originalFactory;
  var pluginFactory;

  var apply = function apply(logger, options) {
    if (!logger || !logger.getLogger) {
      throw new TypeError('Argument is not a root loglevel object');
    }

    if (loglevel && pluginFactory !== logger.methodFactory) {
      throw new Error("You can't reassign a plugin after appling another plugin");
    }

    loglevel = logger;

    options = merge({}, defaults, options);

    originalFactory = originalFactory || logger.methodFactory;

    pluginFactory = function methodFactory(methodName, logLevel, loggerName) {
      var rawMethod = originalFactory(methodName, logLevel, loggerName);

      var hasTimestamp = options.template.indexOf('%t') !== -1;
      var hasLevel = options.template.indexOf('%l') !== -1;
      var hasName = options.template.indexOf('%n') !== -1;

      return function () {
        var content = options.template;

        var length = arguments.length;
        var args = Array(length);
        var key = 0;
        for (; key < length; key++) {
          args[key] = arguments[key];
        }

        if (hasTimestamp) content = content.replace(/%t/, options.timestampFormatter(new Date()));
        if (hasLevel) content = content.replace(/%l/, options.levelFormatter(methodName));
        if (hasName) content = content.replace(/%n/, options.nameFormatter(loggerName));

        if (args.length && typeof args[0] === 'string') {
          // concat prefix with first argument to support string substitutions
          args[0] = '' + content + ' ' + args[0];
        } else {
          args.unshift(content);
        }

        rawMethod.apply(undefined, args);
      };
    };

    logger.methodFactory = pluginFactory;
    logger.setLevel(logger.getLevel());
    return logger;
  };

  var disable = function disable() {
    if (!loglevel) {
      throw new Error("You can't disable a not appled plugin");
    }

    if (pluginFactory !== loglevel.methodFactory) {
      throw new Error("You can't disable a plugin after appling another plugin");
    }

    loglevel.methodFactory = originalFactory;
    loglevel.setLevel(loglevel.getLevel());
    originalFactory = undefined;
    loglevel = undefined;
  };

  var api = {
    apply: apply,
    disable: disable
  };

  var save;
  if (root) {
    save = root.prefix;
    api.noConflict = function () {
      if (root.prefix === api) {
        root.prefix = save;
      }
      return api;
    };
  }

  return api;
}));

},{}],81:[function(require,module,exports){
/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (typeof define === 'function' && define.amd) {
        define(definition);
    } else if (typeof module === 'object' && module.exports) {
        module.exports = definition();
    } else {
        root.log = definition();
    }
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      var storageKey = "loglevel";
      if (name) {
        storageKey += ":" + name;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Top-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    return defaultLogger;
}));

},{}],82:[function(require,module,exports){
/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
 Copyright 2009 The Closure Library Authors. All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS-IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/long.js for details
 */
(function(global, factory) {

    /* AMD */ if (typeof define === 'function' && define["amd"])
        define([], factory);
    /* CommonJS */ else if (typeof require === 'function' && typeof module === "object" && module && module["exports"])
        module["exports"] = factory();
    /* Global */ else
        (global["dcodeIO"] = global["dcodeIO"] || {})["Long"] = factory();

})(this, function() {
    "use strict";

    /**
     * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
     *  See the from* functions below for more convenient ways of constructing Longs.
     * @exports Long
     * @class A Long class for representing a 64 bit two's-complement integer value.
     * @param {number} low The low (signed) 32 bits of the long
     * @param {number} high The high (signed) 32 bits of the long
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @constructor
     */
    function Long(low, high, unsigned) {

        /**
         * The low 32 bits as a signed value.
         * @type {number}
         */
        this.low = low | 0;

        /**
         * The high 32 bits as a signed value.
         * @type {number}
         */
        this.high = high | 0;

        /**
         * Whether unsigned or not.
         * @type {boolean}
         */
        this.unsigned = !!unsigned;
    }

    // The internal representation of a long is the two given signed, 32-bit values.
    // We use 32-bit pieces because these are the size of integers on which
    // Javascript performs bit-operations.  For operations like addition and
    // multiplication, we split each number into 16 bit pieces, which can easily be
    // multiplied within Javascript's floating-point representation without overflow
    // or change in sign.
    //
    // In the algorithms below, we frequently reduce the negative case to the
    // positive case by negating the input(s) and then post-processing the result.
    // Note that we must ALWAYS check specially whether those values are MIN_VALUE
    // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
    // a positive number, it overflows back into a negative).  Not handling this
    // case would often result in infinite recursion.
    //
    // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
    // methods on which they depend.

    /**
     * An indicator used to reliably determine if an object is a Long or not.
     * @type {boolean}
     * @const
     * @private
     */
    Long.prototype.__isLong__;

    Object.defineProperty(Long.prototype, "__isLong__", {
        value: true,
        enumerable: false,
        configurable: false
    });

    /**
     * @function
     * @param {*} obj Object
     * @returns {boolean}
     * @inner
     */
    function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
    }

    /**
     * Tests if the specified object is a Long.
     * @function
     * @param {*} obj Object
     * @returns {boolean}
     */
    Long.isLong = isLong;

    /**
     * A cache of the Long representations of small integer values.
     * @type {!Object}
     * @inner
     */
    var INT_CACHE = {};

    /**
     * A cache of the Long representations of small unsigned integer values.
     * @type {!Object}
     * @inner
     */
    var UINT_CACHE = {};

    /**
     * @param {number} value
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromInt(value, unsigned) {
        var obj, cachedObj, cache;
        if (unsigned) {
            value >>>= 0;
            if (cache = (0 <= value && value < 256)) {
                cachedObj = UINT_CACHE[value];
                if (cachedObj)
                    return cachedObj;
            }
            obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
            if (cache)
                UINT_CACHE[value] = obj;
            return obj;
        } else {
            value |= 0;
            if (cache = (-128 <= value && value < 128)) {
                cachedObj = INT_CACHE[value];
                if (cachedObj)
                    return cachedObj;
            }
            obj = fromBits(value, value < 0 ? -1 : 0, false);
            if (cache)
                INT_CACHE[value] = obj;
            return obj;
        }
    }

    /**
     * Returns a Long representing the given 32 bit integer value.
     * @function
     * @param {number} value The 32 bit integer in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromInt = fromInt;

    /**
     * @param {number} value
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromNumber(value, unsigned) {
        if (isNaN(value) || !isFinite(value))
            return unsigned ? UZERO : ZERO;
        if (unsigned) {
            if (value < 0)
                return UZERO;
            if (value >= TWO_PWR_64_DBL)
                return MAX_UNSIGNED_VALUE;
        } else {
            if (value <= -TWO_PWR_63_DBL)
                return MIN_VALUE;
            if (value + 1 >= TWO_PWR_63_DBL)
                return MAX_VALUE;
        }
        if (value < 0)
            return fromNumber(-value, unsigned).neg();
        return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
    }

    /**
     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
     * @function
     * @param {number} value The number in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromNumber = fromNumber;

    /**
     * @param {number} lowBits
     * @param {number} highBits
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromBits(lowBits, highBits, unsigned) {
        return new Long(lowBits, highBits, unsigned);
    }

    /**
     * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
     *  assumed to use 32 bits.
     * @function
     * @param {number} lowBits The low 32 bits
     * @param {number} highBits The high 32 bits
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromBits = fromBits;

    /**
     * @function
     * @param {number} base
     * @param {number} exponent
     * @returns {number}
     * @inner
     */
    var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

    /**
     * @param {string} str
     * @param {(boolean|number)=} unsigned
     * @param {number=} radix
     * @returns {!Long}
     * @inner
     */
    function fromString(str, unsigned, radix) {
        if (str.length === 0)
            throw Error('empty string');
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
            return ZERO;
        if (typeof unsigned === 'number') {
            // For goog.math.long compatibility
            radix = unsigned,
            unsigned = false;
        } else {
            unsigned = !! unsigned;
        }
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
            throw RangeError('radix');

        var p;
        if ((p = str.indexOf('-')) > 0)
            throw Error('interior hyphen');
        else if (p === 0) {
            return fromString(str.substring(1), unsigned, radix).neg();
        }

        // Do several (8) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = fromNumber(pow_dbl(radix, 8));

        var result = ZERO;
        for (var i = 0; i < str.length; i += 8) {
            var size = Math.min(8, str.length - i),
                value = parseInt(str.substring(i, i + size), radix);
            if (size < 8) {
                var power = fromNumber(pow_dbl(radix, size));
                result = result.mul(power).add(fromNumber(value));
            } else {
                result = result.mul(radixToPower);
                result = result.add(fromNumber(value));
            }
        }
        result.unsigned = unsigned;
        return result;
    }

    /**
     * Returns a Long representation of the given string, written using the specified radix.
     * @function
     * @param {string} str The textual representation of the Long
     * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
     * @returns {!Long} The corresponding Long value
     */
    Long.fromString = fromString;

    /**
     * @function
     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
     * @returns {!Long}
     * @inner
     */
    function fromValue(val) {
        if (val /* is compatible */ instanceof Long)
            return val;
        if (typeof val === 'number')
            return fromNumber(val);
        if (typeof val === 'string')
            return fromString(val);
        // Throws for non-objects, converts non-instanceof Long:
        return fromBits(val.low, val.high, val.unsigned);
    }

    /**
     * Converts the specified value to a Long.
     * @function
     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
     * @returns {!Long}
     */
    Long.fromValue = fromValue;

    // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
    // no runtime penalty for these.

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_16_DBL = 1 << 16;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_24_DBL = 1 << 24;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

    /**
     * @type {!Long}
     * @const
     * @inner
     */
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

    /**
     * @type {!Long}
     * @inner
     */
    var ZERO = fromInt(0);

    /**
     * Signed zero.
     * @type {!Long}
     */
    Long.ZERO = ZERO;

    /**
     * @type {!Long}
     * @inner
     */
    var UZERO = fromInt(0, true);

    /**
     * Unsigned zero.
     * @type {!Long}
     */
    Long.UZERO = UZERO;

    /**
     * @type {!Long}
     * @inner
     */
    var ONE = fromInt(1);

    /**
     * Signed one.
     * @type {!Long}
     */
    Long.ONE = ONE;

    /**
     * @type {!Long}
     * @inner
     */
    var UONE = fromInt(1, true);

    /**
     * Unsigned one.
     * @type {!Long}
     */
    Long.UONE = UONE;

    /**
     * @type {!Long}
     * @inner
     */
    var NEG_ONE = fromInt(-1);

    /**
     * Signed negative one.
     * @type {!Long}
     */
    Long.NEG_ONE = NEG_ONE;

    /**
     * @type {!Long}
     * @inner
     */
    var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

    /**
     * Maximum signed value.
     * @type {!Long}
     */
    Long.MAX_VALUE = MAX_VALUE;

    /**
     * @type {!Long}
     * @inner
     */
    var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

    /**
     * Maximum unsigned value.
     * @type {!Long}
     */
    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

    /**
     * @type {!Long}
     * @inner
     */
    var MIN_VALUE = fromBits(0, 0x80000000|0, false);

    /**
     * Minimum signed value.
     * @type {!Long}
     */
    Long.MIN_VALUE = MIN_VALUE;

    /**
     * @alias Long.prototype
     * @inner
     */
    var LongPrototype = Long.prototype;

    /**
     * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
     * @returns {number}
     */
    LongPrototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
    };

    /**
     * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
     * @returns {number}
     */
    LongPrototype.toNumber = function toNumber() {
        if (this.unsigned)
            return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };

    /**
     * Converts the Long to a string written in the specified radix.
     * @param {number=} radix Radix (2-36), defaults to 10
     * @returns {string}
     * @override
     * @throws {RangeError} If `radix` is out of range
     */
    LongPrototype.toString = function toString(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
            throw RangeError('radix');
        if (this.isZero())
            return '0';
        if (this.isNegative()) { // Unsigned Longs are never negative
            if (this.eq(MIN_VALUE)) {
                // We need to change the Long value before it can be negated, so we remove
                // the bottom-most digit in this base and then recurse to do the rest.
                var radixLong = fromNumber(radix),
                    div = this.div(radixLong),
                    rem1 = div.mul(radixLong).sub(this);
                return div.toString(radix) + rem1.toInt().toString(radix);
            } else
                return '-' + this.neg().toString(radix);
        }

        // Do several (6) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
            rem = this;
        var result = '';
        while (true) {
            var remDiv = rem.div(radixToPower),
                intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
                digits = intval.toString(radix);
            rem = remDiv;
            if (rem.isZero())
                return digits + result;
            else {
                while (digits.length < 6)
                    digits = '0' + digits;
                result = '' + digits + result;
            }
        }
    };

    /**
     * Gets the high 32 bits as a signed integer.
     * @returns {number} Signed high bits
     */
    LongPrototype.getHighBits = function getHighBits() {
        return this.high;
    };

    /**
     * Gets the high 32 bits as an unsigned integer.
     * @returns {number} Unsigned high bits
     */
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
    };

    /**
     * Gets the low 32 bits as a signed integer.
     * @returns {number} Signed low bits
     */
    LongPrototype.getLowBits = function getLowBits() {
        return this.low;
    };

    /**
     * Gets the low 32 bits as an unsigned integer.
     * @returns {number} Unsigned low bits
     */
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
    };

    /**
     * Gets the number of bits needed to represent the absolute value of this Long.
     * @returns {number}
     */
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative()) // Unsigned Longs are never negative
            return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--)
            if ((val & (1 << bit)) != 0)
                break;
        return this.high != 0 ? bit + 33 : bit + 1;
    };

    /**
     * Tests if this Long's value equals zero.
     * @returns {boolean}
     */
    LongPrototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
    };

    /**
     * Tests if this Long's value is negative.
     * @returns {boolean}
     */
    LongPrototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
    };

    /**
     * Tests if this Long's value is positive.
     * @returns {boolean}
     */
    LongPrototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
    };

    /**
     * Tests if this Long's value is odd.
     * @returns {boolean}
     */
    LongPrototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
    };

    /**
     * Tests if this Long's value is even.
     * @returns {boolean}
     */
    LongPrototype.isEven = function isEven() {
        return (this.low & 1) === 0;
    };

    /**
     * Tests if this Long's value equals the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.equals = function equals(other) {
        if (!isLong(other))
            other = fromValue(other);
        if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
            return false;
        return this.high === other.high && this.low === other.low;
    };

    /**
     * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.eq = LongPrototype.equals;

    /**
     * Tests if this Long's value differs from the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.notEquals = function notEquals(other) {
        return !this.eq(/* validates */ other);
    };

    /**
     * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.neq = LongPrototype.notEquals;

    /**
     * Tests if this Long's value is less than the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lessThan = function lessThan(other) {
        return this.comp(/* validates */ other) < 0;
    };

    /**
     * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lt = LongPrototype.lessThan;

    /**
     * Tests if this Long's value is less than or equal the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.comp(/* validates */ other) <= 0;
    };

    /**
     * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lte = LongPrototype.lessThanOrEqual;

    /**
     * Tests if this Long's value is greater than the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.greaterThan = function greaterThan(other) {
        return this.comp(/* validates */ other) > 0;
    };

    /**
     * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.gt = LongPrototype.greaterThan;

    /**
     * Tests if this Long's value is greater than or equal the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.comp(/* validates */ other) >= 0;
    };

    /**
     * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;

    /**
     * Compares this Long's value with the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     */
    LongPrototype.compare = function compare(other) {
        if (!isLong(other))
            other = fromValue(other);
        if (this.eq(other))
            return 0;
        var thisNeg = this.isNegative(),
            otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
            return -1;
        if (!thisNeg && otherNeg)
            return 1;
        // At this point the sign bits are the same
        if (!this.unsigned)
            return this.sub(other).isNegative() ? -1 : 1;
        // Both are positive if at least one is unsigned
        return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
    };

    /**
     * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     */
    LongPrototype.comp = LongPrototype.compare;

    /**
     * Negates this Long's value.
     * @returns {!Long} Negated Long
     */
    LongPrototype.negate = function negate() {
        if (!this.unsigned && this.eq(MIN_VALUE))
            return MIN_VALUE;
        return this.not().add(ONE);
    };

    /**
     * Negates this Long's value. This is an alias of {@link Long#negate}.
     * @function
     * @returns {!Long} Negated Long
     */
    LongPrototype.neg = LongPrototype.negate;

    /**
     * Returns the sum of this and the specified Long.
     * @param {!Long|number|string} addend Addend
     * @returns {!Long} Sum
     */
    LongPrototype.add = function add(addend) {
        if (!isLong(addend))
            addend = fromValue(addend);

        // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = addend.high >>> 16;
        var b32 = addend.high & 0xFFFF;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 0xFFFF;

        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 + b48;
        c48 &= 0xFFFF;
        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns the difference of this and the specified Long.
     * @param {!Long|number|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     */
    LongPrototype.subtract = function subtract(subtrahend) {
        if (!isLong(subtrahend))
            subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
    };

    /**
     * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
     * @function
     * @param {!Long|number|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     */
    LongPrototype.sub = LongPrototype.subtract;

    /**
     * Returns the product of this and the specified Long.
     * @param {!Long|number|string} multiplier Multiplier
     * @returns {!Long} Product
     */
    LongPrototype.multiply = function multiply(multiplier) {
        if (this.isZero())
            return ZERO;
        if (!isLong(multiplier))
            multiplier = fromValue(multiplier);
        if (multiplier.isZero())
            return ZERO;
        if (this.eq(MIN_VALUE))
            return multiplier.isOdd() ? MIN_VALUE : ZERO;
        if (multiplier.eq(MIN_VALUE))
            return this.isOdd() ? MIN_VALUE : ZERO;

        if (this.isNegative()) {
            if (multiplier.isNegative())
                return this.neg().mul(multiplier.neg());
            else
                return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative())
            return this.mul(multiplier.neg()).neg();

        // If both longs are small, use float multiplication
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
            return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

        // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
        // We can skip products that would overflow.

        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 0xFFFF;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 0xFFFF;

        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 0xFFFF;
        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
     * @function
     * @param {!Long|number|string} multiplier Multiplier
     * @returns {!Long} Product
     */
    LongPrototype.mul = LongPrototype.multiply;

    /**
     * Returns this Long divided by the specified. The result is signed if this Long is signed or
     *  unsigned if this Long is unsigned.
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Quotient
     */
    LongPrototype.divide = function divide(divisor) {
        if (!isLong(divisor))
            divisor = fromValue(divisor);
        if (divisor.isZero())
            throw Error('division by zero');
        if (this.isZero())
            return this.unsigned ? UZERO : ZERO;
        var approx, rem, res;
        if (!this.unsigned) {
            // This section is only relevant for signed longs and is derived from the
            // closure library as a whole.
            if (this.eq(MIN_VALUE)) {
                if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                    return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
                else if (divisor.eq(MIN_VALUE))
                    return ONE;
                else {
                    // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                    var halfThis = this.shr(1);
                    approx = halfThis.div(divisor).shl(1);
                    if (approx.eq(ZERO)) {
                        return divisor.isNegative() ? ONE : NEG_ONE;
                    } else {
                        rem = this.sub(divisor.mul(approx));
                        res = approx.add(rem.div(divisor));
                        return res;
                    }
                }
            } else if (divisor.eq(MIN_VALUE))
                return this.unsigned ? UZERO : ZERO;
            if (this.isNegative()) {
                if (divisor.isNegative())
                    return this.neg().div(divisor.neg());
                return this.neg().div(divisor).neg();
            } else if (divisor.isNegative())
                return this.div(divisor.neg()).neg();
            res = ZERO;
        } else {
            // The algorithm below has not been made for unsigned longs. It's therefore
            // required to take special care of the MSB prior to running it.
            if (!divisor.unsigned)
                divisor = divisor.toUnsigned();
            if (divisor.gt(this))
                return UZERO;
            if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
                return UONE;
            res = UZERO;
        }

        // Repeat the following until the remainder is less than other:  find a
        // floating-point that approximates remainder / other *from below*, add this
        // into the result, and subtract it from the remainder.  It is critical that
        // the approximate value is less than or equal to the real value so that the
        // remainder never becomes negative.
        rem = this;
        while (rem.gte(divisor)) {
            // Approximate the result of division. This may be a little greater or
            // smaller than the actual value.
            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

            // We will tweak the approximate result by changing it in the 48-th digit or
            // the smallest non-fractional digit, whichever is larger.
            var log2 = Math.ceil(Math.log(approx) / Math.LN2),
                delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

            // Decrease the approximation until it is smaller than the remainder.  Note
            // that if it is too large, the product overflows and is negative.
                approxRes = fromNumber(approx),
                approxRem = approxRes.mul(divisor);
            while (approxRem.isNegative() || approxRem.gt(rem)) {
                approx -= delta;
                approxRes = fromNumber(approx, this.unsigned);
                approxRem = approxRes.mul(divisor);
            }

            // We know the answer can't be zero... and actually, zero would cause
            // infinite recursion since we would make no progress.
            if (approxRes.isZero())
                approxRes = ONE;

            res = res.add(approxRes);
            rem = rem.sub(approxRem);
        }
        return res;
    };

    /**
     * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
     * @function
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Quotient
     */
    LongPrototype.div = LongPrototype.divide;

    /**
     * Returns this Long modulo the specified.
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Remainder
     */
    LongPrototype.modulo = function modulo(divisor) {
        if (!isLong(divisor))
            divisor = fromValue(divisor);
        return this.sub(this.div(divisor).mul(divisor));
    };

    /**
     * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
     * @function
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Remainder
     */
    LongPrototype.mod = LongPrototype.modulo;

    /**
     * Returns the bitwise NOT of this Long.
     * @returns {!Long}
     */
    LongPrototype.not = function not() {
        return fromBits(~this.low, ~this.high, this.unsigned);
    };

    /**
     * Returns the bitwise AND of this Long and the specified.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.and = function and(other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };

    /**
     * Returns the bitwise OR of this Long and the specified.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.or = function or(other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };

    /**
     * Returns the bitwise XOR of this Long and the given one.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.xor = function xor(other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
            return this;
        else if (numBits < 32)
            return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
        else
            return fromBits(0, this.low << (numBits - 32), this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shl = LongPrototype.shiftLeft;

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftRight = function shiftRight(numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
            return this;
        else if (numBits < 32)
            return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
        else
            return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
    };

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shr = LongPrototype.shiftRight;

    /**
     * Returns this Long with bits logically shifted to the right by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        numBits &= 63;
        if (numBits === 0)
            return this;
        else {
            var high = this.high;
            if (numBits < 32) {
                var low = this.low;
                return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
            } else if (numBits === 32)
                return fromBits(high, 0, this.unsigned);
            else
                return fromBits(high >>> (numBits - 32), 0, this.unsigned);
        }
    };

    /**
     * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;

    /**
     * Converts this Long to signed.
     * @returns {!Long} Signed long
     */
    LongPrototype.toSigned = function toSigned() {
        if (!this.unsigned)
            return this;
        return fromBits(this.low, this.high, false);
    };

    /**
     * Converts this Long to unsigned.
     * @returns {!Long} Unsigned long
     */
    LongPrototype.toUnsigned = function toUnsigned() {
        if (this.unsigned)
            return this;
        return fromBits(this.low, this.high, true);
    };

    /**
     * Converts this Long to its byte representation.
     * @param {boolean=} le Whether little or big endian, defaults to big endian
     * @returns {!Array.<number>} Byte representation
     */
    LongPrototype.toBytes = function(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
    }

    /**
     * Converts this Long to its little endian byte representation.
     * @returns {!Array.<number>} Little endian byte representation
     */
    LongPrototype.toBytesLE = function() {
        var hi = this.high,
            lo = this.low;
        return [
             lo         & 0xff,
            (lo >>>  8) & 0xff,
            (lo >>> 16) & 0xff,
            (lo >>> 24) & 0xff,
             hi         & 0xff,
            (hi >>>  8) & 0xff,
            (hi >>> 16) & 0xff,
            (hi >>> 24) & 0xff
        ];
    }

    /**
     * Converts this Long to its big endian byte representation.
     * @returns {!Array.<number>} Big endian byte representation
     */
    LongPrototype.toBytesBE = function() {
        var hi = this.high,
            lo = this.low;
        return [
            (hi >>> 24) & 0xff,
            (hi >>> 16) & 0xff,
            (hi >>>  8) & 0xff,
             hi         & 0xff,
            (lo >>> 24) & 0xff,
            (lo >>> 16) & 0xff,
            (lo >>>  8) & 0xff,
             lo         & 0xff
        ];
    }

    return Long;
});

},{}],83:[function(require,module,exports){
// full library entry point.

"use strict";
module.exports = require("./src/index");

},{"./src/index":94}],84:[function(require,module,exports){
// light library entry point.

"use strict";
module.exports = require("./src/index-light");
},{"./src/index-light":92}],85:[function(require,module,exports){
// minimal library entry point.

"use strict";
module.exports = require("./src/index-minimal");

},{"./src/index-minimal":93}],86:[function(require,module,exports){
"use strict";
module.exports = common;

var commonRe = /\/|\./;

/**
 * Provides common type definitions.
 * Can also be used to provide additional google types or your own custom types.
 * @param {string} name Short name as in `google/protobuf/[name].proto` or full file name
 * @param {Object.<string,*>} json JSON definition within `google.protobuf` if a short name, otherwise the file's root definition
 * @returns {undefined}
 * @property {INamespace} google/protobuf/any.proto Any
 * @property {INamespace} google/protobuf/duration.proto Duration
 * @property {INamespace} google/protobuf/empty.proto Empty
 * @property {INamespace} google/protobuf/struct.proto Struct, Value, NullValue and ListValue
 * @property {INamespace} google/protobuf/timestamp.proto Timestamp
 * @property {INamespace} google/protobuf/wrappers.proto Wrappers
 * @example
 * // manually provides descriptor.proto (assumes google/protobuf/ namespace and .proto extension)
 * protobuf.common("descriptor", descriptorJson);
 *
 * // manually provides a custom definition (uses my.foo namespace)
 * protobuf.common("my/foo/bar.proto", myFooBarJson);
 */
function common(name, json) {
    if (!commonRe.test(name)) {
        name = "google/protobuf/" + name + ".proto";
        json = { nested: { google: { nested: { protobuf: { nested: json } } } } };
    }
    common[name] = json;
}

// Not provided because of limited use (feel free to discuss or to provide yourself):
//
// google/protobuf/descriptor.proto
// google/protobuf/field_mask.proto
// google/protobuf/source_context.proto
// google/protobuf/type.proto
//
// Stripped and pre-parsed versions of these non-bundled files are instead available as part of
// the repository or package within the google/protobuf directory.

common("any", {

    /**
     * Properties of a google.protobuf.Any message.
     * @interface IAny
     * @type {Object}
     * @property {string} [typeUrl]
     * @property {Uint8Array} [bytes]
     * @memberof common
     */
    Any: {
        fields: {
            type_url: {
                type: "string",
                id: 1
            },
            value: {
                type: "bytes",
                id: 2
            }
        }
    }
});

var timeType;

common("duration", {

    /**
     * Properties of a google.protobuf.Duration message.
     * @interface IDuration
     * @type {Object}
     * @property {number|Long} [seconds]
     * @property {number} [nanos]
     * @memberof common
     */
    Duration: timeType = {
        fields: {
            seconds: {
                type: "int64",
                id: 1
            },
            nanos: {
                type: "int32",
                id: 2
            }
        }
    }
});

common("timestamp", {

    /**
     * Properties of a google.protobuf.Timestamp message.
     * @interface ITimestamp
     * @type {Object}
     * @property {number|Long} [seconds]
     * @property {number} [nanos]
     * @memberof common
     */
    Timestamp: timeType
});

common("empty", {

    /**
     * Properties of a google.protobuf.Empty message.
     * @interface IEmpty
     * @memberof common
     */
    Empty: {
        fields: {}
    }
});

common("struct", {

    /**
     * Properties of a google.protobuf.Struct message.
     * @interface IStruct
     * @type {Object}
     * @property {Object.<string,IValue>} [fields]
     * @memberof common
     */
    Struct: {
        fields: {
            fields: {
                keyType: "string",
                type: "Value",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Value message.
     * @interface IValue
     * @type {Object}
     * @property {string} [kind]
     * @property {0} [nullValue]
     * @property {number} [numberValue]
     * @property {string} [stringValue]
     * @property {boolean} [boolValue]
     * @property {IStruct} [structValue]
     * @property {IListValue} [listValue]
     * @memberof common
     */
    Value: {
        oneofs: {
            kind: {
                oneof: [
                    "nullValue",
                    "numberValue",
                    "stringValue",
                    "boolValue",
                    "structValue",
                    "listValue"
                ]
            }
        },
        fields: {
            nullValue: {
                type: "NullValue",
                id: 1
            },
            numberValue: {
                type: "double",
                id: 2
            },
            stringValue: {
                type: "string",
                id: 3
            },
            boolValue: {
                type: "bool",
                id: 4
            },
            structValue: {
                type: "Struct",
                id: 5
            },
            listValue: {
                type: "ListValue",
                id: 6
            }
        }
    },

    NullValue: {
        values: {
            NULL_VALUE: 0
        }
    },

    /**
     * Properties of a google.protobuf.ListValue message.
     * @interface IListValue
     * @type {Object}
     * @property {Array.<IValue>} [values]
     * @memberof common
     */
    ListValue: {
        fields: {
            values: {
                rule: "repeated",
                type: "Value",
                id: 1
            }
        }
    }
});

common("wrappers", {

    /**
     * Properties of a google.protobuf.DoubleValue message.
     * @interface IDoubleValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    DoubleValue: {
        fields: {
            value: {
                type: "double",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.FloatValue message.
     * @interface IFloatValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    FloatValue: {
        fields: {
            value: {
                type: "float",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Int64Value message.
     * @interface IInt64Value
     * @type {Object}
     * @property {number|Long} [value]
     * @memberof common
     */
    Int64Value: {
        fields: {
            value: {
                type: "int64",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.UInt64Value message.
     * @interface IUInt64Value
     * @type {Object}
     * @property {number|Long} [value]
     * @memberof common
     */
    UInt64Value: {
        fields: {
            value: {
                type: "uint64",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Int32Value message.
     * @interface IInt32Value
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    Int32Value: {
        fields: {
            value: {
                type: "int32",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.UInt32Value message.
     * @interface IUInt32Value
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    UInt32Value: {
        fields: {
            value: {
                type: "uint32",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.BoolValue message.
     * @interface IBoolValue
     * @type {Object}
     * @property {boolean} [value]
     * @memberof common
     */
    BoolValue: {
        fields: {
            value: {
                type: "bool",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.StringValue message.
     * @interface IStringValue
     * @type {Object}
     * @property {string} [value]
     * @memberof common
     */
    StringValue: {
        fields: {
            value: {
                type: "string",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.BytesValue message.
     * @interface IBytesValue
     * @type {Object}
     * @property {Uint8Array} [value]
     * @memberof common
     */
    BytesValue: {
        fields: {
            value: {
                type: "bytes",
                id: 1
            }
        }
    }
});

/**
 * Gets the root definition of the specified common proto file.
 *
 * Bundled definitions are:
 * - google/protobuf/any.proto
 * - google/protobuf/duration.proto
 * - google/protobuf/empty.proto
 * - google/protobuf/struct.proto
 * - google/protobuf/timestamp.proto
 * - google/protobuf/wrappers.proto
 *
 * @param {string} file Proto file name
 * @returns {INamespace|null} Root definition or `null` if not defined
 */
common.get = function get(file) {
    return common[file] || null;
};

},{}],87:[function(require,module,exports){
"use strict";
/**
 * Runtime message from/to plain object converters.
 * @namespace
 */
var converter = exports;

var Enum = require("./enum"),
    util = require("./util");

/**
 * Generates a partial value fromObject conveter.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} prop Property reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) { gen
            ("switch(d%s){", prop);
            for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
                if (field.repeated && values[keys[i]] === field.typeDefault) gen
                ("default:");
                gen
                ("case%j:", keys[i])
                ("case %i:", values[keys[i]])
                    ("m%s=%j", prop, values[keys[i]])
                    ("break");
            } gen
            ("}");
        } else gen
            ("if(typeof d%s!==\"object\")", prop)
                ("throw TypeError(%j)", field.fullName + ": object expected")
            ("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
    } else {
        var isUnsigned = false;
        switch (field.type) {
            case "double":
            case "float": gen
                ("m%s=Number(d%s)", prop, prop); // also catches "NaN", "Infinity"
                break;
            case "uint32":
            case "fixed32": gen
                ("m%s=d%s>>>0", prop, prop);
                break;
            case "int32":
            case "sint32":
            case "sfixed32": gen
                ("m%s=d%s|0", prop, prop);
                break;
            case "uint64":
                isUnsigned = true;
                // eslint-disable-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
                ("if(util.Long)")
                    ("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)
                ("else if(typeof d%s===\"string\")", prop)
                    ("m%s=parseInt(d%s,10)", prop, prop)
                ("else if(typeof d%s===\"number\")", prop)
                    ("m%s=d%s", prop, prop)
                ("else if(typeof d%s===\"object\")", prop)
                    ("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
                break;
            case "bytes": gen
                ("if(typeof d%s===\"string\")", prop)
                    ("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)
                ("else if(d%s.length)", prop)
                    ("m%s=d%s", prop, prop);
                break;
            case "string": gen
                ("m%s=String(d%s)", prop, prop);
                break;
            case "bool": gen
                ("m%s=Boolean(d%s)", prop, prop);
                break;
            /* default: gen
                ("m%s=d%s", prop, prop);
                break; */
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

/**
 * Generates a plain object to runtime message converter specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
converter.fromObject = function fromObject(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var fields = mtype.fieldsArray;
    var gen = util.codegen(["d"], mtype.name + "$fromObject")
    ("if(d instanceof this.ctor)")
        ("return d");
    if (!fields.length) return gen
    ("return new this.ctor");
    gen
    ("var m=new this.ctor");
    for (var i = 0; i < fields.length; ++i) {
        var field  = fields[i].resolve(),
            prop   = util.safeProp(field.name);

        // Map fields
        if (field.map) { gen
    ("if(d%s){", prop)
        ("if(typeof d%s!==\"object\")", prop)
            ("throw TypeError(%j)", field.fullName + ": object expected")
        ("m%s={}", prop)
        ("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[ks[i]]")
        ("}")
    ("}");

        // Repeated fields
        } else if (field.repeated) { gen
    ("if(d%s){", prop)
        ("if(!Array.isArray(d%s))", prop)
            ("throw TypeError(%j)", field.fullName + ": array expected")
        ("m%s=[]", prop)
        ("for(var i=0;i<d%s.length;++i){", prop);
            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[i]")
        ("}")
    ("}");

        // Non-repeated fields
        } else {
            if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)
    ("if(d%s!=null){", prop); // !== undefined && !== null
        genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);
            if (!(field.resolvedType instanceof Enum)) gen
    ("}");
        }
    } return gen
    ("return m");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
};

/**
 * Generates a partial value toObject converter.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} prop Property reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genValuePartial_toObject(gen, field, fieldIndex, prop) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) gen
            ("d%s=o.enums===String?types[%i].values[m%s]:m%s", prop, fieldIndex, prop, prop);
        else gen
            ("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
    } else {
        var isUnsigned = false;
        switch (field.type) {
            case "double":
            case "float": gen
            ("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
                break;
            case "uint64":
                isUnsigned = true;
                // eslint-disable-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
            ("if(typeof m%s===\"number\")", prop)
                ("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)
            ("else") // Long-like
                ("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true": "", prop);
                break;
            case "bytes": gen
            ("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
                break;
            default: gen
            ("d%s=m%s", prop, prop);
                break;
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

/**
 * Generates a runtime message to plain object converter specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
converter.toObject = function toObject(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
    if (!fields.length)
        return util.codegen()("return {}");
    var gen = util.codegen(["m", "o"], mtype.name + "$toObject")
    ("if(!o)")
        ("o={}")
    ("var d={}");

    var repeatedFields = [],
        mapFields = [],
        normalFields = [],
        i = 0;
    for (; i < fields.length; ++i)
        if (!fields[i].partOf)
            ( fields[i].resolve().repeated ? repeatedFields
            : fields[i].map ? mapFields
            : normalFields).push(fields[i]);

    if (repeatedFields.length) { gen
    ("if(o.arrays||o.defaults){");
        for (i = 0; i < repeatedFields.length; ++i) gen
        ("d%s=[]", util.safeProp(repeatedFields[i].name));
        gen
    ("}");
    }

    if (mapFields.length) { gen
    ("if(o.objects||o.defaults){");
        for (i = 0; i < mapFields.length; ++i) gen
        ("d%s={}", util.safeProp(mapFields[i].name));
        gen
    ("}");
    }

    if (normalFields.length) { gen
    ("if(o.defaults){");
        for (i = 0; i < normalFields.length; ++i) {
            var field = normalFields[i],
                prop  = util.safeProp(field.name);
            if (field.resolvedType instanceof Enum) gen
        ("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
            else if (field.long) gen
        ("if(util.Long){")
            ("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)
            ("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)
        ("}else")
            ("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
            else if (field.bytes) gen
        ("d%s=o.bytes===String?%j:%s", prop, String.fromCharCode.apply(String, field.typeDefault), "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]");
            else gen
        ("d%s=%j", prop, field.typeDefault); // also messages (=null)
        } gen
    ("}");
    }
    var hasKs2 = false;
    for (i = 0; i < fields.length; ++i) {
        var field = fields[i],
            index = mtype._fieldsArray.indexOf(field),
            prop  = util.safeProp(field.name);
        if (field.map) {
            if (!hasKs2) { hasKs2 = true; gen
    ("var ks2");
            } gen
    ("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)
        ("d%s={}", prop)
        ("for(var j=0;j<ks2.length;++j){");
            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[ks2[j]]")
        ("}");
        } else if (field.repeated) { gen
    ("if(m%s&&m%s.length){", prop, prop)
        ("d%s=[]", prop)
        ("for(var j=0;j<m%s.length;++j){", prop);
            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[j]")
        ("}");
        } else { gen
    ("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name); // !== undefined && !== null
        genValuePartial_toObject(gen, field, /* sorted */ index, prop);
        if (field.partOf) gen
        ("if(o.oneofs)")
            ("d%s=%j", util.safeProp(field.partOf.name), field.name);
        }
        gen
    ("}");
    }
    return gen
    ("return d");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
};

},{"./enum":90,"./util":112}],88:[function(require,module,exports){
"use strict";
module.exports = decoder;

var Enum    = require("./enum"),
    types   = require("./types"),
    util    = require("./util");

function missing(field) {
    return "missing required '" + field.name + "'";
}

/**
 * Generates a decoder specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function decoder(mtype) {
    /* eslint-disable no-unexpected-multiline */
    var gen = util.codegen(["r", "l"], mtype.name + "$decode")
    ("if(!(r instanceof Reader))")
        ("r=Reader.create(r)")
    ("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field) { return field.map; }).length ? ",k" : ""))
    ("while(r.pos<c){")
        ("var t=r.uint32()");
    if (mtype.group) gen
        ("if((t&7)===4)")
            ("break");
    gen
        ("switch(t>>>3){");

    var i = 0;
    for (; i < /* initializes */ mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(),
            type  = field.resolvedType instanceof Enum ? "int32" : field.type,
            ref   = "m" + util.safeProp(field.name); gen
            ("case %i:", field.id);

        // Map fields
        if (field.map) { gen
                ("r.skip().pos++") // assumes id 1 + key wireType
                ("if(%s===util.emptyObject)", ref)
                    ("%s={}", ref)
                ("k=r.%s()", field.keyType)
                ("r.pos++"); // assumes id 2 + value wireType
            if (types.long[field.keyType] !== undefined) {
                if (types.basic[type] === undefined) gen
                ("%s[typeof k===\"object\"?util.longToHash(k):k]=types[%i].decode(r,r.uint32())", ref, i); // can't be groups
                else gen
                ("%s[typeof k===\"object\"?util.longToHash(k):k]=r.%s()", ref, type);
            } else {
                if (types.basic[type] === undefined) gen
                ("%s[k]=types[%i].decode(r,r.uint32())", ref, i); // can't be groups
                else gen
                ("%s[k]=r.%s()", ref, type);
            }

        // Repeated fields
        } else if (field.repeated) { gen

                ("if(!(%s&&%s.length))", ref, ref)
                    ("%s=[]", ref);

            // Packable (always check for forward and backward compatiblity)
            if (types.packed[type] !== undefined) gen
                ("if((t&7)===2){")
                    ("var c2=r.uint32()+r.pos")
                    ("while(r.pos<c2)")
                        ("%s.push(r.%s())", ref, type)
                ("}else");

            // Non-packed
            if (types.basic[type] === undefined) gen(field.resolvedType.group
                    ? "%s.push(types[%i].decode(r))"
                    : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);
            else gen
                    ("%s.push(r.%s())", ref, type);

        // Non-repeated
        } else if (types.basic[type] === undefined) gen(field.resolvedType.group
                ? "%s=types[%i].decode(r)"
                : "%s=types[%i].decode(r,r.uint32())", ref, i);
        else gen
                ("%s=r.%s()", ref, type);
        gen
                ("break");
    // Unknown fields
    } gen
            ("default:")
                ("r.skipType(t&7)")
                ("break")

        ("}")
    ("}");

    // Field presence
    for (i = 0; i < mtype._fieldsArray.length; ++i) {
        var rfield = mtype._fieldsArray[i];
        if (rfield.required) gen
    ("if(!m.hasOwnProperty(%j))", rfield.name)
        ("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
    }

    return gen
    ("return m");
    /* eslint-enable no-unexpected-multiline */
}

},{"./enum":90,"./types":111,"./util":112}],89:[function(require,module,exports){
"use strict";
module.exports = encoder;

var Enum     = require("./enum"),
    types    = require("./types"),
    util     = require("./util");

/**
 * Generates a partial message type encoder.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genTypePartial(gen, field, fieldIndex, ref) {
    return field.resolvedType.group
        ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0)
        : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
}

/**
 * Generates an encoder specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function encoder(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var gen = util.codegen(["m", "w"], mtype.name + "$encode")
    ("if(!w)")
        ("w=Writer.create()");

    var i, ref;

    // "when a message is serialized its known fields should be written sequentially by field number"
    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);

    for (var i = 0; i < fields.length; ++i) {
        var field    = fields[i].resolve(),
            index    = mtype._fieldsArray.indexOf(field),
            type     = field.resolvedType instanceof Enum ? "int32" : field.type,
            wireType = types.basic[type];
            ref      = "m" + util.safeProp(field.name);

        // Map fields
        if (field.map) {
            gen
    ("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name) // !== undefined && !== null
        ("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)
            ("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
            if (wireType === undefined) gen
            ("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref); // can't be groups
            else gen
            (".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
            gen
        ("}")
    ("}");

            // Repeated fields
        } else if (field.repeated) { gen
    ("if(%s!=null&&%s.length){", ref, ref); // !== undefined && !== null

            // Packed repeated
            if (field.packed && types.packed[type] !== undefined) { gen

        ("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)
        ("for(var i=0;i<%s.length;++i)", ref)
            ("w.%s(%s[i])", type, ref)
        ("w.ldelim()");

            // Non-packed
            } else { gen

        ("for(var i=0;i<%s.length;++i)", ref);
                if (wireType === undefined)
            genTypePartial(gen, field, index, ref + "[i]");
                else gen
            ("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);

            } gen
    ("}");

        // Non-repeated
        } else {
            if (field.optional) gen
    ("if(%s!=null&&m.hasOwnProperty(%j))", ref, field.name); // !== undefined && !== null

            if (wireType === undefined)
        genTypePartial(gen, field, index, ref);
            else gen
        ("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);

        }
    }

    return gen
    ("return w");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}
},{"./enum":90,"./types":111,"./util":112}],90:[function(require,module,exports){
"use strict";
module.exports = Enum;

// extends ReflectionObject
var ReflectionObject = require("./object");
((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";

var util = require("./util");

/**
 * Constructs a new enum instance.
 * @classdesc Reflected enum.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {Object.<string,number>} [values] Enum values as an object, by name
 * @param {Object.<string,*>} [options] Declared options
 */
function Enum(name, values, options) {
    ReflectionObject.call(this, name, options);

    if (values && typeof values !== "object")
        throw TypeError("values must be an object");

    /**
     * Enum values by id.
     * @type {Object.<number,string>}
     */
    this.valuesById = {};

    /**
     * Enum values by name.
     * @type {Object.<string,number>}
     */
    this.values = Object.create(this.valuesById); // toJSON, marker

    /**
     * Value comment texts, if any.
     * @type {Object.<string,string>}
     */
    this.comments = {};

    // Note that values inherit valuesById on their prototype which makes them a TypeScript-
    // compatible enum. This is used by pbts to write actual enum definitions that work for
    // static and reflection code alike instead of emitting generic object definitions.

    if (values)
        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)
            if (typeof values[keys[i]] === "number") // use forward entries only
                this.valuesById[ this.values[keys[i]] = values[keys[i]] ] = keys[i];
}

/**
 * Enum descriptor.
 * @interface IEnum
 * @property {Object.<string,number>} values Enum values
 * @property {Object.<string,*>} [options] Enum options
 */

/**
 * Constructs an enum from an enum descriptor.
 * @param {string} name Enum name
 * @param {IEnum} json Enum descriptor
 * @returns {Enum} Created enum
 * @throws {TypeError} If arguments are invalid
 */
Enum.fromJSON = function fromJSON(name, json) {
    return new Enum(name, json.values, json.options);
};

/**
 * Converts this enum to an enum descriptor.
 * @returns {IEnum} Enum descriptor
 */
Enum.prototype.toJSON = function toJSON() {
    return util.toObject([
        "options" , this.options,
        "values"  , this.values
    ]);
};

/**
 * Adds a value to this enum.
 * @param {string} name Value name
 * @param {number} id Value id
 * @param {string} [comment] Comment, if any
 * @returns {Enum} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a value with this name or id
 */
Enum.prototype.add = function(name, id, comment) {
    // utilized by the parser but not by .fromJSON

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (!util.isInteger(id))
        throw TypeError("id must be an integer");

    if (this.values[name] !== undefined)
        throw Error("duplicate name");

    if (this.valuesById[id] !== undefined) {
        if (!(this.options && this.options.allow_alias))
            throw Error("duplicate id");
        this.values[name] = id;
    } else
        this.valuesById[this.values[name] = id] = name;

    this.comments[name] = comment || null;
    return this;
};

/**
 * Removes a value from this enum
 * @param {string} name Value name
 * @returns {Enum} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `name` is not a name of this enum
 */
Enum.prototype.remove = function(name) {

    if (!util.isString(name))
        throw TypeError("name must be a string");

    var val = this.values[name];
    if (val === undefined)
        throw Error("name does not exist");

    delete this.valuesById[val];
    delete this.values[name];
    delete this.comments[name];

    return this;
};

},{"./object":99,"./util":112}],91:[function(require,module,exports){
"use strict";
module.exports = Field;

// extends ReflectionObject
var ReflectionObject = require("./object");
((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";

var Enum  = require("./enum"),
    types = require("./types"),
    util  = require("./util");

var Type; // cyclic

var ruleRe = /^required|optional|repeated$/;

/**
 * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.
 * @name Field
 * @classdesc Reflected message field.
 * @extends FieldBase
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} type Value type
 * @param {string|Object.<string,*>} [rule="optional"] Field rule
 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
 * @param {Object.<string,*>} [options] Declared options
 */

/**
 * Constructs a field from a field descriptor.
 * @param {string} name Field name
 * @param {IField} json Field descriptor
 * @returns {Field} Created field
 * @throws {TypeError} If arguments are invalid
 */
Field.fromJSON = function fromJSON(name, json) {
    return new Field(name, json.id, json.type, json.rule, json.extend, json.options);
};

/**
 * Not an actual constructor. Use {@link Field} instead.
 * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.
 * @exports FieldBase
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} type Value type
 * @param {string|Object.<string,*>} [rule="optional"] Field rule
 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
 * @param {Object.<string,*>} [options] Declared options
 */
function Field(name, id, type, rule, extend, options) {

    if (util.isObject(rule)) {
        options = rule;
        rule = extend = undefined;
    } else if (util.isObject(extend)) {
        options = extend;
        extend = undefined;
    }

    ReflectionObject.call(this, name, options);

    if (!util.isInteger(id) || id < 0)
        throw TypeError("id must be a non-negative integer");

    if (!util.isString(type))
        throw TypeError("type must be a string");

    if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase()))
        throw TypeError("rule must be a string rule");

    if (extend !== undefined && !util.isString(extend))
        throw TypeError("extend must be a string");

    /**
     * Field rule, if any.
     * @type {string|undefined}
     */
    this.rule = rule && rule !== "optional" ? rule : undefined; // toJSON

    /**
     * Field type.
     * @type {string}
     */
    this.type = type; // toJSON

    /**
     * Unique field id.
     * @type {number}
     */
    this.id = id; // toJSON, marker

    /**
     * Extended type if different from parent.
     * @type {string|undefined}
     */
    this.extend = extend || undefined; // toJSON

    /**
     * Whether this field is required.
     * @type {boolean}
     */
    this.required = rule === "required";

    /**
     * Whether this field is optional.
     * @type {boolean}
     */
    this.optional = !this.required;

    /**
     * Whether this field is repeated.
     * @type {boolean}
     */
    this.repeated = rule === "repeated";

    /**
     * Whether this field is a map or not.
     * @type {boolean}
     */
    this.map = false;

    /**
     * Message this field belongs to.
     * @type {Type|null}
     */
    this.message = null;

    /**
     * OneOf this field belongs to, if any,
     * @type {OneOf|null}
     */
    this.partOf = null;

    /**
     * The field type's default value.
     * @type {*}
     */
    this.typeDefault = null;

    /**
     * The field's default value on prototypes.
     * @type {*}
     */
    this.defaultValue = null;

    /**
     * Whether this field's value should be treated as a long.
     * @type {boolean}
     */
    this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */ false;

    /**
     * Whether this field's value is a buffer.
     * @type {boolean}
     */
    this.bytes = type === "bytes";

    /**
     * Resolved type if not a basic type.
     * @type {Type|Enum|null}
     */
    this.resolvedType = null;

    /**
     * Sister-field within the extended type if a declaring extension field.
     * @type {Field|null}
     */
    this.extensionField = null;

    /**
     * Sister-field within the declaring namespace if an extended field.
     * @type {Field|null}
     */
    this.declaringField = null;

    /**
     * Internally remembers whether this field is packed.
     * @type {boolean|null}
     * @private
     */
    this._packed = null;
}

/**
 * Determines whether this field is packed. Only relevant when repeated and working with proto2.
 * @name Field#packed
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(Field.prototype, "packed", {
    get: function() {
        // defaults to packed=true if not explicity set to false
        if (this._packed === null)
            this._packed = this.getOption("packed") !== false;
        return this._packed;
    }
});

/**
 * @override
 */
Field.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (name === "packed") // clear cached before setting
        this._packed = null;
    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
};

/**
 * Field descriptor.
 * @interface IField
 * @property {string} [rule="optional"] Field rule
 * @property {string} type Field type
 * @property {number} id Field id
 * @property {Object.<string,*>} [options] Field options
 */

/**
 * Extension field descriptor.
 * @interface IExtensionField
 * @extends IField
 * @property {string} extend Extended type
 */

/**
 * Converts this field to a field descriptor.
 * @returns {IField} Field descriptor
 */
Field.prototype.toJSON = function toJSON() {
    return util.toObject([
        "rule"    , this.rule !== "optional" && this.rule || undefined,
        "type"    , this.type,
        "id"      , this.id,
        "extend"  , this.extend,
        "options" , this.options
    ]);
};

/**
 * Resolves this field's type references.
 * @returns {Field} `this`
 * @throws {Error} If any reference cannot be resolved
 */
Field.prototype.resolve = function resolve() {

    if (this.resolved)
        return this;

    if ((this.typeDefault = types.defaults[this.type]) === undefined) { // if not a basic type, resolve it
        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
        if (this.resolvedType instanceof Type)
            this.typeDefault = null;
        else // instanceof Enum
            this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]; // first defined
    }

    // use explicitly set default value if present
    if (this.options && this.options["default"] != null) {
        this.typeDefault = this.options["default"];
        if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
            this.typeDefault = this.resolvedType.values[this.typeDefault];
    }

    // remove unnecessary options
    if (this.options) {
        if (this.options.packed === true || this.options.packed !== undefined && this.resolvedType && !(this.resolvedType instanceof Enum))
            delete this.options.packed;
        if (!Object.keys(this.options).length)
            this.options = undefined;
    }

    // convert to internal data type if necesssary
    if (this.long) {
        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");

        /* istanbul ignore else */
        if (Object.freeze)
            Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even requires it)

    } else if (this.bytes && typeof this.typeDefault === "string") {
        var buf;
        if (util.base64.test(this.typeDefault))
            util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);
        else
            util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
        this.typeDefault = buf;
    }

    // take special care of maps and repeated fields
    if (this.map)
        this.defaultValue = util.emptyObject;
    else if (this.repeated)
        this.defaultValue = util.emptyArray;
    else
        this.defaultValue = this.typeDefault;

    // ensure proper value on prototype
    if (this.parent instanceof Type)
        this.parent.ctor.prototype[this.name] = this.defaultValue;

    return ReflectionObject.prototype.resolve.call(this);
};

/**
 * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).
 * @typedef FieldDecorator
 * @type {function}
 * @param {Object} prototype Target prototype
 * @param {string} fieldName Field name
 * @returns {undefined}
 */

/**
 * Field decorator (TypeScript).
 * @name Field.d
 * @function
 * @param {number} fieldId Field id
 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"string"|"bool"|"bytes"|Object} fieldType Field type
 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
 * @param {T} [defaultValue] Default value
 * @returns {FieldDecorator} Decorator function
 * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]
 */
Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {

    // submessage: decorate the submessage and use its name as the type
    if (typeof fieldType === "function")
        fieldType = util.decorateType(fieldType).name;

    // enum reference: create a reflected copy of the enum and keep reuseing it
    else if (fieldType && typeof fieldType === "object")
        fieldType = util.decorateEnum(fieldType).name;

    return function fieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor)
            .add(new Field(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
    };
};

/**
 * Field decorator (TypeScript).
 * @name Field.d
 * @function
 * @param {number} fieldId Field id
 * @param {Constructor<T>|string} fieldType Field type
 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
 * @returns {FieldDecorator} Decorator function
 * @template T extends Message<T>
 * @variation 2
 */
// like Field.d but without a default value

Field._configure = function configure(Type_) {
    Type = Type_;
};

},{"./enum":90,"./object":99,"./types":111,"./util":112}],92:[function(require,module,exports){
"use strict";
var protobuf = module.exports = require("./index-minimal");

protobuf.build = "light";

/**
 * A node-style callback as used by {@link load} and {@link Root#load}.
 * @typedef LoadCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Root} [root] Root, if there hasn't been an error
 * @returns {undefined}
 */

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} root Root namespace, defaults to create a new one if omitted.
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @see {@link Root#load}
 */
function load(filename, root, callback) {
    if (typeof root === "function") {
        callback = root;
        root = new protobuf.Root();
    } else if (!root)
        root = new protobuf.Root();
    return root.load(filename, callback);
}

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @name load
 * @function
 * @param {string|string[]} filename One or multiple files to load
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @see {@link Root#load}
 * @variation 2
 */
// function load(filename:string, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.
 * @name load
 * @function
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
 * @returns {Promise<Root>} Promise
 * @see {@link Root#load}
 * @variation 3
 */
// function load(filename:string, [root:Root]):Promise<Root>

protobuf.load = load;

/**
 * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
 * @returns {Root} Root namespace
 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
 * @see {@link Root#loadSync}
 */
function loadSync(filename, root) {
    if (!root)
        root = new protobuf.Root();
    return root.loadSync(filename);
}

protobuf.loadSync = loadSync;

// Serialization
protobuf.encoder          = require("./encoder");
protobuf.decoder          = require("./decoder");
protobuf.verifier         = require("./verifier");
protobuf.converter        = require("./converter");

// Reflection
protobuf.ReflectionObject = require("./object");
protobuf.Namespace        = require("./namespace");
protobuf.Root             = require("./root");
protobuf.Enum             = require("./enum");
protobuf.Type             = require("./type");
protobuf.Field            = require("./field");
protobuf.OneOf            = require("./oneof");
protobuf.MapField         = require("./mapfield");
protobuf.Service          = require("./service");
protobuf.Method           = require("./method");

// Runtime
protobuf.Message          = require("./message");
protobuf.wrappers         = require("./wrappers");

// Utility
protobuf.types            = require("./types");
protobuf.util             = require("./util");

// Configure reflection
protobuf.ReflectionObject._configure(protobuf.Root);
protobuf.Namespace._configure(protobuf.Type, protobuf.Service);
protobuf.Root._configure(protobuf.Type);
protobuf.Field._configure(protobuf.Type);

},{"./converter":87,"./decoder":88,"./encoder":89,"./enum":90,"./field":91,"./index-minimal":93,"./mapfield":95,"./message":96,"./method":97,"./namespace":98,"./object":99,"./oneof":100,"./root":104,"./service":108,"./type":110,"./types":111,"./util":112,"./verifier":115,"./wrappers":116}],93:[function(require,module,exports){
"use strict";
var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = require("./writer");
protobuf.BufferWriter = require("./writer_buffer");
protobuf.Reader       = require("./reader");
protobuf.BufferReader = require("./reader_buffer");

// Utility
protobuf.util         = require("./util/minimal");
protobuf.rpc          = require("./rpc");
protobuf.roots        = require("./roots");
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.Reader._configure(protobuf.BufferReader);
    protobuf.util._configure();
}

// Configure serialization
protobuf.Writer._configure(protobuf.BufferWriter);
configure();

},{"./reader":102,"./reader_buffer":103,"./roots":105,"./rpc":106,"./util/minimal":114,"./writer":117,"./writer_buffer":118}],94:[function(require,module,exports){
"use strict";
var protobuf = module.exports = require("./index-light");

protobuf.build = "full";

// Parser
protobuf.tokenize         = require("./tokenize");
protobuf.parse            = require("./parse");
protobuf.common           = require("./common");

// Configure parser
protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);

},{"./common":86,"./index-light":92,"./parse":101,"./tokenize":109}],95:[function(require,module,exports){
"use strict";
module.exports = MapField;

// extends Field
var Field = require("./field");
((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";

var types   = require("./types"),
    util    = require("./util");

/**
 * Constructs a new map field instance.
 * @classdesc Reflected map field.
 * @extends FieldBase
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} keyType Key type
 * @param {string} type Value type
 * @param {Object.<string,*>} [options] Declared options
 */
function MapField(name, id, keyType, type, options) {
    Field.call(this, name, id, type, options);

    /* istanbul ignore if */
    if (!util.isString(keyType))
        throw TypeError("keyType must be a string");

    /**
     * Key type.
     * @type {string}
     */
    this.keyType = keyType; // toJSON, marker

    /**
     * Resolved key type if not a basic type.
     * @type {ReflectionObject|null}
     */
    this.resolvedKeyType = null;

    // Overrides Field#map
    this.map = true;
}

/**
 * Map field descriptor.
 * @interface IMapField
 * @extends {IField}
 * @property {string} keyType Key type
 */

/**
 * Extension map field descriptor.
 * @interface IExtensionMapField
 * @extends IMapField
 * @property {string} extend Extended type
 */

/**
 * Constructs a map field from a map field descriptor.
 * @param {string} name Field name
 * @param {IMapField} json Map field descriptor
 * @returns {MapField} Created map field
 * @throws {TypeError} If arguments are invalid
 */
MapField.fromJSON = function fromJSON(name, json) {
    return new MapField(name, json.id, json.keyType, json.type, json.options);
};

/**
 * Converts this map field to a map field descriptor.
 * @returns {IMapField} Map field descriptor
 */
MapField.prototype.toJSON = function toJSON() {
    return util.toObject([
        "keyType" , this.keyType,
        "type"    , this.type,
        "id"      , this.id,
        "extend"  , this.extend,
        "options" , this.options
    ]);
};

/**
 * @override
 */
MapField.prototype.resolve = function resolve() {
    if (this.resolved)
        return this;

    // Besides a value type, map fields have a key type that may be "any scalar type except for floating point types and bytes"
    if (types.mapKey[this.keyType] === undefined)
        throw Error("invalid key type: " + this.keyType);

    return Field.prototype.resolve.call(this);
};

/**
 * Map field decorator (TypeScript).
 * @name MapField.d
 * @function
 * @param {number} fieldId Field id
 * @param {"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"} fieldKeyType Field key type
 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"|"bytes"|Object|Constructor<{}>} fieldValueType Field value type
 * @returns {FieldDecorator} Decorator function
 * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }
 */
MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {

    // submessage value: decorate the submessage and use its name as the type
    if (typeof fieldValueType === "function")
        fieldValueType = util.decorateType(fieldValueType).name;

    // enum reference value: create a reflected copy of the enum and keep reuseing it
    else if (fieldValueType && typeof fieldValueType === "object")
        fieldValueType = util.decorateEnum(fieldValueType).name;

    return function mapFieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor)
            .add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
    };
};

},{"./field":91,"./types":111,"./util":112}],96:[function(require,module,exports){
"use strict";
module.exports = Message;

var util = require("./util/minimal");

/**
 * Constructs a new message instance.
 * @classdesc Abstract runtime message.
 * @constructor
 * @param {Properties<T>} [properties] Properties to set
 * @template T extends object
 */
function Message(properties) {
    // not used internally
    if (properties)
        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            this[keys[i]] = properties[keys[i]];
}

/**
 * Reference to the reflected type.
 * @name Message.$type
 * @type {Type}
 * @readonly
 */

/**
 * Reference to the reflected type.
 * @name Message#$type
 * @type {Type}
 * @readonly
 */

/*eslint-disable valid-jsdoc*/

/**
 * Creates a new message of this type using the specified properties.
 * @param {Object.<string,*>} [properties] Properties to set
 * @returns {Message<T>} Message instance
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.create = function create(properties) {
    return this.$type.create(properties);
};

/**
 * Encodes a message of this type.
 * @param {T|Object.<string,*>} message Message to encode
 * @param {Writer} [writer] Writer to use
 * @returns {Writer} Writer
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.encode = function encode(message, writer) {
    return this.$type.encode(message, writer);
};

/**
 * Encodes a message of this type preceeded by its length as a varint.
 * @param {T|Object.<string,*>} message Message to encode
 * @param {Writer} [writer] Writer to use
 * @returns {Writer} Writer
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.encodeDelimited = function encodeDelimited(message, writer) {
    return this.$type.encodeDelimited(message, writer);
};

/**
 * Decodes a message of this type.
 * @name Message.decode
 * @function
 * @param {Reader|Uint8Array} reader Reader or buffer to decode
 * @returns {T} Decoded message
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.decode = function decode(reader) {
    return this.$type.decode(reader);
};

/**
 * Decodes a message of this type preceeded by its length as a varint.
 * @name Message.decodeDelimited
 * @function
 * @param {Reader|Uint8Array} reader Reader or buffer to decode
 * @returns {T} Decoded message
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.decodeDelimited = function decodeDelimited(reader) {
    return this.$type.decodeDelimited(reader);
};

/**
 * Verifies a message of this type.
 * @name Message.verify
 * @function
 * @param {Object.<string,*>} message Plain object to verify
 * @returns {string|null} `null` if valid, otherwise the reason why it is not
 */
Message.verify = function verify(message) {
    return this.$type.verify(message);
};

/**
 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
 * @param {Object.<string,*>} object Plain object
 * @returns {T} Message instance
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.fromObject = function fromObject(object) {
    return this.$type.fromObject(object);
};

/**
 * Creates a plain object from a message of this type. Also converts values to other types if specified.
 * @param {T} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.toObject = function toObject(message, options) {
    return this.$type.toObject(message, options);
};

/**
 * Converts this message to JSON.
 * @returns {Object.<string,*>} JSON object
 */
Message.prototype.toJSON = function toJSON() {
    return this.$type.toObject(this, util.toJSONOptions);
};

/*eslint-enable valid-jsdoc*/
},{"./util/minimal":114}],97:[function(require,module,exports){
"use strict";
module.exports = Method;

// extends ReflectionObject
var ReflectionObject = require("./object");
((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";

var util = require("./util");

/**
 * Constructs a new service method instance.
 * @classdesc Reflected service method.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Method name
 * @param {string|undefined} type Method type, usually `"rpc"`
 * @param {string} requestType Request message type
 * @param {string} responseType Response message type
 * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed
 * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed
 * @param {Object.<string,*>} [options] Declared options
 */
function Method(name, type, requestType, responseType, requestStream, responseStream, options) {

    /* istanbul ignore next */
    if (util.isObject(requestStream)) {
        options = requestStream;
        requestStream = responseStream = undefined;
    } else if (util.isObject(responseStream)) {
        options = responseStream;
        responseStream = undefined;
    }

    /* istanbul ignore if */
    if (!(type === undefined || util.isString(type)))
        throw TypeError("type must be a string");

    /* istanbul ignore if */
    if (!util.isString(requestType))
        throw TypeError("requestType must be a string");

    /* istanbul ignore if */
    if (!util.isString(responseType))
        throw TypeError("responseType must be a string");

    ReflectionObject.call(this, name, options);

    /**
     * Method type.
     * @type {string}
     */
    this.type = type || "rpc"; // toJSON

    /**
     * Request type.
     * @type {string}
     */
    this.requestType = requestType; // toJSON, marker

    /**
     * Whether requests are streamed or not.
     * @type {boolean|undefined}
     */
    this.requestStream = requestStream ? true : undefined; // toJSON

    /**
     * Response type.
     * @type {string}
     */
    this.responseType = responseType; // toJSON

    /**
     * Whether responses are streamed or not.
     * @type {boolean|undefined}
     */
    this.responseStream = responseStream ? true : undefined; // toJSON

    /**
     * Resolved request type.
     * @type {Type|null}
     */
    this.resolvedRequestType = null;

    /**
     * Resolved response type.
     * @type {Type|null}
     */
    this.resolvedResponseType = null;
}

/**
 * Method descriptor.
 * @interface IMethod
 * @property {string} [type="rpc"] Method type
 * @property {string} requestType Request type
 * @property {string} responseType Response type
 * @property {boolean} [requestStream=false] Whether requests are streamed
 * @property {boolean} [responseStream=false] Whether responses are streamed
 * @property {Object.<string,*>} [options] Method options
 */

/**
 * Constructs a method from a method descriptor.
 * @param {string} name Method name
 * @param {IMethod} json Method descriptor
 * @returns {Method} Created method
 * @throws {TypeError} If arguments are invalid
 */
Method.fromJSON = function fromJSON(name, json) {
    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options);
};

/**
 * Converts this method to a method descriptor.
 * @returns {IMethod} Method descriptor
 */
Method.prototype.toJSON = function toJSON() {
    return util.toObject([
        "type"           , this.type !== "rpc" && /* istanbul ignore next */ this.type || undefined,
        "requestType"    , this.requestType,
        "requestStream"  , this.requestStream,
        "responseType"   , this.responseType,
        "responseStream" , this.responseStream,
        "options"        , this.options
    ]);
};

/**
 * @override
 */
Method.prototype.resolve = function resolve() {

    /* istanbul ignore if */
    if (this.resolved)
        return this;

    this.resolvedRequestType = this.parent.lookupType(this.requestType);
    this.resolvedResponseType = this.parent.lookupType(this.responseType);

    return ReflectionObject.prototype.resolve.call(this);
};

},{"./object":99,"./util":112}],98:[function(require,module,exports){
"use strict";
module.exports = Namespace;

// extends ReflectionObject
var ReflectionObject = require("./object");
((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";

var Enum     = require("./enum"),
    Field    = require("./field"),
    util     = require("./util");

var Type,    // cyclic
    Service; // "

/**
 * Constructs a new namespace instance.
 * @name Namespace
 * @classdesc Reflected namespace.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Namespace name
 * @param {Object.<string,*>} [options] Declared options
 */

/**
 * Constructs a namespace from JSON.
 * @memberof Namespace
 * @function
 * @param {string} name Namespace name
 * @param {Object.<string,*>} json JSON object
 * @returns {Namespace} Created namespace
 * @throws {TypeError} If arguments are invalid
 */
Namespace.fromJSON = function fromJSON(name, json) {
    return new Namespace(name, json.options).addJSON(json.nested);
};

/**
 * Converts an array of reflection objects to JSON.
 * @memberof Namespace
 * @param {ReflectionObject[]} array Object array
 * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty
 */
function arrayToJSON(array) {
    if (!(array && array.length))
        return undefined;
    var obj = {};
    for (var i = 0; i < array.length; ++i)
        obj[array[i].name] = array[i].toJSON();
    return obj;
}

Namespace.arrayToJSON = arrayToJSON;

/**
 * Not an actual constructor. Use {@link Namespace} instead.
 * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.
 * @exports NamespaceBase
 * @extends ReflectionObject
 * @abstract
 * @constructor
 * @param {string} name Namespace name
 * @param {Object.<string,*>} [options] Declared options
 * @see {@link Namespace}
 */
function Namespace(name, options) {
    ReflectionObject.call(this, name, options);

    /**
     * Nested objects by name.
     * @type {Object.<string,ReflectionObject>|undefined}
     */
    this.nested = undefined; // toJSON

    /**
     * Cached nested objects as an array.
     * @type {ReflectionObject[]|null}
     * @private
     */
    this._nestedArray = null;
}

function clearCache(namespace) {
    namespace._nestedArray = null;
    return namespace;
}

/**
 * Nested objects of this namespace as an array for iteration.
 * @name NamespaceBase#nestedArray
 * @type {ReflectionObject[]}
 * @readonly
 */
Object.defineProperty(Namespace.prototype, "nestedArray", {
    get: function() {
        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
    }
});

/**
 * Namespace descriptor.
 * @interface INamespace
 * @property {Object.<string,*>} [options] Namespace options
 * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors
 */

/**
 * Any extension field descriptor.
 * @typedef AnyExtensionField
 * @type {IExtensionField|IExtensionMapField}
 */

/**
 * Any nested object descriptor.
 * @typedef AnyNestedObject
 * @type {IEnum|IType|IService|AnyExtensionField|INamespace}
 */
// ^ BEWARE: VSCode hangs forever when using more than 5 types (that's why AnyExtensionField exists in the first place)

/**
 * Converts this namespace to a namespace descriptor.
 * @returns {INamespace} Namespace descriptor
 */
Namespace.prototype.toJSON = function toJSON() {
    return util.toObject([
        "options" , this.options,
        "nested"  , arrayToJSON(this.nestedArray)
    ]);
};

/**
 * Adds nested objects to this namespace from nested object descriptors.
 * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors
 * @returns {Namespace} `this`
 */
Namespace.prototype.addJSON = function addJSON(nestedJson) {
    var ns = this;
    /* istanbul ignore else */
    if (nestedJson) {
        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
            nested = nestedJson[names[i]];
            ns.add( // most to least likely
                ( nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : nested.id !== undefined
                ? Field.fromJSON
                : Namespace.fromJSON )(names[i], nested)
            );
        }
    }
    return this;
};

/**
 * Gets the nested object of the specified name.
 * @param {string} name Nested object name
 * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist
 */
Namespace.prototype.get = function get(name) {
    return this.nested && this.nested[name]
        || null;
};

/**
 * Gets the values of the nested {@link Enum|enum} of the specified name.
 * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.
 * @param {string} name Nested enum name
 * @returns {Object.<string,number>} Enum values
 * @throws {Error} If there is no such enum
 */
Namespace.prototype.getEnum = function getEnum(name) {
    if (this.nested && this.nested[name] instanceof Enum)
        return this.nested[name].values;
    throw Error("no such enum");
};

/**
 * Adds a nested object to this namespace.
 * @param {ReflectionObject} object Nested object to add
 * @returns {Namespace} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a nested object with this name
 */
Namespace.prototype.add = function add(object) {

    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type || object instanceof Enum || object instanceof Service || object instanceof Namespace))
        throw TypeError("object must be a valid nested object");

    if (!this.nested)
        this.nested = {};
    else {
        var prev = this.get(object.name);
        if (prev) {
            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
                // replace plain namespace but keep existing nested elements and options
                var nested = prev.nestedArray;
                for (var i = 0; i < nested.length; ++i)
                    object.add(nested[i]);
                this.remove(prev);
                if (!this.nested)
                    this.nested = {};
                object.setOptions(prev.options, true);

            } else
                throw Error("duplicate name '" + object.name + "' in " + this);
        }
    }
    this.nested[object.name] = object;
    object.onAdd(this);
    return clearCache(this);
};

/**
 * Removes a nested object from this namespace.
 * @param {ReflectionObject} object Nested object to remove
 * @returns {Namespace} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `object` is not a member of this namespace
 */
Namespace.prototype.remove = function remove(object) {

    if (!(object instanceof ReflectionObject))
        throw TypeError("object must be a ReflectionObject");
    if (object.parent !== this)
        throw Error(object + " is not a member of " + this);

    delete this.nested[object.name];
    if (!Object.keys(this.nested).length)
        this.nested = undefined;

    object.onRemove(this);
    return clearCache(this);
};

/**
 * Defines additial namespaces within this one if not yet existing.
 * @param {string|string[]} path Path to create
 * @param {*} [json] Nested types to create from JSON
 * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty
 */
Namespace.prototype.define = function define(path, json) {

    if (util.isString(path))
        path = path.split(".");
    else if (!Array.isArray(path))
        throw TypeError("illegal path");
    if (path && path.length && path[0] === "")
        throw Error("path must be relative");

    var ptr = this;
    while (path.length > 0) {
        var part = path.shift();
        if (ptr.nested && ptr.nested[part]) {
            ptr = ptr.nested[part];
            if (!(ptr instanceof Namespace))
                throw Error("path conflicts with non-namespace objects");
        } else
            ptr.add(ptr = new Namespace(part));
    }
    if (json)
        ptr.addJSON(json);
    return ptr;
};

/**
 * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.
 * @returns {Namespace} `this`
 */
Namespace.prototype.resolveAll = function resolveAll() {
    var nested = this.nestedArray, i = 0;
    while (i < nested.length)
        if (nested[i] instanceof Namespace)
            nested[i++].resolveAll();
        else
            nested[i++].resolve();
    return this.resolve();
};

/**
 * Recursively looks up the reflection object matching the specified path in the scope of this namespace.
 * @param {string|string[]} path Path to look up
 * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.
 * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked
 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
 */
Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {

    /* istanbul ignore next */
    if (typeof filterTypes === "boolean") {
        parentAlreadyChecked = filterTypes;
        filterTypes = undefined;
    } else if (filterTypes && !Array.isArray(filterTypes))
        filterTypes = [ filterTypes ];

    if (util.isString(path) && path.length) {
        if (path === ".")
            return this.root;
        path = path.split(".");
    } else if (!path.length)
        return this;

    // Start at root if path is absolute
    if (path[0] === "")
        return this.root.lookup(path.slice(1), filterTypes);

    // Test if the first part matches any nested object, and if so, traverse if path contains more
    var found = this.get(path[0]);
    if (found) {
        if (path.length === 1) {
            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)
                return found;
        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))
            return found;

    // Otherwise try each nested namespace
    } else
        for (var i = 0; i < this.nestedArray.length; ++i)
            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))
                return found;

    // If there hasn't been a match, try again at the parent
    if (this.parent === null || parentAlreadyChecked)
        return null;
    return this.parent.lookup(path, filterTypes);
};

/**
 * Looks up the reflection object at the specified path, relative to this namespace.
 * @name NamespaceBase#lookup
 * @function
 * @param {string|string[]} path Path to look up
 * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked
 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
 * @variation 2
 */
// lookup(path: string, [parentAlreadyChecked: boolean])

/**
 * Looks up the {@link Type|type} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Type} Looked up type
 * @throws {Error} If `path` does not point to a type
 */
Namespace.prototype.lookupType = function lookupType(path) {
    var found = this.lookup(path, [ Type ]);
    if (!found)
        throw Error("no such type");
    return found;
};

/**
 * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Enum} Looked up enum
 * @throws {Error} If `path` does not point to an enum
 */
Namespace.prototype.lookupEnum = function lookupEnum(path) {
    var found = this.lookup(path, [ Enum ]);
    if (!found)
        throw Error("no such Enum '" + path + "' in " + this);
    return found;
};

/**
 * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Type} Looked up type or enum
 * @throws {Error} If `path` does not point to a type or enum
 */
Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
    var found = this.lookup(path, [ Type, Enum ]);
    if (!found)
        throw Error("no such Type or Enum '" + path + "' in " + this);
    return found;
};

/**
 * Looks up the {@link Service|service} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Service} Looked up service
 * @throws {Error} If `path` does not point to a service
 */
Namespace.prototype.lookupService = function lookupService(path) {
    var found = this.lookup(path, [ Service ]);
    if (!found)
        throw Error("no such Service '" + path + "' in " + this);
    return found;
};

Namespace._configure = function(Type_, Service_) {
    Type    = Type_;
    Service = Service_;
};

},{"./enum":90,"./field":91,"./object":99,"./util":112}],99:[function(require,module,exports){
"use strict";
module.exports = ReflectionObject;

ReflectionObject.className = "ReflectionObject";

var util = require("./util");

var Root; // cyclic

/**
 * Constructs a new reflection object instance.
 * @classdesc Base class of all reflection objects.
 * @constructor
 * @param {string} name Object name
 * @param {Object.<string,*>} [options] Declared options
 * @abstract
 */
function ReflectionObject(name, options) {

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (options && !util.isObject(options))
        throw TypeError("options must be an object");

    /**
     * Options.
     * @type {Object.<string,*>|undefined}
     */
    this.options = options; // toJSON

    /**
     * Unique name within its namespace.
     * @type {string}
     */
    this.name = name;

    /**
     * Parent namespace.
     * @type {Namespace|null}
     */
    this.parent = null;

    /**
     * Whether already resolved or not.
     * @type {boolean}
     */
    this.resolved = false;

    /**
     * Comment text, if any.
     * @type {string|null}
     */
    this.comment = null;

    /**
     * Defining file name.
     * @type {string|null}
     */
    this.filename = null;
}

Object.defineProperties(ReflectionObject.prototype, {

    /**
     * Reference to the root namespace.
     * @name ReflectionObject#root
     * @type {Root}
     * @readonly
     */
    root: {
        get: function() {
            var ptr = this;
            while (ptr.parent !== null)
                ptr = ptr.parent;
            return ptr;
        }
    },

    /**
     * Full name including leading dot.
     * @name ReflectionObject#fullName
     * @type {string}
     * @readonly
     */
    fullName: {
        get: function() {
            var path = [ this.name ],
                ptr = this.parent;
            while (ptr) {
                path.unshift(ptr.name);
                ptr = ptr.parent;
            }
            return path.join(".");
        }
    }
});

/**
 * Converts this reflection object to its descriptor representation.
 * @returns {Object.<string,*>} Descriptor
 * @abstract
 */
ReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() {
    throw Error(); // not implemented, shouldn't happen
};

/**
 * Called when this object is added to a parent.
 * @param {ReflectionObject} parent Parent added to
 * @returns {undefined}
 */
ReflectionObject.prototype.onAdd = function onAdd(parent) {
    if (this.parent && this.parent !== parent)
        this.parent.remove(this);
    this.parent = parent;
    this.resolved = false;
    var root = parent.root;
    if (root instanceof Root)
        root._handleAdd(this);
};

/**
 * Called when this object is removed from a parent.
 * @param {ReflectionObject} parent Parent removed from
 * @returns {undefined}
 */
ReflectionObject.prototype.onRemove = function onRemove(parent) {
    var root = parent.root;
    if (root instanceof Root)
        root._handleRemove(this);
    this.parent = null;
    this.resolved = false;
};

/**
 * Resolves this objects type references.
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.resolve = function resolve() {
    if (this.resolved)
        return this;
    if (this.root instanceof Root)
        this.resolved = true; // only if part of a root
    return this;
};

/**
 * Gets an option value.
 * @param {string} name Option name
 * @returns {*} Option value or `undefined` if not set
 */
ReflectionObject.prototype.getOption = function getOption(name) {
    if (this.options)
        return this.options[name];
    return undefined;
};

/**
 * Sets an option.
 * @param {string} name Option name
 * @param {*} value Option value
 * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (!ifNotSet || !this.options || this.options[name] === undefined)
        (this.options || (this.options = {}))[name] = value;
    return this;
};

/**
 * Sets multiple options.
 * @param {Object.<string,*>} options Options to set
 * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
    if (options)
        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)
            this.setOption(keys[i], options[keys[i]], ifNotSet);
    return this;
};

/**
 * Converts this instance to its string representation.
 * @returns {string} Class name[, space, full name]
 */
ReflectionObject.prototype.toString = function toString() {
    var className = this.constructor.className,
        fullName  = this.fullName;
    if (fullName.length)
        return className + " " + fullName;
    return className;
};

ReflectionObject._configure = function(Root_) {
    Root = Root_;
};

},{"./util":112}],100:[function(require,module,exports){
"use strict";
module.exports = OneOf;

// extends ReflectionObject
var ReflectionObject = require("./object");
((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";

var Field = require("./field"),
    util  = require("./util");

/**
 * Constructs a new oneof instance.
 * @classdesc Reflected oneof.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Oneof name
 * @param {string[]|Object.<string,*>} [fieldNames] Field names
 * @param {Object.<string,*>} [options] Declared options
 */
function OneOf(name, fieldNames, options) {
    if (!Array.isArray(fieldNames)) {
        options = fieldNames;
        fieldNames = undefined;
    }
    ReflectionObject.call(this, name, options);

    /* istanbul ignore if */
    if (!(fieldNames === undefined || Array.isArray(fieldNames)))
        throw TypeError("fieldNames must be an Array");

    /**
     * Field names that belong to this oneof.
     * @type {string[]}
     */
    this.oneof = fieldNames || []; // toJSON, marker

    /**
     * Fields that belong to this oneof as an array for iteration.
     * @type {Field[]}
     * @readonly
     */
    this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent
}

/**
 * Oneof descriptor.
 * @interface IOneOf
 * @property {Array.<string>} oneof Oneof field names
 * @property {Object.<string,*>} [options] Oneof options
 */

/**
 * Constructs a oneof from a oneof descriptor.
 * @param {string} name Oneof name
 * @param {IOneOf} json Oneof descriptor
 * @returns {OneOf} Created oneof
 * @throws {TypeError} If arguments are invalid
 */
OneOf.fromJSON = function fromJSON(name, json) {
    return new OneOf(name, json.oneof, json.options);
};

/**
 * Converts this oneof to a oneof descriptor.
 * @returns {IOneOf} Oneof descriptor
 */
OneOf.prototype.toJSON = function toJSON() {
    return util.toObject([
        "options" , this.options,
        "oneof"   , this.oneof
    ]);
};

/**
 * Adds the fields of the specified oneof to the parent if not already done so.
 * @param {OneOf} oneof The oneof
 * @returns {undefined}
 * @inner
 * @ignore
 */
function addFieldsToParent(oneof) {
    if (oneof.parent)
        for (var i = 0; i < oneof.fieldsArray.length; ++i)
            if (!oneof.fieldsArray[i].parent)
                oneof.parent.add(oneof.fieldsArray[i]);
}

/**
 * Adds a field to this oneof and removes it from its current parent, if any.
 * @param {Field} field Field to add
 * @returns {OneOf} `this`
 */
OneOf.prototype.add = function add(field) {

    /* istanbul ignore if */
    if (!(field instanceof Field))
        throw TypeError("field must be a Field");

    if (field.parent && field.parent !== this.parent)
        field.parent.remove(field);
    this.oneof.push(field.name);
    this.fieldsArray.push(field);
    field.partOf = this; // field.parent remains null
    addFieldsToParent(this);
    return this;
};

/**
 * Removes a field from this oneof and puts it back to the oneof's parent.
 * @param {Field} field Field to remove
 * @returns {OneOf} `this`
 */
OneOf.prototype.remove = function remove(field) {

    /* istanbul ignore if */
    if (!(field instanceof Field))
        throw TypeError("field must be a Field");

    var index = this.fieldsArray.indexOf(field);

    /* istanbul ignore if */
    if (index < 0)
        throw Error(field + " is not a member of " + this);

    this.fieldsArray.splice(index, 1);
    index = this.oneof.indexOf(field.name);

    /* istanbul ignore else */
    if (index > -1) // theoretical
        this.oneof.splice(index, 1);

    field.partOf = null;
    return this;
};

/**
 * @override
 */
OneOf.prototype.onAdd = function onAdd(parent) {
    ReflectionObject.prototype.onAdd.call(this, parent);
    var self = this;
    // Collect present fields
    for (var i = 0; i < this.oneof.length; ++i) {
        var field = parent.get(this.oneof[i]);
        if (field && !field.partOf) {
            field.partOf = self;
            self.fieldsArray.push(field);
        }
    }
    // Add not yet present fields
    addFieldsToParent(this);
};

/**
 * @override
 */
OneOf.prototype.onRemove = function onRemove(parent) {
    for (var i = 0, field; i < this.fieldsArray.length; ++i)
        if ((field = this.fieldsArray[i]).parent)
            field.parent.remove(field);
    ReflectionObject.prototype.onRemove.call(this, parent);
};

/**
 * Decorator function as returned by {@link OneOf.d} (TypeScript).
 * @typedef OneOfDecorator
 * @type {function}
 * @param {Object} prototype Target prototype
 * @param {string} oneofName OneOf name
 * @returns {undefined}
 */

/**
 * OneOf decorator (TypeScript).
 * @function
 * @param {...string} fieldNames Field names
 * @returns {OneOfDecorator} Decorator function
 * @template T extends string
 */
OneOf.d = function decorateOneOf() {
    var fieldNames = new Array(arguments.length),
        index = 0;
    while (index < arguments.length)
        fieldNames[index] = arguments[index++];
    return function oneOfDecorator(prototype, oneofName) {
        util.decorateType(prototype.constructor)
            .add(new OneOf(oneofName, fieldNames));
        Object.defineProperty(prototype, oneofName, {
            get: util.oneOfGetter(fieldNames),
            set: util.oneOfSetter(fieldNames)
        });
    };
};

},{"./field":91,"./object":99,"./util":112}],101:[function(require,module,exports){
"use strict";
module.exports = parse;

parse.filename = null;
parse.defaults = { keepCase: false };

var tokenize  = require("./tokenize"),
    Root      = require("./root"),
    Type      = require("./type"),
    Field     = require("./field"),
    MapField  = require("./mapfield"),
    OneOf     = require("./oneof"),
    Enum      = require("./enum"),
    Service   = require("./service"),
    Method    = require("./method"),
    types     = require("./types"),
    util      = require("./util");

var base10Re    = /^[1-9][0-9]*$/,
    base10NegRe = /^-?[1-9][0-9]*$/,
    base16Re    = /^0[x][0-9a-fA-F]+$/,
    base16NegRe = /^-?0[x][0-9a-fA-F]+$/,
    base8Re     = /^0[0-7]+$/,
    base8NegRe  = /^-?0[0-7]+$/,
    numberRe    = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,
    nameRe      = /^[a-zA-Z_][a-zA-Z_0-9]*$/,
    typeRefRe   = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)+$/,
    fqTypeRefRe = /^(?:\.[a-zA-Z][a-zA-Z_0-9]*)+$/;

/**
 * Result object returned from {@link parse}.
 * @interface IParserResult
 * @property {string|undefined} package Package name, if declared
 * @property {string[]|undefined} imports Imports, if any
 * @property {string[]|undefined} weakImports Weak imports, if any
 * @property {string|undefined} syntax Syntax, if specified (either `"proto2"` or `"proto3"`)
 * @property {Root} root Populated root instance
 */

/**
 * Options modifying the behavior of {@link parse}.
 * @interface IParseOptions
 * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case
 */

/**
 * Parses the given .proto source and returns an object with the parsed contents.
 * @param {string} source Source contents
 * @param {Root} root Root to populate
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {IParserResult} Parser result
 * @property {string} filename=null Currently processing file name for error reporting, if known
 * @property {IParseOptions} defaults Default {@link IParseOptions}
 */
function parse(source, root, options) {
    /* eslint-disable callback-return */
    if (!(root instanceof Root)) {
        options = root;
        root = new Root();
    }
    if (!options)
        options = parse.defaults;

    var tn = tokenize(source),
        next = tn.next,
        push = tn.push,
        peek = tn.peek,
        skip = tn.skip,
        cmnt = tn.cmnt;

    var head = true,
        pkg,
        imports,
        weakImports,
        syntax,
        isProto3 = false;

    var ptr = root;

    var applyCase = options.keepCase ? function(name) { return name; } : util.camelCase;

    /* istanbul ignore next */
    function illegal(token, name, insideTryCatch) {
        var filename = parse.filename;
        if (!insideTryCatch)
            parse.filename = null;
        return Error("illegal " + (name || "token") + " '" + token + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
    }

    function readString() {
        var values = [],
            token;
        do {
            /* istanbul ignore if */
            if ((token = next()) !== "\"" && token !== "'")
                throw illegal(token);

            values.push(next());
            skip(token);
            token = peek();
        } while (token === "\"" || token === "'");
        return values.join("");
    }

    function readValue(acceptTypeRef) {
        var token = next();
        switch (token) {
            case "'":
            case "\"":
                push(token);
                return readString();
            case "true": case "TRUE":
                return true;
            case "false": case "FALSE":
                return false;
        }
        try {
            return parseNumber(token, /* insideTryCatch */ true);
        } catch (e) {

            /* istanbul ignore else */
            if (acceptTypeRef && typeRefRe.test(token))
                return token;

            /* istanbul ignore next */
            throw illegal(token, "value");
        }
    }

    function readRanges(target, acceptStrings) {
        var token, start;
        do {
            if (acceptStrings && ((token = peek()) === "\"" || token === "'"))
                target.push(readString());
            else
                target.push([ start = parseId(next()), skip("to", true) ? parseId(next()) : start ]);
        } while (skip(",", true));
        skip(";");
    }

    function parseNumber(token, insideTryCatch) {
        var sign = 1;
        if (token.charAt(0) === "-") {
            sign = -1;
            token = token.substring(1);
        }
        switch (token) {
            case "inf": case "INF": case "Inf":
                return sign * Infinity;
            case "nan": case "NAN": case "Nan": case "NaN":
                return NaN;
            case "0":
                return 0;
        }
        if (base10Re.test(token))
            return sign * parseInt(token, 10);
        if (base16Re.test(token))
            return sign * parseInt(token, 16);
        if (base8Re.test(token))
            return sign * parseInt(token, 8);

        /* istanbul ignore else */
        if (numberRe.test(token))
            return sign * parseFloat(token);

        /* istanbul ignore next */
        throw illegal(token, "number", insideTryCatch);
    }

    function parseId(token, acceptNegative) {
        switch (token) {
            case "max": case "MAX": case "Max":
                return 536870911;
            case "0":
                return 0;
        }

        /* istanbul ignore if */
        if (!acceptNegative && token.charAt(0) === "-")
            throw illegal(token, "id");

        if (base10NegRe.test(token))
            return parseInt(token, 10);
        if (base16NegRe.test(token))
            return parseInt(token, 16);

        /* istanbul ignore else */
        if (base8NegRe.test(token))
            return parseInt(token, 8);

        /* istanbul ignore next */
        throw illegal(token, "id");
    }

    function parsePackage() {

        /* istanbul ignore if */
        if (pkg !== undefined)
            throw illegal("package");

        pkg = next();

        /* istanbul ignore if */
        if (!typeRefRe.test(pkg))
            throw illegal(pkg, "name");

        ptr = ptr.define(pkg);
        skip(";");
    }

    function parseImport() {
        var token = peek();
        var whichImports;
        switch (token) {
            case "weak":
                whichImports = weakImports || (weakImports = []);
                next();
                break;
            case "public":
                next();
                // eslint-disable-line no-fallthrough
            default:
                whichImports = imports || (imports = []);
                break;
        }
        token = readString();
        skip(";");
        whichImports.push(token);
    }

    function parseSyntax() {
        skip("=");
        syntax = readString();
        isProto3 = syntax === "proto3";

        /* istanbul ignore if */
        if (!isProto3 && syntax !== "proto2")
            throw illegal(syntax, "syntax");

        skip(";");
    }

    function parseCommon(parent, token) {
        switch (token) {

            case "option":
                parseOption(parent, token);
                skip(";");
                return true;

            case "message":
                parseType(parent, token);
                return true;

            case "enum":
                parseEnum(parent, token);
                return true;

            case "service":
                parseService(parent, token);
                return true;

            case "extend":
                parseExtension(parent, token);
                return true;
        }
        return false;
    }

    function ifBlock(obj, fnIf, fnElse) {
        var trailingLine = tn.line;
        if (obj) {
            obj.comment = cmnt(); // try block-type comment
            obj.filename = parse.filename;
        }
        if (skip("{", true)) {
            var token;
            while ((token = next()) !== "}")
                fnIf(token);
            skip(";", true);
        } else {
            if (fnElse)
                fnElse();
            skip(";");
            if (obj && typeof obj.comment !== "string")
                obj.comment = cmnt(trailingLine); // try line-type comment if no block
        }
    }

    function parseType(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "type name");

        var type = new Type(token);
        ifBlock(type, function parseType_block(token) {
            if (parseCommon(type, token))
                return;

            switch (token) {

                case "map":
                    parseMapField(type, token);
                    break;

                case "required":
                case "optional":
                case "repeated":
                    parseField(type, token);
                    break;

                case "oneof":
                    parseOneOf(type, token);
                    break;

                case "extensions":
                    readRanges(type.extensions || (type.extensions = []));
                    break;

                case "reserved":
                    readRanges(type.reserved || (type.reserved = []), true);
                    break;

                default:
                    /* istanbul ignore if */
                    if (!isProto3 || !typeRefRe.test(token))
                        throw illegal(token);

                    push(token);
                    parseField(type, "optional");
                    break;
            }
        });
        parent.add(type);
    }

    function parseField(parent, rule, extend) {
        var type = next();
        if (type === "group") {
            parseGroup(parent, rule);
            return;
        }

        /* istanbul ignore if */
        if (!typeRefRe.test(type))
            throw illegal(type, "type");

        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        name = applyCase(name);
        skip("=");

        var field = new Field(name, parseId(next()), type, rule, extend);
        ifBlock(field, function parseField_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(field, token);
                skip(";");
            } else
                throw illegal(token);

        }, function parseField_line() {
            parseInlineOptions(field);
        });
        parent.add(field);

        // JSON defaults to packed=true if not set so we have to set packed=false explicity when
        // parsing proto2 descriptors without the option, where applicable. This must be done for
        // all known packable types and anything that could be an enum (= is not a basic type).
        if (!isProto3 && field.repeated && (types.packed[type] !== undefined || types.basic[type] === undefined))
            field.setOption("packed", false, /* ifNotSet */ true);
    }

    function parseGroup(parent, rule) {
        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        var fieldName = util.lcFirst(name);
        if (name === fieldName)
            name = util.ucFirst(name);
        skip("=");
        var id = parseId(next());
        var type = new Type(name);
        type.group = true;
        var field = new Field(fieldName, id, name, rule);
        field.filename = parse.filename;
        ifBlock(type, function parseGroup_block(token) {
            switch (token) {

                case "option":
                    parseOption(type, token);
                    skip(";");
                    break;

                case "required":
                case "optional":
                case "repeated":
                    parseField(type, token);
                    break;

                /* istanbul ignore next */
                default:
                    throw illegal(token); // there are no groups with proto3 semantics
            }
        });
        parent.add(type)
              .add(field);
    }

    function parseMapField(parent) {
        skip("<");
        var keyType = next();

        /* istanbul ignore if */
        if (types.mapKey[keyType] === undefined)
            throw illegal(keyType, "type");

        skip(",");
        var valueType = next();

        /* istanbul ignore if */
        if (!typeRefRe.test(valueType))
            throw illegal(valueType, "type");

        skip(">");
        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        skip("=");
        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);
        ifBlock(field, function parseMapField_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(field, token);
                skip(";");
            } else
                throw illegal(token);

        }, function parseMapField_line() {
            parseInlineOptions(field);
        });
        parent.add(field);
    }

    function parseOneOf(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var oneof = new OneOf(applyCase(token));
        ifBlock(oneof, function parseOneOf_block(token) {
            if (token === "option") {
                parseOption(oneof, token);
                skip(";");
            } else {
                push(token);
                parseField(oneof, "optional");
            }
        });
        parent.add(oneof);
    }

    function parseEnum(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var enm = new Enum(token);
        ifBlock(enm, function parseEnum_block(token) {
            if (token === "option") {
                parseOption(enm, token);
                skip(";");
            } else
                parseEnumValue(enm, token);
        });
        parent.add(enm);
    }

    function parseEnumValue(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token))
            throw illegal(token, "name");

        skip("=");
        var value = parseId(next(), true),
            dummy = {};
        ifBlock(dummy, function parseEnumValue_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(dummy, token); // skip
                skip(";");
            } else
                throw illegal(token);

        }, function parseEnumValue_line() {
            parseInlineOptions(dummy); // skip
        });
        parent.add(token, value, dummy.comment);
    }

    function parseOption(parent, token) {
        var isCustom = skip("(", true);

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token, "name");

        var name = token;
        if (isCustom) {
            skip(")");
            name = "(" + name + ")";
            token = peek();
            if (fqTypeRefRe.test(token)) {
                name += token;
                next();
            }
        }
        skip("=");
        parseOptionValue(parent, name);
    }

    function parseOptionValue(parent, name) {
        if (skip("{", true)) { // { a: "foo" b { c: "bar" } }
            do {
                /* istanbul ignore if */
                if (!nameRe.test(token = next()))
                    throw illegal(token, "name");

                if (peek() === "{")
                    parseOptionValue(parent, name + "." + token);
                else {
                    skip(":");
                    setOption(parent, name + "." + token, readValue(true));
                }
            } while (!skip("}", true));
        } else
            setOption(parent, name, readValue(true));
        // Does not enforce a delimiter to be universal
    }

    function setOption(parent, name, value) {
        if (parent.setOption)
            parent.setOption(name, value);
    }

    function parseInlineOptions(parent) {
        if (skip("[", true)) {
            do {
                parseOption(parent, "option");
            } while (skip(",", true));
            skip("]");
        }
        return parent;
    }

    function parseService(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "service name");

        var service = new Service(token);
        ifBlock(service, function parseService_block(token) {
            if (parseCommon(service, token))
                return;

            /* istanbul ignore else */
            if (token === "rpc")
                parseMethod(service, token);
            else
                throw illegal(token);
        });
        parent.add(service);
    }

    function parseMethod(parent, token) {
        var type = token;

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var name = token,
            requestType, requestStream,
            responseType, responseStream;

        skip("(");
        if (skip("stream", true))
            requestStream = true;

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token);

        requestType = token;
        skip(")"); skip("returns"); skip("(");
        if (skip("stream", true))
            responseStream = true;

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token);

        responseType = token;
        skip(")");

        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);
        ifBlock(method, function parseMethod_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(method, token);
                skip(";");
            } else
                throw illegal(token);

        });
        parent.add(method);
    }

    function parseExtension(parent, token) {

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token, "reference");

        var reference = token;
        ifBlock(null, function parseExtension_block(token) {
            switch (token) {

                case "required":
                case "repeated":
                case "optional":
                    parseField(parent, token, reference);
                    break;

                default:
                    /* istanbul ignore if */
                    if (!isProto3 || !typeRefRe.test(token))
                        throw illegal(token);
                    push(token);
                    parseField(parent, "optional", reference);
                    break;
            }
        });
    }

    var token;
    while ((token = next()) !== null) {
        switch (token) {

            case "package":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parsePackage();
                break;

            case "import":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parseImport();
                break;

            case "syntax":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parseSyntax();
                break;

            case "option":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parseOption(ptr, token);
                skip(";");
                break;

            default:

                /* istanbul ignore else */
                if (parseCommon(ptr, token)) {
                    head = false;
                    continue;
                }

                /* istanbul ignore next */
                throw illegal(token);
        }
    }

    parse.filename = null;
    return {
        "package"     : pkg,
        "imports"     : imports,
         weakImports  : weakImports,
         syntax       : syntax,
         root         : root
    };
}

/**
 * Parses the given .proto source and returns an object with the parsed contents.
 * @name parse
 * @function
 * @param {string} source Source contents
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {IParserResult} Parser result
 * @property {string} filename=null Currently processing file name for error reporting, if known
 * @property {IParseOptions} defaults Default {@link IParseOptions}
 * @variation 2
 */

},{"./enum":90,"./field":91,"./mapfield":95,"./method":97,"./oneof":100,"./root":104,"./service":108,"./tokenize":109,"./type":110,"./types":111,"./util":112}],102:[function(require,module,exports){
"use strict";
module.exports = Reader;

var util      = require("./util/minimal");

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = util.Buffer
    ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer) {
            return util.Buffer.isBuffer(buffer)
                ? new BufferReader(buffer)
                /* istanbul ignore next */
                : create_array(buffer);
        })(buffer);
    }
    /* istanbul ignore next */
    : create_array;

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            do { // eslint-disable-line no-constant-condition
                if ((wireType = this.uint32() & 7) === 4)
                    break;
                this.skipType(wireType);
            } while (true);
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};

},{"./util/minimal":114}],103:[function(require,module,exports){
"use strict";
module.exports = BufferReader;

// extends Reader
var Reader = require("./reader");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = require("./util/minimal");

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

/* istanbul ignore else */
if (util.Buffer)
    BufferReader.prototype._slice = util.Buffer.prototype.slice;

/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

},{"./reader":102,"./util/minimal":114}],104:[function(require,module,exports){
"use strict";
module.exports = Root;

// extends Namespace
var Namespace = require("./namespace");
((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";

var Field   = require("./field"),
    Enum    = require("./enum"),
    OneOf   = require("./oneof"),
    util    = require("./util");

var Type,   // cyclic
    parse,  // might be excluded
    common; // "

/**
 * Constructs a new root namespace instance.
 * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.
 * @extends NamespaceBase
 * @constructor
 * @param {Object.<string,*>} [options] Top level options
 */
function Root(options) {
    Namespace.call(this, "", options);

    /**
     * Deferred extension fields.
     * @type {Field[]}
     */
    this.deferred = [];

    /**
     * Resolved file names of loaded files.
     * @type {string[]}
     */
    this.files = [];
}

/**
 * Loads a namespace descriptor into a root namespace.
 * @param {INamespace} json Nameespace descriptor
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted
 * @returns {Root} Root namespace
 */
Root.fromJSON = function fromJSON(json, root) {
    if (!root)
        root = new Root();
    if (json.options)
        root.setOptions(json.options);
    return root.addJSON(json.nested);
};

/**
 * Resolves the path of an imported file, relative to the importing origin.
 * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.
 * @function
 * @param {string} origin The file name of the importing file
 * @param {string} target The file name being imported
 * @returns {string|null} Resolved path to `target` or `null` to skip the file
 */
Root.prototype.resolvePath = util.path.resolve;

// A symbol-like function to safely signal synchronous loading
/* istanbul ignore next */
function SYNC() {} // eslint-disable-line no-empty-function

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} options Parse options
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 */
Root.prototype.load = function load(filename, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = undefined;
    }
    var self = this;
    if (!callback)
        return util.asPromise(load, self, filename, options);

    var sync = callback === SYNC; // undocumented

    // Finishes loading by calling the callback (exactly once)
    function finish(err, root) {
        /* istanbul ignore if */
        if (!callback)
            return;
        var cb = callback;
        callback = null;
        if (sync)
            throw err;
        cb(err, root);
    }

    // Processes a single file
    function process(filename, source) {
        try {
            if (util.isString(source) && source.charAt(0) === "{")
                source = JSON.parse(source);
            if (!util.isString(source))
                self.setOptions(source.options).addJSON(source.nested);
            else {
                parse.filename = filename;
                var parsed = parse(source, self, options),
                    resolved,
                    i = 0;
                if (parsed.imports)
                    for (; i < parsed.imports.length; ++i)
                        if (resolved = self.resolvePath(filename, parsed.imports[i]))
                            fetch(resolved);
                if (parsed.weakImports)
                    for (i = 0; i < parsed.weakImports.length; ++i)
                        if (resolved = self.resolvePath(filename, parsed.weakImports[i]))
                            fetch(resolved, true);
            }
        } catch (err) {
            finish(err);
        }
        if (!sync && !queued)
            finish(null, self); // only once anyway
    }

    // Fetches a single file
    function fetch(filename, weak) {

        // Strip path if this file references a bundled definition
        var idx = filename.lastIndexOf("google/protobuf/");
        if (idx > -1) {
            var altname = filename.substring(idx);
            if (altname in common)
                filename = altname;
        }

        // Skip if already loaded / attempted
        if (self.files.indexOf(filename) > -1)
            return;
        self.files.push(filename);

        // Shortcut bundled definitions
        if (filename in common) {
            if (sync)
                process(filename, common[filename]);
            else {
                ++queued;
                setTimeout(function() {
                    --queued;
                    process(filename, common[filename]);
                });
            }
            return;
        }

        // Otherwise fetch from disk or network
        if (sync) {
            var source;
            try {
                source = util.fs.readFileSync(filename).toString("utf8");
            } catch (err) {
                if (!weak)
                    finish(err);
                return;
            }
            process(filename, source);
        } else {
            ++queued;
            util.fetch(filename, function(err, source) {
                --queued;
                /* istanbul ignore if */
                if (!callback)
                    return; // terminated meanwhile
                if (err) {
                    /* istanbul ignore else */
                    if (!weak)
                        finish(err);
                    else if (!queued) // can't be covered reliably
                        finish(null, self);
                    return;
                }
                process(filename, source);
            });
        }
    }
    var queued = 0;

    // Assembling the root namespace doesn't require working type
    // references anymore, so we can load everything in parallel
    if (util.isString(filename))
        filename = [ filename ];
    for (var i = 0, resolved; i < filename.length; ++i)
        if (resolved = self.resolvePath("", filename[i]))
            fetch(resolved);

    if (sync)
        return self;
    if (!queued)
        finish(null, self);
    return undefined;
};
// function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
 * @function Root#load
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @variation 2
 */
// function load(filename:string, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.
 * @function Root#load
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {Promise<Root>} Promise
 * @variation 3
 */
// function load(filename:string, [options:IParseOptions]):Promise<Root>

/**
 * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).
 * @function Root#loadSync
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {Root} Root namespace
 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
 */
Root.prototype.loadSync = function loadSync(filename, options) {
    if (!util.isNode)
        throw Error("not supported");
    return this.load(filename, options, SYNC);
};

/**
 * @override
 */
Root.prototype.resolveAll = function resolveAll() {
    if (this.deferred.length)
        throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
            return "'extend " + field.extend + "' in " + field.parent.fullName;
        }).join(", "));
    return Namespace.prototype.resolveAll.call(this);
};

// only uppercased (and thus conflict-free) children are exposed, see below
var exposeRe = /^[A-Z]/;

/**
 * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.
 * @param {Root} root Root instance
 * @param {Field} field Declaring extension field witin the declaring type
 * @returns {boolean} `true` if successfully added to the extended type, `false` otherwise
 * @inner
 * @ignore
 */
function tryHandleExtension(root, field) {
    var extendedType = field.parent.lookup(field.extend);
    if (extendedType) {
        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);
        sisterField.declaringField = field;
        field.extensionField = sisterField;
        extendedType.add(sisterField);
        return true;
    }
    return false;
}

/**
 * Called when any object is added to this root or its sub-namespaces.
 * @param {ReflectionObject} object Object added
 * @returns {undefined}
 * @private
 */
Root.prototype._handleAdd = function _handleAdd(object) {
    if (object instanceof Field) {

        if (/* an extension field (implies not part of a oneof) */ object.extend !== undefined && /* not already handled */ !object.extensionField)
            if (!tryHandleExtension(this, object))
                this.deferred.push(object);

    } else if (object instanceof Enum) {

        if (exposeRe.test(object.name))
            object.parent[object.name] = object.values; // expose enum values as property of its parent

    } else if (!(object instanceof OneOf)) /* everything else is a namespace */ {

        if (object instanceof Type) // Try to handle any deferred extensions
            for (var i = 0; i < this.deferred.length;)
                if (tryHandleExtension(this, this.deferred[i]))
                    this.deferred.splice(i, 1);
                else
                    ++i;
        for (var j = 0; j < /* initializes */ object.nestedArray.length; ++j) // recurse into the namespace
            this._handleAdd(object._nestedArray[j]);
        if (exposeRe.test(object.name))
            object.parent[object.name] = object; // expose namespace as property of its parent
    }

    // The above also adds uppercased (and thus conflict-free) nested types, services and enums as
    // properties of namespaces just like static code does. This allows using a .d.ts generated for
    // a static module with reflection-based solutions where the condition is met.
};

/**
 * Called when any object is removed from this root or its sub-namespaces.
 * @param {ReflectionObject} object Object removed
 * @returns {undefined}
 * @private
 */
Root.prototype._handleRemove = function _handleRemove(object) {
    if (object instanceof Field) {

        if (/* an extension field */ object.extend !== undefined) {
            if (/* already handled */ object.extensionField) { // remove its sister field
                object.extensionField.parent.remove(object.extensionField);
                object.extensionField = null;
            } else { // cancel the extension
                var index = this.deferred.indexOf(object);
                /* istanbul ignore else */
                if (index > -1)
                    this.deferred.splice(index, 1);
            }
        }

    } else if (object instanceof Enum) {

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose enum values

    } else if (object instanceof Namespace) {

        for (var i = 0; i < /* initializes */ object.nestedArray.length; ++i) // recurse into the namespace
            this._handleRemove(object._nestedArray[i]);

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose namespaces

    }
};

Root._configure = function(Type_, parse_, common_) {
    Type = Type_;
    parse = parse_;
    common = common_;
};

},{"./enum":90,"./field":91,"./namespace":98,"./oneof":100,"./util":112}],105:[function(require,module,exports){
"use strict";
module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */

},{}],106:[function(require,module,exports){
"use strict";

/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = require("./rpc/service");

},{"./rpc/service":107}],107:[function(require,module,exports){
"use strict";
module.exports = Service;

var util = require("../util/minimal");

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};

},{"../util/minimal":114}],108:[function(require,module,exports){
"use strict";
module.exports = Service;

// extends Namespace
var Namespace = require("./namespace");
((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";

var Method = require("./method"),
    util   = require("./util"),
    rpc    = require("./rpc");

/**
 * Constructs a new service instance.
 * @classdesc Reflected service.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Service name
 * @param {Object.<string,*>} [options] Service options
 * @throws {TypeError} If arguments are invalid
 */
function Service(name, options) {
    Namespace.call(this, name, options);

    /**
     * Service methods.
     * @type {Object.<string,Method>}
     */
    this.methods = {}; // toJSON, marker

    /**
     * Cached methods as an array.
     * @type {Method[]|null}
     * @private
     */
    this._methodsArray = null;
}

/**
 * Service descriptor.
 * @interface IService
 * @extends INamespace
 * @property {Object.<string,IMethod>} methods Method descriptors
 */

/**
 * Constructs a service from a service descriptor.
 * @param {string} name Service name
 * @param {IService} json Service descriptor
 * @returns {Service} Created service
 * @throws {TypeError} If arguments are invalid
 */
Service.fromJSON = function fromJSON(name, json) {
    var service = new Service(name, json.options);
    /* istanbul ignore else */
    if (json.methods)
        for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)
            service.add(Method.fromJSON(names[i], json.methods[names[i]]));
    if (json.nested)
        service.addJSON(json.nested);
    return service;
};

/**
 * Converts this service to a service descriptor.
 * @returns {IService} Service descriptor
 */
Service.prototype.toJSON = function toJSON() {
    var inherited = Namespace.prototype.toJSON.call(this);
    return util.toObject([
        "options" , inherited && inherited.options || undefined,
        "methods" , Namespace.arrayToJSON(this.methodsArray) || /* istanbul ignore next */ {},
        "nested"  , inherited && inherited.nested || undefined
    ]);
};

/**
 * Methods of this service as an array for iteration.
 * @name Service#methodsArray
 * @type {Method[]}
 * @readonly
 */
Object.defineProperty(Service.prototype, "methodsArray", {
    get: function() {
        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
    }
});

function clearCache(service) {
    service._methodsArray = null;
    return service;
}

/**
 * @override
 */
Service.prototype.get = function get(name) {
    return this.methods[name]
        || Namespace.prototype.get.call(this, name);
};

/**
 * @override
 */
Service.prototype.resolveAll = function resolveAll() {
    var methods = this.methodsArray;
    for (var i = 0; i < methods.length; ++i)
        methods[i].resolve();
    return Namespace.prototype.resolve.call(this);
};

/**
 * @override
 */
Service.prototype.add = function add(object) {

    /* istanbul ignore if */
    if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);

    if (object instanceof Method) {
        this.methods[object.name] = object;
        object.parent = this;
        return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
};

/**
 * @override
 */
Service.prototype.remove = function remove(object) {
    if (object instanceof Method) {

        /* istanbul ignore if */
        if (this.methods[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.methods[object.name];
        object.parent = null;
        return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
};

/**
 * Creates a runtime service using the specified rpc implementation.
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 * @returns {rpc.Service} RPC service. Useful where requests and/or responses are streamed.
 */
Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
    var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
    for (var i = 0, method; i < /* initializes */ this.methodsArray.length; ++i) {
        rpcService[util.lcFirst((method = this._methodsArray[i]).resolve().name)] = util.codegen(["r","c"], util.lcFirst(method.name))("return this.rpcCall(m,q,s,r,c)")({
            m: method,
            q: method.resolvedRequestType.ctor,
            s: method.resolvedResponseType.ctor
        });
    }
    return rpcService;
};

},{"./method":97,"./namespace":98,"./rpc":106,"./util":112}],109:[function(require,module,exports){
"use strict";
module.exports = tokenize;

var delimRe        = /[\s{}=;:[\],'"()<>]/g,
    stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
    stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;

var setCommentRe = /^ *[*/]+ */,
    setCommentSplitRe = /\n/g,
    whitespaceRe = /\s/,
    unescapeRe = /\\(.?)/g;

var unescapeMap = {
    "0": "\0",
    "r": "\r",
    "n": "\n",
    "t": "\t"
};

/**
 * Unescapes a string.
 * @param {string} str String to unescape
 * @returns {string} Unescaped string
 * @property {Object.<string,string>} map Special characters map
 * @memberof tokenize
 */
function unescape(str) {
    return str.replace(unescapeRe, function($0, $1) {
        switch ($1) {
            case "\\":
            case "":
                return $1;
            default:
                return unescapeMap[$1] || "";
        }
    });
}

tokenize.unescape = unescape;

/**
 * Gets the next token and advances.
 * @typedef TokenizerHandleNext
 * @type {function}
 * @returns {string|null} Next token or `null` on eof
 */

/**
 * Peeks for the next token.
 * @typedef TokenizerHandlePeek
 * @type {function}
 * @returns {string|null} Next token or `null` on eof
 */

/**
 * Pushes a token back to the stack.
 * @typedef TokenizerHandlePush
 * @type {function}
 * @param {string} token Token
 * @returns {undefined}
 */

/**
 * Skips the next token.
 * @typedef TokenizerHandleSkip
 * @type {function}
 * @param {string} expected Expected token
 * @param {boolean} [optional=false] If optional
 * @returns {boolean} Whether the token matched
 * @throws {Error} If the token didn't match and is not optional
 */

/**
 * Gets the comment on the previous line or, alternatively, the line comment on the specified line.
 * @typedef TokenizerHandleCmnt
 * @type {function}
 * @param {number} [line] Line number
 * @returns {string|null} Comment text or `null` if none
 */

/**
 * Handle object returned from {@link tokenize}.
 * @interface ITokenizerHandle
 * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)
 * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)
 * @property {TokenizerHandlePush} push Pushes a token back to the stack
 * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws
 * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any
 * @property {number} line Current line number
 */

/**
 * Tokenizes the given .proto source and returns an object with useful utility functions.
 * @param {string} source Source contents
 * @returns {ITokenizerHandle} Tokenizer handle
 */
function tokenize(source) {
    /* eslint-disable callback-return */
    source = source.toString();

    var offset = 0,
        length = source.length,
        line = 1,
        commentType = null,
        commentText = null,
        commentLine = 0,
        commentLineEmpty = false;

    var stack = [];

    var stringDelim = null;

    /* istanbul ignore next */
    /**
     * Creates an error for illegal syntax.
     * @param {string} subject Subject
     * @returns {Error} Error created
     * @inner
     */
    function illegal(subject) {
        return Error("illegal " + subject + " (line " + line + ")");
    }

    /**
     * Reads a string till its end.
     * @returns {string} String read
     * @inner
     */
    function readString() {
        var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
        re.lastIndex = offset - 1;
        var match = re.exec(source);
        if (!match)
            throw illegal("string");
        offset = re.lastIndex;
        push(stringDelim);
        stringDelim = null;
        return unescape(match[1]);
    }

    /**
     * Gets the character at `pos` within the source.
     * @param {number} pos Position
     * @returns {string} Character
     * @inner
     */
    function charAt(pos) {
        return source.charAt(pos);
    }

    /**
     * Sets the current comment text.
     * @param {number} start Start offset
     * @param {number} end End offset
     * @returns {undefined}
     * @inner
     */
    function setComment(start, end) {
        commentType = source.charAt(start++);
        commentLine = line;
        commentLineEmpty = false;
        var offset = start - 3, // "///" or "/**"
            c;
        do {
            if (--offset < 0 || (c = source.charAt(offset)) === "\n") {
                commentLineEmpty = true;
                break;
            }
        } while (c === " " || c === "\t");
        var lines = source
            .substring(start, end)
            .split(setCommentSplitRe);
        for (var i = 0; i < lines.length; ++i)
            lines[i] = lines[i].replace(setCommentRe, "").trim();
        commentText = lines
            .join("\n")
            .trim();
    }

    /**
     * Obtains the next token.
     * @returns {string|null} Next token or `null` on eof
     * @inner
     */
    function next() {
        if (stack.length > 0)
            return stack.shift();
        if (stringDelim)
            return readString();
        var repeat,
            prev,
            curr,
            start,
            isDoc;
        do {
            if (offset === length)
                return null;
            repeat = false;
            while (whitespaceRe.test(curr = charAt(offset))) {
                if (curr === "\n")
                    ++line;
                if (++offset === length)
                    return null;
            }
            if (charAt(offset) === "/") {
                if (++offset === length)
                    throw illegal("comment");
                if (charAt(offset) === "/") { // Line
                    isDoc = charAt(start = offset + 1) === "/";
                    while (charAt(++offset) !== "\n")
                        if (offset === length)
                            return null;
                    ++offset;
                    if (isDoc) /// Comment
                        setComment(start, offset - 1);
                    ++line;
                    repeat = true;
                } else if ((curr = charAt(offset)) === "*") { /* Block */
                    isDoc = charAt(start = offset + 1) === "*";
                    do {
                        if (curr === "\n")
                            ++line;
                        if (++offset === length)
                            throw illegal("comment");
                        prev = curr;
                        curr = charAt(offset);
                    } while (prev !== "*" || curr !== "/");
                    ++offset;
                    if (isDoc) /** Comment */
                        setComment(start, offset - 2);
                    repeat = true;
                } else
                    return "/";
            }
        } while (repeat);

        // offset !== length if we got here

        var end = offset;
        delimRe.lastIndex = 0;
        var delim = delimRe.test(charAt(end++));
        if (!delim)
            while (end < length && !delimRe.test(charAt(end)))
                ++end;
        var token = source.substring(offset, offset = end);
        if (token === "\"" || token === "'")
            stringDelim = token;
        return token;
    }

    /**
     * Pushes a token back to the stack.
     * @param {string} token Token
     * @returns {undefined}
     * @inner
     */
    function push(token) {
        stack.push(token);
    }

    /**
     * Peeks for the next token.
     * @returns {string|null} Token or `null` on eof
     * @inner
     */
    function peek() {
        if (!stack.length) {
            var token = next();
            if (token === null)
                return null;
            push(token);
        }
        return stack[0];
    }

    /**
     * Skips a token.
     * @param {string} expected Expected token
     * @param {boolean} [optional=false] Whether the token is optional
     * @returns {boolean} `true` when skipped, `false` if not
     * @throws {Error} When a required token is not present
     * @inner
     */
    function skip(expected, optional) {
        var actual = peek(),
            equals = actual === expected;
        if (equals) {
            next();
            return true;
        }
        if (!optional)
            throw illegal("token '" + actual + "', '" + expected + "' expected");
        return false;
    }

    /**
     * Gets a comment.
     * @param {number} [trailingLine] Line number if looking for a trailing comment
     * @returns {string|null} Comment text
     * @inner
     */
    function cmnt(trailingLine) {
        var ret = null;
        if (trailingLine === undefined) {
            if (commentLine === line - 1 && (commentType === "*" || commentLineEmpty))
                ret = commentText;
        } else {
            /* istanbul ignore else */
            if (commentLine < trailingLine)
                peek();
            if (commentLine === trailingLine && !commentLineEmpty && commentType === "/")
                ret = commentText;
        }
        return ret;
    }

    return Object.defineProperty({
        next: next,
        peek: peek,
        push: push,
        skip: skip,
        cmnt: cmnt
    }, "line", {
        get: function() { return line; }
    });
    /* eslint-enable callback-return */
}

},{}],110:[function(require,module,exports){
"use strict";
module.exports = Type;

// extends Namespace
var Namespace = require("./namespace");
((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";

var Enum      = require("./enum"),
    OneOf     = require("./oneof"),
    Field     = require("./field"),
    MapField  = require("./mapfield"),
    Service   = require("./service"),
    Message   = require("./message"),
    Reader    = require("./reader"),
    Writer    = require("./writer"),
    util      = require("./util"),
    encoder   = require("./encoder"),
    decoder   = require("./decoder"),
    verifier  = require("./verifier"),
    converter = require("./converter"),
    wrappers  = require("./wrappers");

/**
 * Constructs a new reflected message type instance.
 * @classdesc Reflected message type.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Message name
 * @param {Object.<string,*>} [options] Declared options
 */
function Type(name, options) {
    Namespace.call(this, name, options);

    /**
     * Message fields.
     * @type {Object.<string,Field>}
     */
    this.fields = {};  // toJSON, marker

    /**
     * Oneofs declared within this namespace, if any.
     * @type {Object.<string,OneOf>}
     */
    this.oneofs = undefined; // toJSON

    /**
     * Extension ranges, if any.
     * @type {number[][]}
     */
    this.extensions = undefined; // toJSON

    /**
     * Reserved ranges, if any.
     * @type {Array.<number[]|string>}
     */
    this.reserved = undefined; // toJSON

    /*?
     * Whether this type is a legacy group.
     * @type {boolean|undefined}
     */
    this.group = undefined; // toJSON

    /**
     * Cached fields by id.
     * @type {Object.<number,Field>|null}
     * @private
     */
    this._fieldsById = null;

    /**
     * Cached fields as an array.
     * @type {Field[]|null}
     * @private
     */
    this._fieldsArray = null;

    /**
     * Cached oneofs as an array.
     * @type {OneOf[]|null}
     * @private
     */
    this._oneofsArray = null;

    /**
     * Cached constructor.
     * @type {Constructor<{}>}
     * @private
     */
    this._ctor = null;
}

Object.defineProperties(Type.prototype, {

    /**
     * Message fields by id.
     * @name Type#fieldsById
     * @type {Object.<number,Field>}
     * @readonly
     */
    fieldsById: {
        get: function() {

            /* istanbul ignore if */
            if (this._fieldsById)
                return this._fieldsById;

            this._fieldsById = {};
            for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
                var field = this.fields[names[i]],
                    id = field.id;

                /* istanbul ignore if */
                if (this._fieldsById[id])
                    throw Error("duplicate id " + id + " in " + this);

                this._fieldsById[id] = field;
            }
            return this._fieldsById;
        }
    },

    /**
     * Fields of this message as an array for iteration.
     * @name Type#fieldsArray
     * @type {Field[]}
     * @readonly
     */
    fieldsArray: {
        get: function() {
            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
        }
    },

    /**
     * Oneofs of this message as an array for iteration.
     * @name Type#oneofsArray
     * @type {OneOf[]}
     * @readonly
     */
    oneofsArray: {
        get: function() {
            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
        }
    },

    /**
     * The registered constructor, if any registered, otherwise a generic constructor.
     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
     * @name Type#ctor
     * @type {Constructor<{}>}
     */
    ctor: {
        get: function() {
            return this._ctor || (this.ctor = Type.generateConstructor(this)());
        },
        set: function(ctor) {

            // Ensure proper prototype
            var prototype = ctor.prototype;
            if (!(prototype instanceof Message)) {
                (ctor.prototype = new Message()).constructor = ctor;
                util.merge(ctor.prototype, prototype);
            }

            // Classes and messages reference their reflected type
            ctor.$type = ctor.prototype.$type = this;

            // Mix in static methods
            util.merge(ctor, Message, true);

            this._ctor = ctor;

            // Messages have non-enumerable default values on their prototype
            var i = 0;
            for (; i < /* initializes */ this.fieldsArray.length; ++i)
                this._fieldsArray[i].resolve(); // ensures a proper value

            // Messages have non-enumerable getters and setters for each virtual oneof field
            var ctorProperties = {};
            for (i = 0; i < /* initializes */ this.oneofsArray.length; ++i)
                ctorProperties[this._oneofsArray[i].resolve().name] = {
                    get: util.oneOfGetter(this._oneofsArray[i].oneof),
                    set: util.oneOfSetter(this._oneofsArray[i].oneof)
                };
            if (i)
                Object.defineProperties(ctor.prototype, ctorProperties);
        }
    }
});

/**
 * Generates a constructor function for the specified type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
Type.generateConstructor = function generateConstructor(mtype) {
    /* eslint-disable no-unexpected-multiline */
    var gen = util.codegen(["p"], mtype.name);
    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype
    for (var i = 0, field; i < mtype.fieldsArray.length; ++i)
        if ((field = mtype._fieldsArray[i]).map) gen
            ("this%s={}", util.safeProp(field.name));
        else if (field.repeated) gen
            ("this%s=[]", util.safeProp(field.name));
    return gen
    ("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)") // omit undefined or null
        ("this[ks[i]]=p[ks[i]]");
    /* eslint-enable no-unexpected-multiline */
};

function clearCache(type) {
    type._fieldsById = type._fieldsArray = type._oneofsArray = null;
    delete type.encode;
    delete type.decode;
    delete type.verify;
    return type;
}

/**
 * Message type descriptor.
 * @interface IType
 * @extends INamespace
 * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors
 * @property {Object.<string,IField>} fields Field descriptors
 * @property {number[][]} [extensions] Extension ranges
 * @property {number[][]} [reserved] Reserved ranges
 * @property {boolean} [group=false] Whether a legacy group or not
 */

/**
 * Creates a message type from a message type descriptor.
 * @param {string} name Message name
 * @param {IType} json Message type descriptor
 * @returns {Type} Created message type
 */
Type.fromJSON = function fromJSON(name, json) {
    var type = new Type(name, json.options);
    type.extensions = json.extensions;
    type.reserved = json.reserved;
    var names = Object.keys(json.fields),
        i = 0;
    for (; i < names.length; ++i)
        type.add(
            ( typeof json.fields[names[i]].keyType !== "undefined"
            ? MapField.fromJSON
            : Field.fromJSON )(names[i], json.fields[names[i]])
        );
    if (json.oneofs)
        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)
            type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
    if (json.nested)
        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
            var nested = json.nested[names[i]];
            type.add( // most to least likely
                ( nested.id !== undefined
                ? Field.fromJSON
                : nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : Namespace.fromJSON )(names[i], nested)
            );
        }
    if (json.extensions && json.extensions.length)
        type.extensions = json.extensions;
    if (json.reserved && json.reserved.length)
        type.reserved = json.reserved;
    if (json.group)
        type.group = true;
    return type;
};

/**
 * Converts this message type to a message type descriptor.
 * @returns {IType} Message type descriptor
 */
Type.prototype.toJSON = function toJSON() {
    var inherited = Namespace.prototype.toJSON.call(this);
    return util.toObject([
        "options"    , inherited && inherited.options || undefined,
        "oneofs"     , Namespace.arrayToJSON(this.oneofsArray),
        "fields"     , Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) { return !obj.declaringField; })) || {},
        "extensions" , this.extensions && this.extensions.length ? this.extensions : undefined,
        "reserved"   , this.reserved && this.reserved.length ? this.reserved : undefined,
        "group"      , this.group || undefined,
        "nested"     , inherited && inherited.nested || undefined
    ]);
};

/**
 * @override
 */
Type.prototype.resolveAll = function resolveAll() {
    var fields = this.fieldsArray, i = 0;
    while (i < fields.length)
        fields[i++].resolve();
    var oneofs = this.oneofsArray; i = 0;
    while (i < oneofs.length)
        oneofs[i++].resolve();
    return Namespace.prototype.resolveAll.call(this);
};

/**
 * @override
 */
Type.prototype.get = function get(name) {
    return this.fields[name]
        || this.oneofs && this.oneofs[name]
        || this.nested && this.nested[name]
        || null;
};

/**
 * Adds a nested object to this type.
 * @param {ReflectionObject} object Nested object to add
 * @returns {Type} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id
 */
Type.prototype.add = function add(object) {

    if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);

    if (object instanceof Field && object.extend === undefined) {
        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.
        // The root object takes care of adding distinct sister-fields to the respective extended
        // type instead.

        // avoids calling the getter if not absolutely necessary because it's called quite frequently
        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id])
            throw Error("duplicate id " + object.id + " in " + this);
        if (this.isReservedId(object.id))
            throw Error("id " + object.id + " is reserved in " + this);
        if (this.isReservedName(object.name))
            throw Error("name '" + object.name + "' is reserved in " + this);

        if (object.parent)
            object.parent.remove(object);
        this.fields[object.name] = object;
        object.message = this;
        object.onAdd(this);
        return clearCache(this);
    }
    if (object instanceof OneOf) {
        if (!this.oneofs)
            this.oneofs = {};
        this.oneofs[object.name] = object;
        object.onAdd(this);
        return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
};

/**
 * Removes a nested object from this type.
 * @param {ReflectionObject} object Nested object to remove
 * @returns {Type} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `object` is not a member of this type
 */
Type.prototype.remove = function remove(object) {
    if (object instanceof Field && object.extend === undefined) {
        // See Type#add for the reason why extension fields are excluded here.

        /* istanbul ignore if */
        if (!this.fields || this.fields[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.fields[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    }
    if (object instanceof OneOf) {

        /* istanbul ignore if */
        if (!this.oneofs || this.oneofs[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.oneofs[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
};

/**
 * Tests if the specified id is reserved.
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Type.prototype.isReservedId = function isReservedId(id) {
    if (this.reserved)
        for (var i = 0; i < this.reserved.length; ++i)
            if (typeof this.reserved[i] !== "string" && this.reserved[i][0] <= id && this.reserved[i][1] >= id)
                return true;
    return false;
};

/**
 * Tests if the specified name is reserved.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Type.prototype.isReservedName = function isReservedName(name) {
    if (this.reserved)
        for (var i = 0; i < this.reserved.length; ++i)
            if (this.reserved[i] === name)
                return true;
    return false;
};

/**
 * Creates a new message of this type using the specified properties.
 * @param {Object.<string,*>} [properties] Properties to set
 * @returns {Message<{}>} Message instance
 */
Type.prototype.create = function create(properties) {
    return new this.ctor(properties);
};

/**
 * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.
 * @returns {Type} `this`
 */
Type.prototype.setup = function setup() {
    // Sets up everything at once so that the prototype chain does not have to be re-evaluated
    // multiple times (V8, soft-deopt prototype-check).

    var fullName = this.fullName,
        types    = [];
    for (var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)
        types.push(this._fieldsArray[i].resolve().resolvedType);

    // Replace setup methods with type-specific generated functions
    this.encode = encoder(this)({
        Writer : Writer,
        types  : types,
        util   : util
    });
    this.decode = decoder(this)({
        Reader : Reader,
        types  : types,
        util   : util
    });
    this.verify = verifier(this)({
        types : types,
        util  : util
    });
    this.fromObject = converter.fromObject(this)({
        types : types,
        util  : util
    });
    this.toObject = converter.toObject(this)({
        types : types,
        util  : util
    });

    // Inject custom wrappers for common types
    var wrapper = wrappers[fullName];
    if (wrapper) {
        var originalThis = Object.create(this);
        // if (wrapper.fromObject) {
            originalThis.fromObject = this.fromObject;
            this.fromObject = wrapper.fromObject.bind(originalThis);
        // }
        // if (wrapper.toObject) {
            originalThis.toObject = this.toObject;
            this.toObject = wrapper.toObject.bind(originalThis);
        // }
    }

    return this;
};

/**
 * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.
 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
 * @param {Writer} [writer] Writer to encode to
 * @returns {Writer} writer
 */
Type.prototype.encode = function encode_setup(message, writer) {
    return this.setup().encode(message, writer); // overrides this method
};

/**
 * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.
 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
 * @param {Writer} [writer] Writer to encode to
 * @returns {Writer} writer
 */
Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
};

/**
 * Decodes a message of this type.
 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
 * @param {number} [length] Length of the message, if known beforehand
 * @returns {Message<{}>} Decoded message
 * @throws {Error} If the payload is not a reader or valid buffer
 * @throws {util.ProtocolError<{}>} If required fields are missing
 */
Type.prototype.decode = function decode_setup(reader, length) {
    return this.setup().decode(reader, length); // overrides this method
};

/**
 * Decodes a message of this type preceeded by its byte length as a varint.
 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
 * @returns {Message<{}>} Decoded message
 * @throws {Error} If the payload is not a reader or valid buffer
 * @throws {util.ProtocolError} If required fields are missing
 */
Type.prototype.decodeDelimited = function decodeDelimited(reader) {
    if (!(reader instanceof Reader))
        reader = Reader.create(reader);
    return this.decode(reader, reader.uint32());
};

/**
 * Verifies that field values are valid and that required fields are present.
 * @param {Object.<string,*>} message Plain object to verify
 * @returns {null|string} `null` if valid, otherwise the reason why it is not
 */
Type.prototype.verify = function verify_setup(message) {
    return this.setup().verify(message); // overrides this method
};

/**
 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
 * @param {Object.<string,*>} object Plain object to convert
 * @returns {Message<{}>} Message instance
 */
Type.prototype.fromObject = function fromObject(object) {
    return this.setup().fromObject(object);
};

/**
 * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.
 * @interface IConversionOptions
 * @property {Function} [longs] Long conversion type.
 * Valid values are `String` and `Number` (the global types).
 * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.
 * @property {Function} [enums] Enum value conversion type.
 * Only valid value is `String` (the global type).
 * Defaults to copy the present value, which is the numeric id.
 * @property {Function} [bytes] Bytes value conversion type.
 * Valid values are `Array` and (a base64 encoded) `String` (the global types).
 * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.
 * @property {boolean} [defaults=false] Also sets default values on the resulting object
 * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`
 * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`
 * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any
 * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings
 */

/**
 * Creates a plain object from a message of this type. Also converts values to other types if specified.
 * @param {Message<{}>} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 */
Type.prototype.toObject = function toObject(message, options) {
    return this.setup().toObject(message, options);
};

/**
 * Decorator function as returned by {@link Type.d} (TypeScript).
 * @typedef TypeDecorator
 * @type {function}
 * @param {Constructor<T>} target Target constructor
 * @returns {undefined}
 * @template T extends Message<T>
 */

/**
 * Type decorator (TypeScript).
 * @param {string} [typeName] Type name, defaults to the constructor's name
 * @returns {TypeDecorator<T>} Decorator function
 * @template T extends Message<T>
 */
Type.d = function decorateType(typeName) {
    return function typeDecorator(target) {
        util.decorateType(target, typeName);
    };
};

},{"./converter":87,"./decoder":88,"./encoder":89,"./enum":90,"./field":91,"./mapfield":95,"./message":96,"./namespace":98,"./oneof":100,"./reader":102,"./service":108,"./util":112,"./verifier":115,"./wrappers":116,"./writer":117}],111:[function(require,module,exports){
"use strict";

/**
 * Common type constants.
 * @namespace
 */
var types = exports;

var util = require("./util");

var s = [
    "double",   // 0
    "float",    // 1
    "int32",    // 2
    "uint32",   // 3
    "sint32",   // 4
    "fixed32",  // 5
    "sfixed32", // 6
    "int64",    // 7
    "uint64",   // 8
    "sint64",   // 9
    "fixed64",  // 10
    "sfixed64", // 11
    "bool",     // 12
    "string",   // 13
    "bytes"     // 14
];

function bake(values, offset) {
    var i = 0, o = {};
    offset |= 0;
    while (i < values.length) o[s[i + offset]] = values[i++];
    return o;
}

/**
 * Basic type wire types.
 * @type {Object.<string,number>}
 * @const
 * @property {number} double=1 Fixed64 wire type
 * @property {number} float=5 Fixed32 wire type
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 * @property {number} string=2 Ldelim wire type
 * @property {number} bytes=2 Ldelim wire type
 */
types.basic = bake([
    /* double   */ 1,
    /* float    */ 5,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0,
    /* string   */ 2,
    /* bytes    */ 2
]);

/**
 * Basic type defaults.
 * @type {Object.<string,*>}
 * @const
 * @property {number} double=0 Double default
 * @property {number} float=0 Float default
 * @property {number} int32=0 Int32 default
 * @property {number} uint32=0 Uint32 default
 * @property {number} sint32=0 Sint32 default
 * @property {number} fixed32=0 Fixed32 default
 * @property {number} sfixed32=0 Sfixed32 default
 * @property {number} int64=0 Int64 default
 * @property {number} uint64=0 Uint64 default
 * @property {number} sint64=0 Sint32 default
 * @property {number} fixed64=0 Fixed64 default
 * @property {number} sfixed64=0 Sfixed64 default
 * @property {boolean} bool=false Bool default
 * @property {string} string="" String default
 * @property {Array.<number>} bytes=Array(0) Bytes default
 * @property {null} message=null Message default
 */
types.defaults = bake([
    /* double   */ 0,
    /* float    */ 0,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 0,
    /* sfixed32 */ 0,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 0,
    /* sfixed64 */ 0,
    /* bool     */ false,
    /* string   */ "",
    /* bytes    */ util.emptyArray,
    /* message  */ null
]);

/**
 * Basic long type wire types.
 * @type {Object.<string,number>}
 * @const
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 */
types.long = bake([
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1
], 7);

/**
 * Allowed types for map keys with their associated wire type.
 * @type {Object.<string,number>}
 * @const
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 * @property {number} string=2 Ldelim wire type
 */
types.mapKey = bake([
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0,
    /* string   */ 2
], 2);

/**
 * Allowed types for packed repeated fields with their associated wire type.
 * @type {Object.<string,number>}
 * @const
 * @property {number} double=1 Fixed64 wire type
 * @property {number} float=5 Fixed32 wire type
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 */
types.packed = bake([
    /* double   */ 1,
    /* float    */ 5,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0
]);

},{"./util":112}],112:[function(require,module,exports){
"use strict";

/**
 * Various utility functions.
 * @namespace
 */
var util = module.exports = require("./util/minimal");

var roots = require("./roots");

var Type, // cyclic
    Enum;

util.codegen = require("@protobufjs/codegen");
util.fetch   = require("@protobufjs/fetch");
util.path    = require("@protobufjs/path");

/**
 * Node's fs module if available.
 * @type {Object.<string,*>}
 */
util.fs = util.inquire("fs");

/**
 * Converts an object's values to an array.
 * @param {Object.<string,*>} object Object to convert
 * @returns {Array.<*>} Converted array
 */
util.toArray = function toArray(object) {
    if (object) {
        var keys  = Object.keys(object),
            array = new Array(keys.length),
            index = 0;
        while (index < keys.length)
            array[index] = object[keys[index++]];
        return array;
    }
    return [];
};

/**
 * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.
 * @param {Array.<*>} array Array to convert
 * @returns {Object.<string,*>} Converted object
 */
util.toObject = function toObject(array) {
    var object = {},
        index  = 0;
    while (index < array.length) {
        var key = array[index++],
            val = array[index++];
        if (val !== undefined)
            object[key] = val;
    }
    return object;
};

var safePropBackslashRe = /\\/g,
    safePropQuoteRe     = /"/g;

/**
 * Returns a safe property accessor for the specified properly name.
 * @param {string} prop Property name
 * @returns {string} Safe accessor
 */
util.safeProp = function safeProp(prop) {
    return "[\"" + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, "\\\"") + "\"]";
};

/**
 * Converts the first character of a string to upper case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.ucFirst = function ucFirst(str) {
    return str.charAt(0).toUpperCase() + str.substring(1);
};

var camelCaseRe = /_([a-z])/g;

/**
 * Converts a string to camel case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.camelCase = function camelCase(str) {
    return str.substring(0, 1)
         + str.substring(1)
               .replace(camelCaseRe, function($0, $1) { return $1.toUpperCase(); });
};

/**
 * Compares reflected fields by id.
 * @param {Field} a First field
 * @param {Field} b Second field
 * @returns {number} Comparison value
 */
util.compareFieldsById = function compareFieldsById(a, b) {
    return a.id - b.id;
};

/**
 * Decorator helper for types (TypeScript).
 * @param {Constructor<T>} ctor Constructor function
 * @param {string} [typeName] Type name, defaults to the constructor's name
 * @returns {Type} Reflected type
 * @template T extends Message<T>
 * @property {Root} root Decorators root
 */
util.decorateType = function decorateType(ctor, typeName) {

    /* istanbul ignore if */
    if (ctor.$type) {
        if (typeName && ctor.$type.name !== typeName) {
            util.decorateRoot.remove(ctor.$type);
            ctor.$type.name = typeName;
            util.decorateRoot.add(ctor.$type);
        }
        return ctor.$type;
    }

    /* istanbul ignore next */
    if (!Type)
        Type = require("./type");

    var type = new Type(typeName || ctor.name);
    util.decorateRoot.add(type);
    type.ctor = ctor; // sets up .encode, .decode etc.
    Object.defineProperty(ctor, "$type", { value: type, enumerable: false });
    Object.defineProperty(ctor.prototype, "$type", { value: type, enumerable: false });
    return type;
};

var decorateEnumIndex = 0;

/**
 * Decorator helper for enums (TypeScript).
 * @param {Object} object Enum object
 * @returns {Enum} Reflected enum
 */
util.decorateEnum = function decorateEnum(object) {

    /* istanbul ignore if */
    if (object.$type)
        return object.$type;

    /* istanbul ignore next */
    if (!Enum)
        Enum = require("./enum");

    var enm = new Enum("Enum" + decorateEnumIndex++, object);
    util.decorateRoot.add(enm);
    Object.defineProperty(object, "$type", { value: enm, enumerable: false });
    return enm;
};

/**
 * Decorator root (TypeScript).
 * @name util.decorateRoot
 * @type {Root}
 * @readonly
 */
Object.defineProperty(util, "decorateRoot", {
    get: function() {
        return roots["decorated"] || (roots["decorated"] = new (require("./root"))());
    }
});

},{"./enum":90,"./root":104,"./roots":105,"./type":110,"./util/minimal":114,"@protobufjs/codegen":3,"@protobufjs/fetch":5,"@protobufjs/path":8}],113:[function(require,module,exports){
"use strict";
module.exports = LongBits;

var util = require("../util/minimal");

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};

},{"../util/minimal":114}],114:[function(require,module,exports){
(function (global){
"use strict";
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = require("@protobufjs/aspromise");

// converts to / from base64 encoded strings
util.base64 = require("@protobufjs/base64");

// base class of rpc.Service
util.EventEmitter = require("@protobufjs/eventemitter");

// float handling accross browsers
util.float = require("@protobufjs/float");

// requires modules optionally and hides the call from bundlers
util.inquire = require("@protobufjs/inquire");

// converts to / from utf8 encoded strings
util.utf8 = require("@protobufjs/utf8");

// provides a node-like buffer pool in the browser
util.pool = require("@protobufjs/pool");

// utility to work with the low and high bits of a 64 bit value
util.LongBits = require("./longbits");

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 * @const
 */
util.isNode = Boolean(global.process && global.process.versions && global.process.versions.node);

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ global.dcodeIO && /* istanbul ignore next */ global.dcodeIO.Long || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: (new Error()).stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./longbits":113,"@protobufjs/aspromise":1,"@protobufjs/base64":2,"@protobufjs/eventemitter":4,"@protobufjs/float":6,"@protobufjs/inquire":7,"@protobufjs/pool":9,"@protobufjs/utf8":10}],115:[function(require,module,exports){
"use strict";
module.exports = verifier;

var Enum      = require("./enum"),
    util      = require("./util");

function invalid(field, expected) {
    return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:"+field.keyType+"}" : "") + " expected";
}

/**
 * Generates a partial value verifier.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genVerifyValue(gen, field, fieldIndex, ref) {
    /* eslint-disable no-unexpected-multiline */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) { gen
            ("switch(%s){", ref)
                ("default:")
                    ("return%j", invalid(field, "enum value"));
            for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) gen
                ("case %i:", field.resolvedType.values[keys[j]]);
            gen
                    ("break")
            ("}");
        } else {
            gen
            ((gen.hasErrorVar ? "" : "var ") + "e=types[%i].verify(%s);", fieldIndex, ref)
            ("if(e)")
                ("return%j+e", field.name + ".");
            gen.hasErrorVar = true;
        }
    } else {
        switch (field.type) {
            case "int32":
            case "uint32":
            case "sint32":
            case "fixed32":
            case "sfixed32": gen
                ("if(!util.isInteger(%s))", ref)
                    ("return%j", invalid(field, "integer"));
                break;
            case "int64":
            case "uint64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
                ("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)
                    ("return%j", invalid(field, "integer|Long"));
                break;
            case "float":
            case "double": gen
                ("if(typeof %s!==\"number\")", ref)
                    ("return%j", invalid(field, "number"));
                break;
            case "bool": gen
                ("if(typeof %s!==\"boolean\")", ref)
                    ("return%j", invalid(field, "boolean"));
                break;
            case "string": gen
                ("if(!util.isString(%s))", ref)
                    ("return%j", invalid(field, "string"));
                break;
            case "bytes": gen
                ("if(!(%s&&typeof %s.length===\"number\"||util.isString(%s)))", ref, ref, ref)
                    ("return%j", invalid(field, "buffer"));
                break;
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline */
}

/**
 * Generates a partial key verifier.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genVerifyKey(gen, field, ref) {
    /* eslint-disable no-unexpected-multiline */
    switch (field.keyType) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32": gen
            ("if(!util.key32Re.test(%s))", ref)
                ("return%j", invalid(field, "integer key"));
            break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64": gen
            ("if(!util.key64Re.test(%s))", ref) // see comment above: x is ok, d is not
                ("return%j", invalid(field, "integer|Long key"));
            break;
        case "bool": gen
            ("if(!util.key2Re.test(%s))", ref)
                ("return%j", invalid(field, "boolean key"));
            break;
    }
    return gen;
    /* eslint-enable no-unexpected-multiline */
}

/**
 * Generates a verifier specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function verifier(mtype) {
    /* eslint-disable no-unexpected-multiline */

    var gen = util.codegen(["m"], mtype.name + "$verify")
    ("if(typeof m!==\"object\"||m===null)")
        ("return%j", "object expected");
    var oneofs = mtype.oneofsArray,
        seenFirstField = {};
    if (oneofs.length) gen
    ("var p={}");

    for (var i = 0; i < /* initializes */ mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(),
            ref   = "m" + util.safeProp(field.name);

        if (field.optional) gen
        ("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name); // !== undefined && !== null

        // map fields
        if (field.map) { gen
            ("if(!util.isObject(%s))", ref)
                ("return%j", invalid(field, "object"))
            ("var k=Object.keys(%s)", ref)
            ("for(var i=0;i<k.length;++i){");
                genVerifyKey(gen, field, "k[i]");
                genVerifyValue(gen, field, i, ref + "[k[i]]")
            ("}");

        // repeated fields
        } else if (field.repeated) { gen
            ("if(!Array.isArray(%s))", ref)
                ("return%j", invalid(field, "array"))
            ("for(var i=0;i<%s.length;++i){", ref);
                genVerifyValue(gen, field, i, ref + "[i]")
            ("}");

        // required or present fields
        } else {
            if (field.partOf) {
                var oneofProp = util.safeProp(field.partOf.name);
                if (seenFirstField[field.partOf.name] === 1) gen
            ("if(p%s===1)", oneofProp)
                ("return%j", field.partOf.name + ": multiple values");
                seenFirstField[field.partOf.name] = 1;
                gen
            ("p%s=1", oneofProp);
            }
            genVerifyValue(gen, field, i, ref);
        }
        if (field.optional) gen
        ("}");
    }
    return gen
    ("return null");
    /* eslint-enable no-unexpected-multiline */
}
},{"./enum":90,"./util":112}],116:[function(require,module,exports){
"use strict";

/**
 * Wrappers for common types.
 * @type {Object.<string,IWrapper>}
 * @const
 */
var wrappers = exports;

var Message = require("./message");

/**
 * From object converter part of an {@link IWrapper}.
 * @typedef WrapperFromObjectConverter
 * @type {function}
 * @param {Object.<string,*>} object Plain object
 * @returns {Message<{}>} Message instance
 * @this Type
 */

/**
 * To object converter part of an {@link IWrapper}.
 * @typedef WrapperToObjectConverter
 * @type {function}
 * @param {Message<{}>} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 * @this Type
 */

/**
 * Common type wrapper part of {@link wrappers}.
 * @interface IWrapper
 * @property {WrapperFromObjectConverter} [fromObject] From object converter
 * @property {WrapperToObjectConverter} [toObject] To object converter
 */

// Custom wrapper for Any
wrappers[".google.protobuf.Any"] = {

    fromObject: function(object) {

        // unwrap value type if mapped
        if (object && object["@type"]) {
            var type = this.lookup(object["@type"]);
            /* istanbul ignore else */
            if (type)
                return this.create({
                    type_url: object["@type"],
                    value: type.encode(object).finish()
                });
        }

        return this.fromObject(object);
    },

    toObject: function(message, options) {

        // decode value if requested and unmapped
        if (options && options.json && message.type_url && message.value) {
            var type = this.lookup(message.type_url);
            /* istanbul ignore else */
            if (type)
                message = type.decode(message.value);
        }

        // wrap value if unmapped
        if (!(message instanceof this.ctor) && message instanceof Message) {
            var object = message.$type.toObject(message, options);
            object["@type"] = message.$type.fullName;
            return object;
        }

        return this.toObject(message, options);
    }
};

},{"./message":96}],117:[function(require,module,exports){
"use strict";
module.exports = Writer;

var util      = require("./util/minimal");

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = util.Buffer
    ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
            return new BufferWriter();
        })();
    }
    /* istanbul ignore next */
    : function create_array() {
        return new Writer();
    };

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
};

},{"./util/minimal":114}],118:[function(require,module,exports){
"use strict";
module.exports = BufferWriter;

// extends Writer
var Writer = require("./writer");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = require("./util/minimal");

var Buffer = util.Buffer;

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Buffer} Buffer
 */
BufferWriter.alloc = function alloc_buffer(size) {
    return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size);
};

var writeBytesBuffer = Buffer && Buffer.prototype instanceof Uint8Array && Buffer.prototype.set.name === "set"
    ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
                           // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
        else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
    };

/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else
        buf.utf8Write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

},{"./util/minimal":114,"./writer":117}],119:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('./Subscriber');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var InnerSubscriber = (function (_super) {
    __extends(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        _super.call(this);
        this.parent = parent;
        this.outerValue = outerValue;
        this.outerIndex = outerIndex;
        this.index = 0;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber_1.Subscriber));
exports.InnerSubscriber = InnerSubscriber;

},{"./Subscriber":128}],120:[function(require,module,exports){
"use strict";
var Observable_1 = require('./Observable');
/**
 * Represents a push-based event or value that an {@link Observable} can emit.
 * This class is particularly useful for operators that manage notifications,
 * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
 * others. Besides wrapping the actual delivered value, it also annotates it
 * with metadata of, for instance, what type of push message it is (`next`,
 * `error`, or `complete`).
 *
 * @see {@link materialize}
 * @see {@link dematerialize}
 * @see {@link observeOn}
 *
 * @class Notification<T>
 */
var Notification = (function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    /**
     * Delivers to the given `observer` the value wrapped by this Notification.
     * @param {Observer} observer
     * @return
     */
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    /**
     * Given some {@link Observer} callbacks, deliver the value represented by the
     * current Notification to the correctly corresponding callback.
     * @param {function(value: T): void} next An Observer `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    /**
     * Takes an Observer or its individual callback functions, and calls `observe`
     * or `do` methods accordingly.
     * @param {Observer|function(value: T): void} nextOrObserver An Observer or
     * the `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        }
        else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    /**
     * Returns a simple Observable that just delivers the notification represented
     * by this Notification instance.
     * @return {any}
     */
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return Observable_1.Observable.of(this.value);
            case 'E':
                return Observable_1.Observable.throw(this.error);
            case 'C':
                return Observable_1.Observable.empty();
        }
        throw new Error('unexpected notification kind value');
    };
    /**
     * A shortcut to create a Notification instance of the type `next` from a
     * given value.
     * @param {T} value The `next` value.
     * @return {Notification<T>} The "next" Notification representing the
     * argument.
     */
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return Notification.undefinedValueNotification;
    };
    /**
     * A shortcut to create a Notification instance of the type `error` from a
     * given error.
     * @param {any} [err] The `error` error.
     * @return {Notification<T>} The "error" Notification representing the
     * argument.
     */
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    /**
     * A shortcut to create a Notification instance of the type `complete`.
     * @return {Notification<any>} The valueless "complete" Notification.
     */
    Notification.createComplete = function () {
        return Notification.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}());
exports.Notification = Notification;

},{"./Observable":121}],121:[function(require,module,exports){
"use strict";
var root_1 = require('./util/root');
var toSubscriber_1 = require('./util/toSubscriber');
var observable_1 = require('./symbol/observable');
var pipe_1 = require('./util/pipe');
/**
 * A representation of any set of values over any amount of time. This is the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */
var Observable = (function () {
    /**
     * @constructor
     * @param {Function} subscribe the function that is called when the Observable is
     * initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or
     * `complete` can be called to notify of a successful completion.
     */
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    /**
     * Creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     * @method lift
     * @param {Operator} operator the operator defining the operation to take on the observable
     * @return {Observable} a new observable with the Operator applied
     */
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    /**
     * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.
     *
     * <span class="informal">Use it when you have all these Observables, but still nothing is happening.</span>
     *
     * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It
     * might be for example a function that you passed to a {@link create} static factory, but most of the time it is
     * a library implementation, which defines what and when will be emitted by an Observable. This means that calling
     * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often
     * thought.
     *
     * Apart from starting the execution of an Observable, this method allows you to listen for values
     * that an Observable emits, as well as for when it completes or errors. You can achieve this in two
     * following ways.
     *
     * The first way is creating an object that implements {@link Observer} interface. It should have methods
     * defined by that interface, but note that it should be just a regular JavaScript object, which you can create
     * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do
     * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also
     * that your object does not have to implement all methods. If you find yourself creating a method that doesn't
     * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will
     * be left uncaught.
     *
     * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.
     * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent
     * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,
     * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,
     * since `subscribe` recognizes these functions by where they were placed in function call. When it comes
     * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.
     *
     * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.
     * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean
     * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback
     * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.
     *
     * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.
     * It is an Observable itself that decides when these functions will be called. For example {@link of}
     * by default emits all its values synchronously. Always check documentation for how given Observable
     * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.
     *
     * @example <caption>Subscribe with an Observer</caption>
     * const sumObserver = {
     *   sum: 0,
     *   next(value) {
     *     console.log('Adding: ' + value);
     *     this.sum = this.sum + value;
     *   },
     *   error() { // We actually could just remove this method,
     *   },        // since we do not really care about errors right now.
     *   complete() {
     *     console.log('Sum equals: ' + this.sum);
     *   }
     * };
     *
     * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.
     * .subscribe(sumObserver);
     *
     * // Logs:
     * // "Adding: 1"
     * // "Adding: 2"
     * // "Adding: 3"
     * // "Sum equals: 6"
     *
     *
     * @example <caption>Subscribe with functions</caption>
     * let sum = 0;
     *
     * Rx.Observable.of(1, 2, 3)
     * .subscribe(
     *   function(value) {
     *     console.log('Adding: ' + value);
     *     sum = sum + value;
     *   },
     *   undefined,
     *   function() {
     *     console.log('Sum equals: ' + sum);
     *   }
     * );
     *
     * // Logs:
     * // "Adding: 1"
     * // "Adding: 2"
     * // "Adding: 3"
     * // "Sum equals: 6"
     *
     *
     * @example <caption>Cancel a subscription</caption>
     * const subscription = Rx.Observable.interval(1000).subscribe(
     *   num => console.log(num),
     *   undefined,
     *   () => console.log('completed!') // Will not be called, even
     * );                                // when cancelling subscription
     *
     *
     * setTimeout(() => {
     *   subscription.unsubscribe();
     *   console.log('unsubscribed!');
     * }, 2500);
     *
     * // Logs:
     * // 0 after 1s
     * // 1 after 2s
     * // "unsubscribed!" after 2.5s
     *
     *
     * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,
     *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed
     *  Observable.
     * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,
     *  the error will be thrown as unhandled.
     * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.
     * @return {ISubscription} a subscription reference to the registered handlers
     * @method subscribe
     */
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            operator.call(sink, this.source);
        }
        else {
            sink.add(this.source || !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
        }
        if (sink.syncErrorThrowable) {
            sink.syncErrorThrowable = false;
            if (sink.syncErrorThrown) {
                throw sink.syncErrorValue;
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            sink.syncErrorThrown = true;
            sink.syncErrorValue = err;
            sink.error(err);
        }
    };
    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
     * @return {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */
    Observable.prototype.forEach = function (next, PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
                PromiseCtor = root_1.root.Rx.config.Promise;
            }
            else if (root_1.root.Promise) {
                PromiseCtor = root_1.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            // Must be declared in a separate statement to avoid a RefernceError when
            // accessing subscription below in the closure due to Temporal Dead Zone.
            var subscription;
            subscription = _this.subscribe(function (value) {
                if (subscription) {
                    // if there is a subscription, then we can surmise
                    // the next handling is asynchronous. Any errors thrown
                    // need to be rejected explicitly and unsubscribe must be
                    // called manually
                    try {
                        next(value);
                    }
                    catch (err) {
                        reject(err);
                        subscription.unsubscribe();
                    }
                }
                else {
                    // if there is NO subscription, then we're getting a nexted
                    // value synchronously during subscription. We can just call it.
                    // If it errors, Observable's `subscribe` will ensure the
                    // unsubscription logic is called, then synchronously rethrow the error.
                    // After that, Promise will trap the error and send it
                    // down the rejection path.
                    next(value);
                }
            }, reject, resolve);
        });
    };
    /** @deprecated internal use only */ Observable.prototype._subscribe = function (subscriber) {
        return this.source.subscribe(subscriber);
    };
    /**
     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
     * @method Symbol.observable
     * @return {Observable} this instance of the observable
     */
    Observable.prototype[observable_1.observable] = function () {
        return this;
    };
    /* tslint:enable:max-line-length */
    /**
     * Used to stitch together functional operators into a chain.
     * @method pipe
     * @return {Observable} the Observable result of all of the operators having
     * been called in the order they were passed in.
     *
     * @example
     *
     * import { map, filter, scan } from 'rxjs/operators';
     *
     * Rx.Observable.interval(1000)
     *   .pipe(
     *     filter(x => x % 2 === 0),
     *     map(x => x + x),
     *     scan((acc, x) => acc + x)
     *   )
     *   .subscribe(x => console.log(x))
     */
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i - 0] = arguments[_i];
        }
        if (operations.length === 0) {
            return this;
        }
        return pipe_1.pipeFromArray(operations)(this);
    };
    /* tslint:enable:max-line-length */
    Observable.prototype.toPromise = function (PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
                PromiseCtor = root_1.root.Rx.config.Promise;
            }
            else if (root_1.root.Promise) {
                PromiseCtor = root_1.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    // HACK: Since TypeScript inherits static properties too, we have to
    // fight against TypeScript here so Subject can have a different static create signature
    /**
     * Creates a new cold Observable by calling the Observable constructor
     * @static true
     * @owner Observable
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @return {Observable} a new cold observable
     */
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
exports.Observable = Observable;

},{"./symbol/observable":156,"./util/pipe":169,"./util/root":170,"./util/toSubscriber":172}],122:[function(require,module,exports){
"use strict";
exports.empty = {
    closed: true,
    next: function (value) { },
    error: function (err) { throw err; },
    complete: function () { }
};

},{}],123:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('./Subscriber');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var OuterSubscriber = (function (_super) {
    __extends(OuterSubscriber, _super);
    function OuterSubscriber() {
        _super.apply(this, arguments);
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber_1.Subscriber));
exports.OuterSubscriber = OuterSubscriber;

},{"./Subscriber":128}],124:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = require('./Subject');
var queue_1 = require('./scheduler/queue');
var Subscription_1 = require('./Subscription');
var observeOn_1 = require('./operators/observeOn');
var ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');
var SubjectSubscription_1 = require('./SubjectSubscription');
/**
 * @class ReplaySubject<T>
 */
var ReplaySubject = (function (_super) {
    __extends(ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
        if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
        _super.call(this);
        this.scheduler = scheduler;
        this._events = [];
        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        this._windowTime = windowTime < 1 ? 1 : windowTime;
    }
    ReplaySubject.prototype.next = function (value) {
        var now = this._getNow();
        this._events.push(new ReplayEvent(now, value));
        this._trimBufferThenGetEvents();
        _super.prototype.next.call(this, value);
    };
    /** @deprecated internal use only */ ReplaySubject.prototype._subscribe = function (subscriber) {
        var _events = this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var subscription;
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscription = Subscription_1.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscription = Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
        if (scheduler) {
            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));
        }
        var len = _events.length;
        for (var i = 0; i < len && !subscriber.closed; i++) {
            subscriber.next(_events[i].value);
        }
        if (this.hasError) {
            subscriber.error(this.thrownError);
        }
        else if (this.isStopped) {
            subscriber.complete();
        }
        return subscription;
    };
    ReplaySubject.prototype._getNow = function () {
        return (this.scheduler || queue_1.queue).now();
    };
    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        // Trim events that fall out of the time window.
        // Start at the front of the list. Break early once
        // we encounter an event that falls within the window.
        while (spliceCount < eventsCount) {
            if ((now - _events[spliceCount].time) < _windowTime) {
                break;
            }
            spliceCount++;
        }
        if (eventsCount > _bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
            _events.splice(0, spliceCount);
        }
        return _events;
    };
    return ReplaySubject;
}(Subject_1.Subject));
exports.ReplaySubject = ReplaySubject;
var ReplayEvent = (function () {
    function ReplayEvent(time, value) {
        this.time = time;
        this.value = value;
    }
    return ReplayEvent;
}());

},{"./Subject":126,"./SubjectSubscription":127,"./Subscription":129,"./operators/observeOn":145,"./scheduler/queue":154,"./util/ObjectUnsubscribedError":158}],125:[function(require,module,exports){
"use strict";
/**
 * An execution context and a data structure to order tasks and schedule their
 * execution. Provides a notion of (potentially virtual) time, through the
 * `now()` getter method.
 *
 * Each unit of work in a Scheduler is called an {@link Action}.
 *
 * ```ts
 * class Scheduler {
 *   now(): number;
 *   schedule(work, delay?, state?): Subscription;
 * }
 * ```
 *
 * @class Scheduler
 */
var Scheduler = (function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) { now = Scheduler.now; }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    /**
     * Schedules a function, `work`, for execution. May happen at some point in
     * the future, according to the `delay` parameter, if specified. May be passed
     * some context object, `state`, which will be passed to the `work` function.
     *
     * The given arguments will be processed an stored as an Action object in a
     * queue of actions.
     *
     * @param {function(state: ?T): ?Subscription} work A function representing a
     * task, or some unit of work to be executed by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler itself.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @return {Subscription} A subscription in order to be able to unsubscribe
     * the scheduled work.
     */
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) { delay = 0; }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };
    return Scheduler;
}());
exports.Scheduler = Scheduler;

},{}],126:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('./Observable');
var Subscriber_1 = require('./Subscriber');
var Subscription_1 = require('./Subscription');
var ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');
var SubjectSubscription_1 = require('./SubjectSubscription');
var rxSubscriber_1 = require('./symbol/rxSubscriber');
/**
 * @class SubjectSubscriber<T>
 */
var SubjectSubscriber = (function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        _super.call(this, destination);
        this.destination = destination;
    }
    return SubjectSubscriber;
}(Subscriber_1.Subscriber));
exports.SubjectSubscriber = SubjectSubscriber;
/**
 * @class Subject<T>
 */
var Subject = (function (_super) {
    __extends(Subject, _super);
    function Subject() {
        _super.call(this);
        this.observers = [];
        this.closed = false;
        this.isStopped = false;
        this.hasError = false;
        this.thrownError = null;
    }
    Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    /** @deprecated internal use only */ Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable_1.Observable));
exports.Subject = Subject;
/**
 * @class AnonymousSubject<T>
 */
var AnonymousSubject = (function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        _super.call(this);
        this.destination = destination;
        this.source = source;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    /** @deprecated internal use only */ AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return Subscription_1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));
exports.AnonymousSubject = AnonymousSubject;

},{"./Observable":121,"./SubjectSubscription":127,"./Subscriber":128,"./Subscription":129,"./symbol/rxSubscriber":157,"./util/ObjectUnsubscribedError":158}],127:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = require('./Subscription');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubjectSubscription = (function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        _super.call(this);
        this.subject = subject;
        this.subscriber = subscriber;
        this.closed = false;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1.Subscription));
exports.SubjectSubscription = SubjectSubscription;

},{"./Subscription":129}],128:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isFunction_1 = require('./util/isFunction');
var Subscription_1 = require('./Subscription');
var Observer_1 = require('./Observer');
var rxSubscriber_1 = require('./symbol/rxSubscriber');
/**
 * Implements the {@link Observer} interface and extends the
 * {@link Subscription} class. While the {@link Observer} is the public API for
 * consuming the values of an {@link Observable}, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 *
 * @class Subscriber<T>
 */
var Subscriber = (function (_super) {
    __extends(Subscriber, _super);
    /**
     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
     * defined Observer or a `next` callback function.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     */
    function Subscriber(destinationOrNext, error, complete) {
        _super.call(this);
        this.syncErrorValue = null;
        this.syncErrorThrown = false;
        this.syncErrorThrowable = false;
        this.isStopped = false;
        switch (arguments.length) {
            case 0:
                this.destination = Observer_1.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    this.destination = Observer_1.empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    // HACK(benlesh): To resolve an issue where Node users may have multiple
                    // copies of rxjs in their node_modules directory.
                    if (isTrustedSubscriber(destinationOrNext)) {
                        var trustedSubscriber = destinationOrNext[rxSubscriber_1.rxSubscriber]();
                        this.syncErrorThrowable = trustedSubscriber.syncErrorThrowable;
                        this.destination = trustedSubscriber;
                        trustedSubscriber.add(this);
                    }
                    else {
                        this.syncErrorThrowable = true;
                        this.destination = new SafeSubscriber(this, destinationOrNext);
                    }
                    break;
                }
            default:
                this.syncErrorThrowable = true;
                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
                break;
        }
    }
    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () { return this; };
    /**
     * A static factory for a Subscriber, given a (potentially partial) definition
     * of an Observer.
     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
     * Observer represented by the given arguments.
     */
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param {T} [value] The `next` value.
     * @return {void}
     */
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached {@link Error}. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param {any} [err] The `error` exception.
     * @return {void}
     */
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     * @return {void}
     */
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    /** @deprecated internal use only */ Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        this._parent = null;
        this._parents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parent = _parent;
        this._parents = _parents;
        return this;
    };
    return Subscriber;
}(Subscription_1.Subscription));
exports.Subscriber = Subscriber;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SafeSubscriber = (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        _super.call(this);
        this._parentSubscriber = _parentSubscriber;
        var next;
        var context = this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== Observer_1.empty) {
                context = Object.create(observerOrNext);
                if (isFunction_1.isFunction(context.unsubscribe)) {
                    this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = this.unsubscribe.bind(this);
            }
        }
        this._context = context;
        this._next = next;
        this._error = error;
        this._complete = complete;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._error) {
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                throw err;
            }
            else {
                _parentSubscriber.syncErrorValue = err;
                _parentSubscriber.syncErrorThrown = true;
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            throw err;
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
        }
        return false;
    };
    /** @deprecated internal use only */ SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));
function isTrustedSubscriber(obj) {
    return obj instanceof Subscriber || ('syncErrorThrowable' in obj && obj[rxSubscriber_1.rxSubscriber]);
}

},{"./Observer":122,"./Subscription":129,"./symbol/rxSubscriber":157,"./util/isFunction":164}],129:[function(require,module,exports){
"use strict";
var isArray_1 = require('./util/isArray');
var isObject_1 = require('./util/isObject');
var isFunction_1 = require('./util/isFunction');
var tryCatch_1 = require('./util/tryCatch');
var errorObject_1 = require('./util/errorObject');
var UnsubscriptionError_1 = require('./util/UnsubscriptionError');
/**
 * Represents a disposable resource, such as the execution of an Observable. A
 * Subscription has one important method, `unsubscribe`, that takes no argument
 * and just disposes the resource held by the subscription.
 *
 * Additionally, subscriptions may be grouped together through the `add()`
 * method, which will attach a child Subscription to the current Subscription.
 * When a Subscription is unsubscribed, all its children (and its grandchildren)
 * will be unsubscribed as well.
 *
 * @class Subscription
 */
var Subscription = (function () {
    /**
     * @param {function(): void} [unsubscribe] A function describing how to
     * perform the disposal of resources when the `unsubscribe` method is called.
     */
    function Subscription(unsubscribe) {
        /**
         * A flag to indicate whether this Subscription has already been unsubscribed.
         * @type {boolean}
         */
        this.closed = false;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    /**
     * Disposes the resources held by the subscription. May, for instance, cancel
     * an ongoing Observable execution or cancel any other type of work that
     * started when the Subscription was created.
     * @return {void}
     */
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parent = null;
        this._parents = null;
        // null out _subscriptions first so any child subscriptions that attempt
        // to remove themselves from this subscription will noop
        this._subscriptions = null;
        var index = -1;
        var len = _parents ? _parents.length : 0;
        // if this._parent is null, then so is this._parents, and we
        // don't have to remove ourselves from any parent subscriptions.
        while (_parent) {
            _parent.remove(this);
            // if this._parents is null or index >= len,
            // then _parent is set to null, and the loop exits
            _parent = ++index < len && _parents[index] || null;
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
            if (trial === errorObject_1.errorObject) {
                hasErrors = true;
                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?
                    flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
            }
        }
        if (isArray_1.isArray(_subscriptions)) {
            index = -1;
            len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                    if (trial === errorObject_1.errorObject) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = errorObject_1.errorObject.e;
                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                        }
                        else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    /**
     * Adds a tear down to be called during the unsubscribe() of this
     * Subscription.
     *
     * If the tear down being added is a subscription that is already
     * unsubscribed, is the same reference `add` is being called on, or is
     * `Subscription.EMPTY`, it will not be added.
     *
     * If this subscription is already in an `closed` state, the passed
     * tear down logic will be executed immediately.
     *
     * @param {TeardownLogic} teardown The additional logic to execute on
     * teardown.
     * @return {Subscription} Returns the Subscription used or created to be
     * added to the inner subscriptions list. This Subscription can be used with
     * `remove()` to remove the passed teardown logic from the inner subscriptions
     * list.
     */
    Subscription.prototype.add = function (teardown) {
        if (!teardown || (teardown === Subscription.EMPTY)) {
            return Subscription.EMPTY;
        }
        if (teardown === this) {
            return this;
        }
        var subscription = teardown;
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (typeof subscription._addParent !== 'function' /* quack quack */) {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default:
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        var subscriptions = this._subscriptions || (this._subscriptions = []);
        subscriptions.push(subscription);
        subscription._addParent(this);
        return subscription;
    };
    /**
     * Removes a Subscription from the internal list of subscriptions that will
     * unsubscribe during the unsubscribe process of this Subscription.
     * @param {Subscription} subscription The subscription to remove.
     * @return {void}
     */
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.prototype._addParent = function (parent) {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        if (!_parent || _parent === parent) {
            // If we don't have a parent, or the new parent is the same as the
            // current parent, then set this._parent to the new parent.
            this._parent = parent;
        }
        else if (!_parents) {
            // If there's already one parent, but not multiple, allocate an Array to
            // store the rest of the parent Subscriptions.
            this._parents = [parent];
        }
        else if (_parents.indexOf(parent) === -1) {
            // Only add the new parent to the _parents list if it's not already there.
            _parents.push(parent);
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
exports.Subscription = Subscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);
}

},{"./util/UnsubscriptionError":159,"./util/errorObject":161,"./util/isArray":162,"./util/isFunction":164,"./util/isObject":165,"./util/tryCatch":173}],130:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var of_1 = require('../../observable/of');
Observable_1.Observable.of = of_1.of;

},{"../../Observable":121,"../../observable/of":140}],131:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var throw_1 = require('../../observable/throw');
Observable_1.Observable.throw = throw_1._throw;

},{"../../Observable":121,"../../observable/throw":141}],132:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var map_1 = require('../../operator/map');
Observable_1.Observable.prototype.map = map_1.map;

},{"../../Observable":121,"../../operator/map":142}],133:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var throttleTime_1 = require('../../operator/throttleTime');
Observable_1.Observable.prototype.throttleTime = throttleTime_1.throttleTime;

},{"../../Observable":121,"../../operator/throttleTime":143}],134:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
var ScalarObservable_1 = require('./ScalarObservable');
var EmptyObservable_1 = require('./EmptyObservable');
var isScheduler_1 = require('../util/isScheduler');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ArrayObservable = (function (_super) {
    __extends(ArrayObservable, _super);
    function ArrayObservable(array, scheduler) {
        _super.call(this);
        this.array = array;
        this.scheduler = scheduler;
        if (!scheduler && array.length === 1) {
            this._isScalar = true;
            this.value = array[0];
        }
    }
    ArrayObservable.create = function (array, scheduler) {
        return new ArrayObservable(array, scheduler);
    };
    /**
     * Creates an Observable that emits some values you specify as arguments,
     * immediately one after the other, and then emits a complete notification.
     *
     * <span class="informal">Emits the arguments you provide, then completes.
     * </span>
     *
     * <img src="./img/of.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the arguments given, and the complete notification thereafter. It can
     * be used for composing with other Observables, such as with {@link concat}.
     * By default, it uses a `null` IScheduler, which means the `next`
     * notifications are sent synchronously, although with a different IScheduler
     * it is possible to determine when those notifications will be delivered.
     *
     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>
     * var numbers = Rx.Observable.of(10, 20, 30);
     * var letters = Rx.Observable.of('a', 'b', 'c');
     * var interval = Rx.Observable.interval(1000);
     * var result = numbers.concat(letters).concat(interval);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link throw}
     *
     * @param {...T} values Arguments that represent `next` values to be emitted.
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emissions of the `next` notifications.
     * @return {Observable<T>} An Observable that emits each given input value.
     * @static true
     * @name of
     * @owner Observable
     */
    ArrayObservable.of = function () {
        var array = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            array[_i - 0] = arguments[_i];
        }
        var scheduler = array[array.length - 1];
        if (isScheduler_1.isScheduler(scheduler)) {
            array.pop();
        }
        else {
            scheduler = null;
        }
        var len = array.length;
        if (len > 1) {
            return new ArrayObservable(array, scheduler);
        }
        else if (len === 1) {
            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
        }
        else {
            return new EmptyObservable_1.EmptyObservable(scheduler);
        }
    };
    ArrayObservable.dispatch = function (state) {
        var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;
        if (index >= count) {
            subscriber.complete();
            return;
        }
        subscriber.next(array[index]);
        if (subscriber.closed) {
            return;
        }
        state.index = index + 1;
        this.schedule(state);
    };
    /** @deprecated internal use only */ ArrayObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var array = this.array;
        var count = array.length;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ArrayObservable.dispatch, 0, {
                array: array, index: index, count: count, subscriber: subscriber
            });
        }
        else {
            for (var i = 0; i < count && !subscriber.closed; i++) {
                subscriber.next(array[i]);
            }
            subscriber.complete();
        }
    };
    return ArrayObservable;
}(Observable_1.Observable));
exports.ArrayObservable = ArrayObservable;

},{"../Observable":121,"../util/isScheduler":167,"./EmptyObservable":135,"./ScalarObservable":137}],135:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var EmptyObservable = (function (_super) {
    __extends(EmptyObservable, _super);
    function EmptyObservable(scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits a complete notification.
     *
     * <span class="informal">Just emits 'complete', and nothing else.
     * </span>
     *
     * <img src="./img/empty.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the complete notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then complete.</caption>
     * var result = Rx.Observable.empty().startWith(7);
     * result.subscribe(x => console.log(x));
     *
     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
     * );
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following to the console:
     * // x is equal to the count on the interval eg(0,1,2,3,...)
     * // x will occur every 1000ms
     * // if x % 2 is equal to 1 print abc
     * // if x % 2 is not equal to 1 nothing will be output
     *
     * @see {@link create}
     * @see {@link never}
     * @see {@link of}
     * @see {@link throw}
     *
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emission of the complete notification.
     * @return {Observable} An "empty" Observable: emits only the complete
     * notification.
     * @static true
     * @name empty
     * @owner Observable
     */
    EmptyObservable.create = function (scheduler) {
        return new EmptyObservable(scheduler);
    };
    EmptyObservable.dispatch = function (arg) {
        var subscriber = arg.subscriber;
        subscriber.complete();
    };
    /** @deprecated internal use only */ EmptyObservable.prototype._subscribe = function (subscriber) {
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });
        }
        else {
            subscriber.complete();
        }
    };
    return EmptyObservable;
}(Observable_1.Observable));
exports.EmptyObservable = EmptyObservable;

},{"../Observable":121}],136:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ErrorObservable = (function (_super) {
    __extends(ErrorObservable, _super);
    function ErrorObservable(error, scheduler) {
        _super.call(this);
        this.error = error;
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits an error notification.
     *
     * <span class="informal">Just emits 'error', and nothing else.
     * </span>
     *
     * <img src="./img/throw.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the error notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then emit an error.</caption>
     * var result = Rx.Observable.throw(new Error('oops!')).startWith(7);
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @example <caption>Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x === 13 ?
     *     Rx.Observable.throw('Thirteens are bad') :
     *     Rx.Observable.of('a', 'b', 'c')
     * );
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link of}
     *
     * @param {any} error The particular Error to pass to the error notification.
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emission of the error notification.
     * @return {Observable} An error Observable: emits only the error notification
     * using the given error argument.
     * @static true
     * @name throw
     * @owner Observable
     */
    ErrorObservable.create = function (error, scheduler) {
        return new ErrorObservable(error, scheduler);
    };
    ErrorObservable.dispatch = function (arg) {
        var error = arg.error, subscriber = arg.subscriber;
        subscriber.error(error);
    };
    /** @deprecated internal use only */ ErrorObservable.prototype._subscribe = function (subscriber) {
        var error = this.error;
        var scheduler = this.scheduler;
        subscriber.syncErrorThrowable = true;
        if (scheduler) {
            return scheduler.schedule(ErrorObservable.dispatch, 0, {
                error: error, subscriber: subscriber
            });
        }
        else {
            subscriber.error(error);
        }
    };
    return ErrorObservable;
}(Observable_1.Observable));
exports.ErrorObservable = ErrorObservable;

},{"../Observable":121}],137:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ScalarObservable = (function (_super) {
    __extends(ScalarObservable, _super);
    function ScalarObservable(value, scheduler) {
        _super.call(this);
        this.value = value;
        this.scheduler = scheduler;
        this._isScalar = true;
        if (scheduler) {
            this._isScalar = false;
        }
    }
    ScalarObservable.create = function (value, scheduler) {
        return new ScalarObservable(value, scheduler);
    };
    ScalarObservable.dispatch = function (state) {
        var done = state.done, value = state.value, subscriber = state.subscriber;
        if (done) {
            subscriber.complete();
            return;
        }
        subscriber.next(value);
        if (subscriber.closed) {
            return;
        }
        state.done = true;
        this.schedule(state);
    };
    /** @deprecated internal use only */ ScalarObservable.prototype._subscribe = function (subscriber) {
        var value = this.value;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ScalarObservable.dispatch, 0, {
                done: false, value: value, subscriber: subscriber
            });
        }
        else {
            subscriber.next(value);
            if (!subscriber.closed) {
                subscriber.complete();
            }
        }
    };
    return ScalarObservable;
}(Observable_1.Observable));
exports.ScalarObservable = ScalarObservable;

},{"../Observable":121}],138:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = require('../../Subject');
var Subscriber_1 = require('../../Subscriber');
var Observable_1 = require('../../Observable');
var Subscription_1 = require('../../Subscription');
var root_1 = require('../../util/root');
var ReplaySubject_1 = require('../../ReplaySubject');
var tryCatch_1 = require('../../util/tryCatch');
var errorObject_1 = require('../../util/errorObject');
var assign_1 = require('../../util/assign');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var WebSocketSubject = (function (_super) {
    __extends(WebSocketSubject, _super);
    function WebSocketSubject(urlConfigOrSource, destination) {
        if (urlConfigOrSource instanceof Observable_1.Observable) {
            _super.call(this, destination, urlConfigOrSource);
        }
        else {
            _super.call(this);
            this.WebSocketCtor = root_1.root.WebSocket;
            this._output = new Subject_1.Subject();
            if (typeof urlConfigOrSource === 'string') {
                this.url = urlConfigOrSource;
            }
            else {
                // WARNING: config object could override important members here.
                assign_1.assign(this, urlConfigOrSource);
            }
            if (!this.WebSocketCtor) {
                throw new Error('no WebSocket constructor can be found');
            }
            this.destination = new ReplaySubject_1.ReplaySubject();
        }
    }
    WebSocketSubject.prototype.resultSelector = function (e) {
        return JSON.parse(e.data);
    };
    /**
     * Wrapper around the w3c-compatible WebSocket object provided by the browser.
     *
     * @example <caption>Wraps browser WebSocket</caption>
     *
     * let socket$ = Observable.webSocket('ws://localhost:8081');
     *
     * socket$.subscribe(
     *    (msg) => console.log('message received: ' + msg),
     *    (err) => console.log(err),
     *    () => console.log('complete')
     *  );
     *
     * socket$.next(JSON.stringify({ op: 'hello' }));
     *
     * @example <caption>Wraps WebSocket from nodejs-websocket (using node.js)</caption>
     *
     * import { w3cwebsocket } from 'websocket';
     *
     * let socket$ = Observable.webSocket({
     *   url: 'ws://localhost:8081',
     *   WebSocketCtor: w3cwebsocket
     * });
     *
     * socket$.subscribe(
     *    (msg) => console.log('message received: ' + msg),
     *    (err) => console.log(err),
     *    () => console.log('complete')
     *  );
     *
     * socket$.next(JSON.stringify({ op: 'hello' }));
     *
     * @param {string | WebSocketSubjectConfig} urlConfigOrSource the source of the websocket as an url or a structure defining the websocket object
     * @return {WebSocketSubject}
     * @static true
     * @name webSocket
     * @owner Observable
     */
    WebSocketSubject.create = function (urlConfigOrSource) {
        return new WebSocketSubject(urlConfigOrSource);
    };
    WebSocketSubject.prototype.lift = function (operator) {
        var sock = new WebSocketSubject(this, this.destination);
        sock.operator = operator;
        return sock;
    };
    WebSocketSubject.prototype._resetState = function () {
        this.socket = null;
        if (!this.source) {
            this.destination = new ReplaySubject_1.ReplaySubject();
        }
        this._output = new Subject_1.Subject();
    };
    // TODO: factor this out to be a proper Operator/Subscriber implementation and eliminate closures
    WebSocketSubject.prototype.multiplex = function (subMsg, unsubMsg, messageFilter) {
        var self = this;
        return new Observable_1.Observable(function (observer) {
            var result = tryCatch_1.tryCatch(subMsg)();
            if (result === errorObject_1.errorObject) {
                observer.error(errorObject_1.errorObject.e);
            }
            else {
                self.next(result);
            }
            var subscription = self.subscribe(function (x) {
                var result = tryCatch_1.tryCatch(messageFilter)(x);
                if (result === errorObject_1.errorObject) {
                    observer.error(errorObject_1.errorObject.e);
                }
                else if (result) {
                    observer.next(x);
                }
            }, function (err) { return observer.error(err); }, function () { return observer.complete(); });
            return function () {
                var result = tryCatch_1.tryCatch(unsubMsg)();
                if (result === errorObject_1.errorObject) {
                    observer.error(errorObject_1.errorObject.e);
                }
                else {
                    self.next(result);
                }
                subscription.unsubscribe();
            };
        });
    };
    WebSocketSubject.prototype._connectSocket = function () {
        var _this = this;
        var WebSocketCtor = this.WebSocketCtor;
        var observer = this._output;
        var socket = null;
        try {
            socket = this.protocol ?
                new WebSocketCtor(this.url, this.protocol) :
                new WebSocketCtor(this.url);
            this.socket = socket;
            if (this.binaryType) {
                this.socket.binaryType = this.binaryType;
            }
        }
        catch (e) {
            observer.error(e);
            return;
        }
        var subscription = new Subscription_1.Subscription(function () {
            _this.socket = null;
            if (socket && socket.readyState === 1) {
                socket.close();
            }
        });
        socket.onopen = function (e) {
            var openObserver = _this.openObserver;
            if (openObserver) {
                openObserver.next(e);
            }
            var queue = _this.destination;
            _this.destination = Subscriber_1.Subscriber.create(function (x) { return socket.readyState === 1 && socket.send(x); }, function (e) {
                var closingObserver = _this.closingObserver;
                if (closingObserver) {
                    closingObserver.next(undefined);
                }
                if (e && e.code) {
                    socket.close(e.code, e.reason);
                }
                else {
                    observer.error(new TypeError('WebSocketSubject.error must be called with an object with an error code, ' +
                        'and an optional reason: { code: number, reason: string }'));
                }
                _this._resetState();
            }, function () {
                var closingObserver = _this.closingObserver;
                if (closingObserver) {
                    closingObserver.next(undefined);
                }
                socket.close();
                _this._resetState();
            });
            if (queue && queue instanceof ReplaySubject_1.ReplaySubject) {
                subscription.add(queue.subscribe(_this.destination));
            }
        };
        socket.onerror = function (e) {
            _this._resetState();
            observer.error(e);
        };
        socket.onclose = function (e) {
            _this._resetState();
            var closeObserver = _this.closeObserver;
            if (closeObserver) {
                closeObserver.next(e);
            }
            if (e.wasClean) {
                observer.complete();
            }
            else {
                observer.error(e);
            }
        };
        socket.onmessage = function (e) {
            var result = tryCatch_1.tryCatch(_this.resultSelector)(e);
            if (result === errorObject_1.errorObject) {
                observer.error(errorObject_1.errorObject.e);
            }
            else {
                observer.next(result);
            }
        };
    };
    /** @deprecated internal use only */ WebSocketSubject.prototype._subscribe = function (subscriber) {
        var _this = this;
        var source = this.source;
        if (source) {
            return source.subscribe(subscriber);
        }
        if (!this.socket) {
            this._connectSocket();
        }
        var subscription = new Subscription_1.Subscription();
        subscription.add(this._output.subscribe(subscriber));
        subscription.add(function () {
            var socket = _this.socket;
            if (_this._output.observers.length === 0) {
                if (socket && socket.readyState === 1) {
                    socket.close();
                }
                _this._resetState();
            }
        });
        return subscription;
    };
    WebSocketSubject.prototype.unsubscribe = function () {
        var _a = this, source = _a.source, socket = _a.socket;
        if (socket && socket.readyState === 1) {
            socket.close();
            this._resetState();
        }
        _super.prototype.unsubscribe.call(this);
        if (!source) {
            this.destination = new ReplaySubject_1.ReplaySubject();
        }
    };
    return WebSocketSubject;
}(Subject_1.AnonymousSubject));
exports.WebSocketSubject = WebSocketSubject;

},{"../../Observable":121,"../../ReplaySubject":124,"../../Subject":126,"../../Subscriber":128,"../../Subscription":129,"../../util/assign":160,"../../util/errorObject":161,"../../util/root":170,"../../util/tryCatch":173}],139:[function(require,module,exports){
"use strict";
var WebSocketSubject_1 = require('./WebSocketSubject');
exports.webSocket = WebSocketSubject_1.WebSocketSubject.create;

},{"./WebSocketSubject":138}],140:[function(require,module,exports){
"use strict";
var ArrayObservable_1 = require('./ArrayObservable');
exports.of = ArrayObservable_1.ArrayObservable.of;

},{"./ArrayObservable":134}],141:[function(require,module,exports){
"use strict";
var ErrorObservable_1 = require('./ErrorObservable');
exports._throw = ErrorObservable_1.ErrorObservable.create;

},{"./ErrorObservable":136}],142:[function(require,module,exports){
"use strict";
var map_1 = require('../operators/map');
/**
 * Applies a given `project` function to each value emitted by the source
 * Observable, and emits the resulting values as an Observable.
 *
 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
 * it passes each source value through a transformation function to get
 * corresponding output values.</span>
 *
 * <img src="./img/map.png" width="100%">
 *
 * Similar to the well known `Array.prototype.map` function, this operator
 * applies a projection to each value and emits that projection in the output
 * Observable.
 *
 * @example <caption>Map every click to the clientX position of that click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks.map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link mapTo}
 * @see {@link pluck}
 *
 * @param {function(value: T, index: number): R} project The function to apply
 * to each `value` emitted by the source Observable. The `index` parameter is
 * the number `i` for the i-th emission that has happened since the
 * subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to define what `this` is in the
 * `project` function.
 * @return {Observable<R>} An Observable that emits the values from the source
 * Observable transformed by the given `project` function.
 * @method map
 * @owner Observable
 */
function map(project, thisArg) {
    return map_1.map(project, thisArg)(this);
}
exports.map = map;

},{"../operators/map":144}],143:[function(require,module,exports){
"use strict";
var async_1 = require('../scheduler/async');
var throttle_1 = require('../operators/throttle');
var throttleTime_1 = require('../operators/throttleTime');
/**
 * Emits a value from the source Observable, then ignores subsequent source
 * values for `duration` milliseconds, then repeats this process.
 *
 * <span class="informal">Lets a value pass, then ignores source values for the
 * next `duration` milliseconds.</span>
 *
 * <img src="./img/throttleTime.png" width="100%">
 *
 * `throttleTime` emits the source Observable values on the output Observable
 * when its internal timer is disabled, and ignores source values when the timer
 * is enabled. Initially, the timer is disabled. As soon as the first source
 * value arrives, it is forwarded to the output Observable, and then the timer
 * is enabled. After `duration` milliseconds (or the time unit determined
 * internally by the optional `scheduler`) has passed, the timer is disabled,
 * and this process repeats for the next source value. Optionally takes a
 * {@link IScheduler} for managing timers.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.throttleTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounceTime}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttle}
 *
 * @param {number} duration Time to wait before emitting another value after
 * emitting the last value, measured in milliseconds or the time unit determined
 * internally by the optional `scheduler`.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the throttling.
 * @return {Observable<T>} An Observable that performs the throttle operation to
 * limit the rate of emissions from the source.
 * @method throttleTime
 * @owner Observable
 */
function throttleTime(duration, scheduler, config) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    if (config === void 0) { config = throttle_1.defaultThrottleConfig; }
    return throttleTime_1.throttleTime(duration, scheduler, config)(this);
}
exports.throttleTime = throttleTime;

},{"../operators/throttle":146,"../operators/throttleTime":147,"../scheduler/async":153}],144:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/**
 * Applies a given `project` function to each value emitted by the source
 * Observable, and emits the resulting values as an Observable.
 *
 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
 * it passes each source value through a transformation function to get
 * corresponding output values.</span>
 *
 * <img src="./img/map.png" width="100%">
 *
 * Similar to the well known `Array.prototype.map` function, this operator
 * applies a projection to each value and emits that projection in the output
 * Observable.
 *
 * @example <caption>Map every click to the clientX position of that click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks.map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link mapTo}
 * @see {@link pluck}
 *
 * @param {function(value: T, index: number): R} project The function to apply
 * to each `value` emitted by the source Observable. The `index` parameter is
 * the number `i` for the i-th emission that has happened since the
 * subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to define what `this` is in the
 * `project` function.
 * @return {Observable<R>} An Observable that emits the values from the source
 * Observable transformed by the given `project` function.
 * @method map
 * @owner Observable
 */
function map(project, thisArg) {
    return function mapOperation(source) {
        if (typeof project !== 'function') {
            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }
        return source.lift(new MapOperator(project, thisArg));
    };
}
exports.map = map;
var MapOperator = (function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}());
exports.MapOperator = MapOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapSubscriber = (function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        _super.call(this, destination);
        this.project = project;
        this.count = 0;
        this.thisArg = thisArg || this;
    }
    // NOTE: This looks unoptimized, but it's actually purposefully NOT
    // using try/catch optimizations.
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":128}],145:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var Notification_1 = require('../Notification');
/**
 *
 * Re-emits all notifications from source Observable with specified scheduler.
 *
 * <span class="informal">Ensure a specific scheduler is used, from outside of an Observable.</span>
 *
 * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule
 * notifications emitted by the source Observable. It might be useful, if you do not have control over
 * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.
 *
 * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,
 * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal
 * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits
 * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.
 * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split
 * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source
 * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a
 * little bit more, to ensure that they are emitted at expected moments.
 *
 * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications
 * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`
 * will delay all notifications - including error notifications - while `delay` will pass through error
 * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator
 * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used
 * for notification emissions in general.
 *
 * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>
 * const intervals = Rx.Observable.interval(10); // Intervals are scheduled
 *                                               // with async scheduler by default...
 *
 * intervals
 * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame
 * .subscribe(val => {                           // scheduler to ensure smooth animation.
 *   someDiv.style.height = val + 'px';
 * });
 *
 * @see {@link delay}
 *
 * @param {IScheduler} scheduler Scheduler that will be used to reschedule notifications from source Observable.
 * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.
 * @return {Observable<T>} Observable that emits the same notifications as the source Observable,
 * but with provided scheduler.
 *
 * @method observeOn
 * @owner Observable
 */
function observeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return function observeOnOperatorFunction(source) {
        return source.lift(new ObserveOnOperator(scheduler, delay));
    };
}
exports.observeOn = observeOn;
var ObserveOnOperator = (function () {
    function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator;
}());
exports.ObserveOnOperator = ObserveOnOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ObserveOnSubscriber = (function (_super) {
    __extends(ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        _super.call(this, destination);
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(Notification_1.Notification.createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(Notification_1.Notification.createError(err));
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(Notification_1.Notification.createComplete());
    };
    return ObserveOnSubscriber;
}(Subscriber_1.Subscriber));
exports.ObserveOnSubscriber = ObserveOnSubscriber;
var ObserveOnMessage = (function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}());
exports.ObserveOnMessage = ObserveOnMessage;

},{"../Notification":120,"../Subscriber":128}],146:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
exports.defaultThrottleConfig = {
    leading: true,
    trailing: false
};
/**
 * Emits a value from the source Observable, then ignores subsequent source
 * values for a duration determined by another Observable, then repeats this
 * process.
 *
 * <span class="informal">It's like {@link throttleTime}, but the silencing
 * duration is determined by a second Observable.</span>
 *
 * <img src="./img/throttle.png" width="100%">
 *
 * `throttle` emits the source Observable values on the output Observable
 * when its internal timer is disabled, and ignores source values when the timer
 * is enabled. Initially, the timer is disabled. As soon as the first source
 * value arrives, it is forwarded to the output Observable, and then the timer
 * is enabled by calling the `durationSelector` function with the source value,
 * which returns the "duration" Observable. When the duration Observable emits a
 * value or completes, the timer is disabled, and this process repeats for the
 * next source value.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.throttle(ev => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounce}
 * @see {@link delayWhen}
 * @see {@link sample}
 * @see {@link throttleTime}
 *
 * @param {function(value: T): SubscribableOrPromise} durationSelector A function
 * that receives a value from the source Observable, for computing the silencing
 * duration for each source value, returned as an Observable or a Promise.
 * @param {Object} config a configuration object to define `leading` and `trailing` behavior. Defaults
 * to `{ leading: true, trailing: false }`.
 * @return {Observable<T>} An Observable that performs the throttle operation to
 * limit the rate of emissions from the source.
 * @method throttle
 * @owner Observable
 */
function throttle(durationSelector, config) {
    if (config === void 0) { config = exports.defaultThrottleConfig; }
    return function (source) { return source.lift(new ThrottleOperator(durationSelector, config.leading, config.trailing)); };
}
exports.throttle = throttle;
var ThrottleOperator = (function () {
    function ThrottleOperator(durationSelector, leading, trailing) {
        this.durationSelector = durationSelector;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
    };
    return ThrottleOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc
 * @ignore
 * @extends {Ignored}
 */
var ThrottleSubscriber = (function (_super) {
    __extends(ThrottleSubscriber, _super);
    function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
        _super.call(this, destination);
        this.destination = destination;
        this.durationSelector = durationSelector;
        this._leading = _leading;
        this._trailing = _trailing;
        this._hasTrailingValue = false;
    }
    ThrottleSubscriber.prototype._next = function (value) {
        if (this.throttled) {
            if (this._trailing) {
                this._hasTrailingValue = true;
                this._trailingValue = value;
            }
        }
        else {
            var duration = this.tryDurationSelector(value);
            if (duration) {
                this.add(this.throttled = subscribeToResult_1.subscribeToResult(this, duration));
            }
            if (this._leading) {
                this.destination.next(value);
                if (this._trailing) {
                    this._hasTrailingValue = true;
                    this._trailingValue = value;
                }
            }
        }
    };
    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
        try {
            return this.durationSelector(value);
        }
        catch (err) {
            this.destination.error(err);
            return null;
        }
    };
    /** @deprecated internal use only */ ThrottleSubscriber.prototype._unsubscribe = function () {
        var _a = this, throttled = _a.throttled, _trailingValue = _a._trailingValue, _hasTrailingValue = _a._hasTrailingValue, _trailing = _a._trailing;
        this._trailingValue = null;
        this._hasTrailingValue = false;
        if (throttled) {
            this.remove(throttled);
            this.throttled = null;
            throttled.unsubscribe();
        }
    };
    ThrottleSubscriber.prototype._sendTrailing = function () {
        var _a = this, destination = _a.destination, throttled = _a.throttled, _trailing = _a._trailing, _trailingValue = _a._trailingValue, _hasTrailingValue = _a._hasTrailingValue;
        if (throttled && _trailing && _hasTrailingValue) {
            destination.next(_trailingValue);
            this._trailingValue = null;
            this._hasTrailingValue = false;
        }
    };
    ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this._sendTrailing();
        this._unsubscribe();
    };
    ThrottleSubscriber.prototype.notifyComplete = function () {
        this._sendTrailing();
        this._unsubscribe();
    };
    return ThrottleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":123,"../util/subscribeToResult":171}],147:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var async_1 = require('../scheduler/async');
var throttle_1 = require('./throttle');
/**
 * Emits a value from the source Observable, then ignores subsequent source
 * values for `duration` milliseconds, then repeats this process.
 *
 * <span class="informal">Lets a value pass, then ignores source values for the
 * next `duration` milliseconds.</span>
 *
 * <img src="./img/throttleTime.png" width="100%">
 *
 * `throttleTime` emits the source Observable values on the output Observable
 * when its internal timer is disabled, and ignores source values when the timer
 * is enabled. Initially, the timer is disabled. As soon as the first source
 * value arrives, it is forwarded to the output Observable, and then the timer
 * is enabled. After `duration` milliseconds (or the time unit determined
 * internally by the optional `scheduler`) has passed, the timer is disabled,
 * and this process repeats for the next source value. Optionally takes a
 * {@link IScheduler} for managing timers.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.throttleTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounceTime}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttle}
 *
 * @param {number} duration Time to wait before emitting another value after
 * emitting the last value, measured in milliseconds or the time unit determined
 * internally by the optional `scheduler`.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the throttling.
 * @return {Observable<T>} An Observable that performs the throttle operation to
 * limit the rate of emissions from the source.
 * @method throttleTime
 * @owner Observable
 */
function throttleTime(duration, scheduler, config) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    if (config === void 0) { config = throttle_1.defaultThrottleConfig; }
    return function (source) { return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing)); };
}
exports.throttleTime = throttleTime;
var ThrottleTimeOperator = (function () {
    function ThrottleTimeOperator(duration, scheduler, leading, trailing) {
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
    };
    return ThrottleTimeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ThrottleTimeSubscriber = (function (_super) {
    __extends(ThrottleTimeSubscriber, _super);
    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
        _super.call(this, destination);
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
        this._hasTrailingValue = false;
        this._trailingValue = null;
    }
    ThrottleTimeSubscriber.prototype._next = function (value) {
        if (this.throttled) {
            if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
        else {
            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));
            if (this.leading) {
                this.destination.next(value);
            }
        }
    };
    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
        var throttled = this.throttled;
        if (throttled) {
            if (this.trailing && this._hasTrailingValue) {
                this.destination.next(this._trailingValue);
                this._trailingValue = null;
                this._hasTrailingValue = false;
            }
            throttled.unsubscribe();
            this.remove(throttled);
            this.throttled = null;
        }
    };
    return ThrottleTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNext(arg) {
    var subscriber = arg.subscriber;
    subscriber.clearThrottle();
}

},{"../Subscriber":128,"../scheduler/async":153,"./throttle":146}],148:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = require('../Subscription');
/**
 * A unit of work to be executed in a {@link Scheduler}. An action is typically
 * created from within a Scheduler and an RxJS user does not need to concern
 * themselves about creating and manipulating an Action.
 *
 * ```ts
 * class Action<T> extends Subscription {
 *   new (scheduler: Scheduler, work: (state?: T) => void);
 *   schedule(state?: T, delay: number = 0): Subscription;
 * }
 * ```
 *
 * @class Action<T>
 */
var Action = (function (_super) {
    __extends(Action, _super);
    function Action(scheduler, work) {
        _super.call(this);
    }
    /**
     * Schedules this action on its parent Scheduler for execution. May be passed
     * some context object, `state`. May happen at some point in the future,
     * according to the `delay` parameter, if specified.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler.
     * @return {void}
     */
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        return this;
    };
    return Action;
}(Subscription_1.Subscription));
exports.Action = Action;

},{"../Subscription":129}],149:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = require('../util/root');
var Action_1 = require('./Action');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AsyncAction = (function (_super) {
    __extends(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.pending = false;
        this.work = work;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (this.closed) {
            return this;
        }
        // Always replace the current state with the new state.
        this.state = state;
        // Set the pending flag indicating that this action has been scheduled, or
        // has recursively rescheduled itself.
        this.pending = true;
        var id = this.id;
        var scheduler = this.scheduler;
        //
        // Important implementation note:
        //
        // Actions only execute once by default, unless rescheduled from within the
        // scheduled callback. This allows us to implement single and repeat
        // actions via the same code path, without adding API surface area, as well
        // as mimic traditional recursion but across asynchronous boundaries.
        //
        // However, JS runtimes and timers distinguish between intervals achieved by
        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of
        // serial `setTimeout` calls can be individually delayed, which delays
        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to
        // guarantee the interval callback will be invoked more precisely to the
        // interval period, regardless of load.
        //
        // Therefore, we use `setInterval` to schedule single and repeat actions.
        // If the action reschedules itself with the same delay, the interval is not
        // canceled. If the action doesn't reschedule, or reschedules with a
        // different delay, the interval will be canceled after scheduled callback
        // execution.
        //
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.delay = delay;
        // If this action has already an async Id, don't request a new one.
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        // If this action is rescheduled with the same delay time, don't clear the interval id.
        if (delay !== null && this.delay === delay && this.pending === false) {
            return id;
        }
        // Otherwise, if the action's delay time is different from the current delay,
        // or the action has been rescheduled before it's executed, clear the interval id
        return root_1.root.clearInterval(id) && undefined || undefined;
    };
    /**
     * Immediately executes this action and the `work` it contains.
     * @return {any}
     */
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        }
        else if (this.pending === false && this.id != null) {
            // Dequeue if the action didn't reschedule itself. Don't call
            // unsubscribe(), because the action could reschedule later.
            // For example:
            // ```
            // scheduler.schedule(function doWork(counter) {
            //   /* ... I'm a busy worker bee ... */
            //   var originalAction = this;
            //   /* wait 100ms before rescheduling the action */
            //   setTimeout(function () {
            //     originalAction.schedule(counter + 1);
            //   }, 100);
            // }, 1000);
            // ```
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        }
        catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    /** @deprecated internal use only */ AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
    };
    return AsyncAction;
}(Action_1.Action));
exports.AsyncAction = AsyncAction;

},{"../util/root":170,"./Action":148}],150:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Scheduler_1 = require('../Scheduler');
var AsyncScheduler = (function (_super) {
    __extends(AsyncScheduler, _super);
    function AsyncScheduler() {
        _super.apply(this, arguments);
        this.actions = [];
        /**
         * A flag to indicate whether the Scheduler is currently executing a batch of
         * queued actions.
         * @type {boolean}
         */
        this.active = false;
        /**
         * An internal ID used to track the latest asynchronous task such as those
         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
         * others.
         * @type {any}
         */
        this.scheduled = undefined;
    }
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift()); // exhaust the scheduler queue
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler_1.Scheduler));
exports.AsyncScheduler = AsyncScheduler;

},{"../Scheduler":125}],151:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var AsyncAction_1 = require('./AsyncAction');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var QueueAction = (function (_super) {
    __extends(QueueAction, _super);
    function QueueAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
    }
    QueueAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay > 0) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction.prototype.execute = function (state, delay) {
        return (delay > 0 || this.closed) ?
            _super.prototype.execute.call(this, state, delay) :
            this._execute(state, delay);
    };
    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        // If delay exists and is greater than 0, or if the delay is null (the
        // action wasn't rescheduled) but was originally scheduled as an async
        // action, then recycle as an async action.
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        // Otherwise flush the scheduler starting with this action.
        return scheduler.flush(this);
    };
    return QueueAction;
}(AsyncAction_1.AsyncAction));
exports.QueueAction = QueueAction;

},{"./AsyncAction":149}],152:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var AsyncScheduler_1 = require('./AsyncScheduler');
var QueueScheduler = (function (_super) {
    __extends(QueueScheduler, _super);
    function QueueScheduler() {
        _super.apply(this, arguments);
    }
    return QueueScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.QueueScheduler = QueueScheduler;

},{"./AsyncScheduler":150}],153:[function(require,module,exports){
"use strict";
var AsyncAction_1 = require('./AsyncAction');
var AsyncScheduler_1 = require('./AsyncScheduler');
/**
 *
 * Async Scheduler
 *
 * <span class="informal">Schedule task as if you used setTimeout(task, duration)</span>
 *
 * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript
 * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating
 * in intervals.
 *
 * If you just want to "defer" task, that is to perform it right after currently
 * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),
 * better choice will be the {@link asap} scheduler.
 *
 * @example <caption>Use async scheduler to delay task</caption>
 * const task = () => console.log('it works!');
 *
 * Rx.Scheduler.async.schedule(task, 2000);
 *
 * // After 2 seconds logs:
 * // "it works!"
 *
 *
 * @example <caption>Use async scheduler to repeat task in intervals</caption>
 * function task(state) {
 *   console.log(state);
 *   this.schedule(state + 1, 1000); // `this` references currently executing Action,
 *                                   // which we reschedule with new state and delay
 * }
 *
 * Rx.Scheduler.async.schedule(task, 3000, 0);
 *
 * // Logs:
 * // 0 after 3s
 * // 1 after 4s
 * // 2 after 5s
 * // 3 after 6s
 *
 * @static true
 * @name async
 * @owner Scheduler
 */
exports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);

},{"./AsyncAction":149,"./AsyncScheduler":150}],154:[function(require,module,exports){
"use strict";
var QueueAction_1 = require('./QueueAction');
var QueueScheduler_1 = require('./QueueScheduler');
/**
 *
 * Queue Scheduler
 *
 * <span class="informal">Put every next task on a queue, instead of executing it immediately</span>
 *
 * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.
 *
 * When used without delay, it schedules given task synchronously - executes it right when
 * it is scheduled. However when called recursively, that is when inside the scheduled task,
 * another task is scheduled with queue scheduler, instead of executing immediately as well,
 * that task will be put on a queue and wait for current one to finish.
 *
 * This means that when you execute task with `queue` scheduler, you are sure it will end
 * before any other task scheduled with that scheduler will start.
 *
 * @examples <caption>Schedule recursively first, then do something</caption>
 *
 * Rx.Scheduler.queue.schedule(() => {
 *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue
 *
 *   console.log('first');
 * });
 *
 * // Logs:
 * // "first"
 * // "second"
 *
 *
 * @example <caption>Reschedule itself recursively</caption>
 *
 * Rx.Scheduler.queue.schedule(function(state) {
 *   if (state !== 0) {
 *     console.log('before', state);
 *     this.schedule(state - 1); // `this` references currently executing Action,
 *                               // which we reschedule with new state
 *     console.log('after', state);
 *   }
 * }, 0, 3);
 *
 * // In scheduler that runs recursively, you would expect:
 * // "before", 3
 * // "before", 2
 * // "before", 1
 * // "after", 1
 * // "after", 2
 * // "after", 3
 *
 * // But with queue it logs:
 * // "before", 3
 * // "after", 3
 * // "before", 2
 * // "after", 2
 * // "before", 1
 * // "after", 1
 *
 *
 * @static true
 * @name queue
 * @owner Scheduler
 */
exports.queue = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);

},{"./QueueAction":151,"./QueueScheduler":152}],155:[function(require,module,exports){
"use strict";
var root_1 = require('../util/root');
function symbolIteratorPonyfill(root) {
    var Symbol = root.Symbol;
    if (typeof Symbol === 'function') {
        if (!Symbol.iterator) {
            Symbol.iterator = Symbol('iterator polyfill');
        }
        return Symbol.iterator;
    }
    else {
        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)
        var Set_1 = root.Set;
        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {
            return '@@iterator';
        }
        var Map_1 = root.Map;
        // required for compatability with es6-shim
        if (Map_1) {
            var keys = Object.getOwnPropertyNames(Map_1.prototype);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.
                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {
                    return key;
                }
            }
        }
        return '@@iterator';
    }
}
exports.symbolIteratorPonyfill = symbolIteratorPonyfill;
exports.iterator = symbolIteratorPonyfill(root_1.root);
/**
 * @deprecated use iterator instead
 */
exports.$$iterator = exports.iterator;

},{"../util/root":170}],156:[function(require,module,exports){
"use strict";
var root_1 = require('../util/root');
function getSymbolObservable(context) {
    var $$observable;
    var Symbol = context.Symbol;
    if (typeof Symbol === 'function') {
        if (Symbol.observable) {
            $$observable = Symbol.observable;
        }
        else {
            $$observable = Symbol('observable');
            Symbol.observable = $$observable;
        }
    }
    else {
        $$observable = '@@observable';
    }
    return $$observable;
}
exports.getSymbolObservable = getSymbolObservable;
exports.observable = getSymbolObservable(root_1.root);
/**
 * @deprecated use observable instead
 */
exports.$$observable = exports.observable;

},{"../util/root":170}],157:[function(require,module,exports){
"use strict";
var root_1 = require('../util/root');
var Symbol = root_1.root.Symbol;
exports.rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
    Symbol.for('rxSubscriber') : '@@rxSubscriber';
/**
 * @deprecated use rxSubscriber instead
 */
exports.$$rxSubscriber = exports.rxSubscriber;

},{"../util/root":170}],158:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an action is invalid because the object has been
 * unsubscribed.
 *
 * @see {@link Subject}
 * @see {@link BehaviorSubject}
 *
 * @class ObjectUnsubscribedError
 */
var ObjectUnsubscribedError = (function (_super) {
    __extends(ObjectUnsubscribedError, _super);
    function ObjectUnsubscribedError() {
        var err = _super.call(this, 'object unsubscribed');
        this.name = err.name = 'ObjectUnsubscribedError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ObjectUnsubscribedError;
}(Error));
exports.ObjectUnsubscribedError = ObjectUnsubscribedError;

},{}],159:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when one or more errors have occurred during the
 * `unsubscribe` of a {@link Subscription}.
 */
var UnsubscriptionError = (function (_super) {
    __extends(UnsubscriptionError, _super);
    function UnsubscriptionError(errors) {
        _super.call(this);
        this.errors = errors;
        var err = Error.call(this, errors ?
            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n  ') : '');
        this.name = err.name = 'UnsubscriptionError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return UnsubscriptionError;
}(Error));
exports.UnsubscriptionError = UnsubscriptionError;

},{}],160:[function(require,module,exports){
"use strict";
var root_1 = require('./root');
function assignImpl(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    var len = sources.length;
    for (var i = 0; i < len; i++) {
        var source = sources[i];
        for (var k in source) {
            if (source.hasOwnProperty(k)) {
                target[k] = source[k];
            }
        }
    }
    return target;
}
exports.assignImpl = assignImpl;
;
function getAssign(root) {
    return root.Object.assign || assignImpl;
}
exports.getAssign = getAssign;
exports.assign = getAssign(root_1.root);

},{"./root":170}],161:[function(require,module,exports){
"use strict";
// typeof any so that it we don't have to cast when comparing a result to the error object
exports.errorObject = { e: {} };

},{}],162:[function(require,module,exports){
"use strict";
exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });

},{}],163:[function(require,module,exports){
"use strict";
exports.isArrayLike = (function (x) { return x && typeof x.length === 'number'; });

},{}],164:[function(require,module,exports){
"use strict";
function isFunction(x) {
    return typeof x === 'function';
}
exports.isFunction = isFunction;

},{}],165:[function(require,module,exports){
"use strict";
function isObject(x) {
    return x != null && typeof x === 'object';
}
exports.isObject = isObject;

},{}],166:[function(require,module,exports){
"use strict";
function isPromise(value) {
    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
exports.isPromise = isPromise;

},{}],167:[function(require,module,exports){
"use strict";
function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}
exports.isScheduler = isScheduler;

},{}],168:[function(require,module,exports){
"use strict";
/* tslint:disable:no-empty */
function noop() { }
exports.noop = noop;

},{}],169:[function(require,module,exports){
"use strict";
var noop_1 = require('./noop');
/* tslint:enable:max-line-length */
function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i - 0] = arguments[_i];
    }
    return pipeFromArray(fns);
}
exports.pipe = pipe;
/* @internal */
function pipeFromArray(fns) {
    if (!fns) {
        return noop_1.noop;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}
exports.pipeFromArray = pipeFromArray;

},{"./noop":168}],170:[function(require,module,exports){
(function (global){
"use strict";
// CommonJS / Node have global context exposed as "global" variable.
// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake
// the global "global" var for now.
var __window = typeof window !== 'undefined' && window;
var __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&
    self instanceof WorkerGlobalScope && self;
var __global = typeof global !== 'undefined' && global;
var _root = __window || __global || __self;
exports.root = _root;
// Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.
// This is needed when used with angular/tsickle which inserts a goog.module statement.
// Wrap in IIFE
(function () {
    if (!_root) {
        throw new Error('RxJS could not find any global context (window, self, global)');
    }
})();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],171:[function(require,module,exports){
"use strict";
var root_1 = require('./root');
var isArrayLike_1 = require('./isArrayLike');
var isPromise_1 = require('./isPromise');
var isObject_1 = require('./isObject');
var Observable_1 = require('../Observable');
var iterator_1 = require('../symbol/iterator');
var InnerSubscriber_1 = require('../InnerSubscriber');
var observable_1 = require('../symbol/observable');
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
    if (destination.closed) {
        return null;
    }
    if (result instanceof Observable_1.Observable) {
        if (result._isScalar) {
            destination.next(result.value);
            destination.complete();
            return null;
        }
        else {
            destination.syncErrorThrowable = true;
            return result.subscribe(destination);
        }
    }
    else if (isArrayLike_1.isArrayLike(result)) {
        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {
            destination.next(result[i]);
        }
        if (!destination.closed) {
            destination.complete();
        }
    }
    else if (isPromise_1.isPromise(result)) {
        result.then(function (value) {
            if (!destination.closed) {
                destination.next(value);
                destination.complete();
            }
        }, function (err) { return destination.error(err); })
            .then(null, function (err) {
            // Escaping the Promise trap: globally throw unhandled errors
            root_1.root.setTimeout(function () { throw err; });
        });
        return destination;
    }
    else if (result && typeof result[iterator_1.iterator] === 'function') {
        var iterator = result[iterator_1.iterator]();
        do {
            var item = iterator.next();
            if (item.done) {
                destination.complete();
                break;
            }
            destination.next(item.value);
            if (destination.closed) {
                break;
            }
        } while (true);
    }
    else if (result && typeof result[observable_1.observable] === 'function') {
        var obs = result[observable_1.observable]();
        if (typeof obs.subscribe !== 'function') {
            destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));
        }
        else {
            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));
        }
    }
    else {
        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = ("You provided " + value + " where a stream was expected.")
            + ' You can provide an Observable, Promise, Array, or Iterable.';
        destination.error(new TypeError(msg));
    }
    return null;
}
exports.subscribeToResult = subscribeToResult;

},{"../InnerSubscriber":119,"../Observable":121,"../symbol/iterator":155,"../symbol/observable":156,"./isArrayLike":163,"./isObject":165,"./isPromise":166,"./root":170}],172:[function(require,module,exports){
"use strict";
var Subscriber_1 = require('../Subscriber');
var rxSubscriber_1 = require('../symbol/rxSubscriber');
var Observer_1 = require('../Observer');
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {
            return nextOrObserver[rxSubscriber_1.rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber(Observer_1.empty);
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
exports.toSubscriber = toSubscriber;

},{"../Observer":122,"../Subscriber":128,"../symbol/rxSubscriber":157}],173:[function(require,module,exports){
"use strict";
var errorObject_1 = require('./errorObject');
var tryCatchTarget;
function tryCatcher() {
    try {
        return tryCatchTarget.apply(this, arguments);
    }
    catch (e) {
        errorObject_1.errorObject.e = e;
        return errorObject_1.errorObject;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}
exports.tryCatch = tryCatch;
;

},{"./errorObject":161}],174:[function(require,module,exports){
function Agent() {
  this._defaults = [];
}

["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects",
 "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert"].forEach(function(fn) {
  /** Default setting for all requests from this agent */
  Agent.prototype[fn] = function(/*varargs*/) {
    this._defaults.push({fn:fn, arguments:arguments});
    return this;
  }
});

Agent.prototype._setDefaults = function(req) {
    this._defaults.forEach(function(def) {
      req[def.fn].apply(req, def.arguments);
    });
};

module.exports = Agent;

},{}],175:[function(require,module,exports){
/**
 * Root reference for iframes.
 */

var root;
if (typeof window !== 'undefined') { // Browser window
  root = window;
} else if (typeof self !== 'undefined') { // Web Worker
  root = self;
} else { // Other environments
  console.warn("Using browser-only version of superagent in non-browser environment");
  root = this;
}

var Emitter = require('component-emitter');
var RequestBase = require('./request-base');
var isObject = require('./is-object');
var ResponseBase = require('./response-base');
var Agent = require('./agent-base');

/**
 * Noop.
 */

function noop(){};

/**
 * Expose `request`.
 */

var request = exports = module.exports = function(method, url) {
  // callback
  if ('function' == typeof url) {
    return new exports.Request('GET', method).end(url);
  }

  // url first
  if (1 == arguments.length) {
    return new exports.Request('GET', method);
  }

  return new exports.Request(method, url);
}

exports.Request = Request;

/**
 * Determine XHR.
 */

request.getXHR = function () {
  if (root.XMLHttpRequest
      && (!root.location || 'file:' != root.location.protocol
          || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  throw Error("Browser-only version of superagent could not find XHR");
};

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

var trim = ''.trim
  ? function(s) { return s.trim(); }
  : function(s) { return s.replace(/(^\s*|\s*$)/g, ''); };

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];
  for (var key in obj) {
    pushEncodedKeyValuePair(pairs, key, obj[key]);
  }
  return pairs.join('&');
}

/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */

function pushEncodedKeyValuePair(pairs, key, val) {
  if (val != null) {
    if (Array.isArray(val)) {
      val.forEach(function(v) {
        pushEncodedKeyValuePair(pairs, key, v);
      });
    } else if (isObject(val)) {
      for(var subkey in val) {
        pushEncodedKeyValuePair(pairs, key + '[' + subkey + ']', val[subkey]);
      }
    } else {
      pairs.push(encodeURIComponent(key)
        + '=' + encodeURIComponent(val));
    }
  } else if (val === null) {
    pairs.push(encodeURIComponent(key));
  }
}

/**
 * Expose serialization method.
 */

request.serializeObject = serialize;

/**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var pair;
  var pos;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');
    if (pos == -1) {
      obj[decodeURIComponent(pair)] = '';
    } else {
      obj[decodeURIComponent(pair.slice(0, pos))] =
        decodeURIComponent(pair.slice(pos + 1));
    }
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'text/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

request.serialize = {
  'application/x-www-form-urlencoded': serialize,
  'application/json': JSON.stringify,
};

/**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse,
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    if (index === -1) { // could be empty line, just skip it
      continue;
    }
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */

function isJSON(mime) {
  // should match /json or +json
  // but not /json-seq
  return /[\/+]json($|[^-\w])/.test(mime);
}

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req) {
  this.req = req;
  this.xhr = this.req.xhr;
  // responseText is accessible only if responseType is '' or 'text' and on older browsers
  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')
     ? this.xhr.responseText
     : null;
  this.statusText = this.req.xhr.statusText;
  var status = this.xhr.status;
  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
  if (status === 1223) {
    status = 204;
  }
  this._setStatusProperties(status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this._setHeaderProperties(this.header);

  if (null === this.text && req._responseType) {
    this.body = this.xhr.response;
  } else {
    this.body = this.req.method != 'HEAD'
      ? this._parseBody(this.text ? this.text : this.xhr.response)
      : null;
  }
}

ResponseBase(Response.prototype);

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function(str) {
  var parse = request.parse[this.type];
  if (this.req._parser) {
    return this.req._parser(this, str);
  }
  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }
  return parse && str && (str.length || str instanceof Object)
    ? parse(str)
    : null;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  var req = this.req;
  var method = req.method;
  var url = req.url;

  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case
  this._header = {}; // coerces header names to lowercase
  this.on('end', function(){
    var err = null;
    var res = null;

    try {
      res = new Response(self);
    } catch(e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
      // issue #675: return the raw response if the response parsing fails
      if (self.xhr) {
        // ie9 doesn't have 'response' property
        err.rawResponse = typeof self.xhr.responseType == 'undefined' ? self.xhr.responseText : self.xhr.response;
        // issue #876: return the http status code if the response parsing fails
        err.status = self.xhr.status ? self.xhr.status : null;
        err.statusCode = err.status; // backwards-compat only
      } else {
        err.rawResponse = null;
        err.status = null;
      }

      return self.callback(err);
    }

    self.emit('response', res);

    var new_err;
    try {
      if (!self._isResponseOK(res)) {
        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
      }
    } catch(custom_err) {
      new_err = custom_err; // ok() callback can throw
    }

    // #1000 don't catch errors from the callback to avoid double calling it
    if (new_err) {
      new_err.original = err;
      new_err.response = res;
      new_err.status = res.status;
      self.callback(new_err, res);
    } else {
      self.callback(null, res);
    }
  });
}

/**
 * Mixin `Emitter` and `RequestBase`.
 */

Emitter(Request.prototype);
RequestBase(Request.prototype);

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} [pass] optional in case of using 'bearer' as type
 * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass, options){
  if (1 === arguments.length) pass = '';
  if (typeof pass === 'object' && pass !== null) { // pass is optional and can be replaced with options
    options = pass;
    pass = '';
  }
  if (!options) {
    options = {
      type: 'function' === typeof btoa ? 'basic' : 'auto',
    };
  }

  var encoder = function(string) {
    if ('function' === typeof btoa) {
      return btoa(string);
    }
    throw new Error('Cannot use basic auth, btoa is not a function');
  };

  return this._auth(user, pass, options, encoder);
};

/**
 * Add query-string `val`.
 *
 * Examples:
 *
 *   request.get('/shoes')
 *     .query('size=10')
 *     .query({ color: 'blue' })
 *
 * @param {Object|String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `options` (or filename).
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String|Object} options
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function(field, file, options){
  if (file) {
    if (this._data) {
      throw Error("superagent can't mix .send() and .attach()");
    }

    this._getFormData().append(field, file, options || file.name);
  }
  return this;
};

Request.prototype._getFormData = function(){
  if (!this._formData) {
    this._formData = new root.FormData();
  }
  return this._formData;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  if (this._shouldRetry(err, res)) {
    return this._retry();
  }

  var fn = this._callback;
  this.clearTimeout();

  if (err) {
    if (this._maxRetries) err.retries = this._retries - 1;
    this.emit('error', err);
  }

  fn(err, res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;

  err.status = this.status;
  err.method = this.method;
  err.url = this.url;

  this.callback(err);
};

// This only warns, because the request is still likely to work
Request.prototype.buffer = Request.prototype.ca = Request.prototype.agent = function(){
  console.warn("This is not supported in browser version of superagent");
  return this;
};

// This throws, because it can't send/receive data as expected
Request.prototype.pipe = Request.prototype.write = function(){
  throw Error("Streaming is not supported in browser version of superagent");
};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */
Request.prototype._isHost = function _isHost(obj) {
  // Native objects stringify to [object File], [object Blob], [object FormData], etc.
  return obj && 'object' === typeof obj && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';
}

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  if (this._endCalled) {
    console.warn("Warning: .end() was called twice. This is not supported in superagent");
  }
  this._endCalled = true;

  // store callback
  this._callback = fn || noop;

  // querystring
  this._finalizeQueryString();

  return this._end();
};

Request.prototype._end = function() {
  var self = this;
  var xhr = (this.xhr = request.getXHR());
  var data = this._formData || this._data;

  this._setTimeouts();

  // state change
  xhr.onreadystatechange = function(){
    var readyState = xhr.readyState;
    if (readyState >= 2 && self._responseTimeoutTimer) {
      clearTimeout(self._responseTimeoutTimer);
    }
    if (4 != readyState) {
      return;
    }

    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"
    var status;
    try { status = xhr.status } catch(e) { status = 0; }

    if (!status) {
      if (self.timedout || self._aborted) return;
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  var handleProgress = function(direction, e) {
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }
    e.direction = direction;
    self.emit('progress', e);
  };
  if (this.hasListeners('progress')) {
    try {
      xhr.onprogress = handleProgress.bind(null, 'download');
      if (xhr.upload) {
        xhr.upload.onprogress = handleProgress.bind(null, 'upload');
      }
    } catch(e) {
      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
      // Reported here:
      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
    }
  }

  // initiate request
  try {
    if (this.username && this.password) {
      xhr.open(this.method, this.url, true, this.username, this.password);
    } else {
      xhr.open(this.method, this.url, true);
    }
  } catch (err) {
    // see #1149
    return this.callback(err);
  }

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if (!this._formData && 'GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {
    // serialize stuff
    var contentType = this._header['content-type'];
    var serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];
    if (!serialize && isJSON(contentType)) {
      serialize = request.serialize['application/json'];
    }
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (var field in this.header) {
    if (null == this.header[field]) continue;

    if (this.header.hasOwnProperty(field))
      xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  }

  // send stuff
  this.emit('request', this);

  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined
  xhr.send(typeof data !== 'undefined' ? data : null);
  return this;
};

request.agent = function() {
  return new Agent();
};

["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"].forEach(function(method) {
  Agent.prototype[method.toLowerCase()] = function(url, fn) {
    var req = new request.Request(method, url);
    this._setDefaults(req);
    if (fn) {
      req.end(fn);
    }
    return req;
  };
});

Agent.prototype.del = Agent.prototype['delete'];

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = function(url, data, fn) {
  var req = request('GET', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.head = function(url, data, fn) {
  var req = request('HEAD', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.options = function(url, data, fn) {
  var req = request('OPTIONS', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

function del(url, data, fn) {
  var req = request('DELETE', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
}

request['del'] = del;
request['delete'] = del;

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = function(url, data, fn) {
  var req = request('PATCH', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.post = function(url, data, fn) {
  var req = request('POST', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.put = function(url, data, fn) {
  var req = request('PUT', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

},{"./agent-base":174,"./is-object":176,"./request-base":177,"./response-base":178,"component-emitter":11}],176:[function(require,module,exports){
'use strict';

/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return null !== obj && 'object' === typeof obj;
}

module.exports = isObject;

},{}],177:[function(require,module,exports){
'use strict';

/**
 * Module of mixed-in functions shared between node and client code
 */
var isObject = require('./is-object');

/**
 * Expose `RequestBase`.
 */

module.exports = RequestBase;

/**
 * Initialize a new `RequestBase`.
 *
 * @api public
 */

function RequestBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in RequestBase.prototype) {
    obj[key] = RequestBase.prototype[key];
  }
  return obj;
}

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.clearTimeout = function _clearTimeout(){
  clearTimeout(this._timer);
  clearTimeout(this._responseTimeoutTimer);
  delete this._timer;
  delete this._responseTimeoutTimer;
  return this;
};

/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.parse = function parse(fn){
  this._parser = fn;
  return this;
};

/**
 * Set format of binary response body.
 * In browser valid formats are 'blob' and 'arraybuffer',
 * which return Blob and ArrayBuffer, respectively.
 *
 * In Node all values result in Buffer.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.responseType = function(val){
  this._responseType = val;
  return this;
};

/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.serialize = function serialize(fn){
  this._serializer = fn;
  return this;
};

/**
 * Set timeouts.
 *
 * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.
 * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.
 *
 * Value of 0 or false means no timeout.
 *
 * @param {Number|Object} ms or {response, deadline}
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.timeout = function timeout(options){
  if (!options || 'object' !== typeof options) {
    this._timeout = options;
    this._responseTimeout = 0;
    return this;
  }

  for(var option in options) {
    switch(option) {
      case 'deadline':
        this._timeout = options.deadline;
        break;
      case 'response':
        this._responseTimeout = options.response;
        break;
      default:
        console.warn("Unknown timeout option", option);
    }
  }
  return this;
};

/**
 * Set number of retry attempts on error.
 *
 * Failed requests will be retried 'count' times if timeout or err.code >= 500.
 *
 * @param {Number} count
 * @param {Function} [fn]
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.retry = function retry(count, fn){
  // Default to 1 if no count passed or true
  if (arguments.length === 0 || count === true) count = 1;
  if (count <= 0) count = 0;
  this._maxRetries = count;
  this._retries = 0;
  this._retryCallback = fn;
  return this;
};

var ERROR_CODES = [
  'ECONNRESET',
  'ETIMEDOUT',
  'EADDRINFO',
  'ESOCKETTIMEDOUT'
];

/**
 * Determine if a request should be retried.
 * (Borrowed from segmentio/superagent-retry)
 *
 * @param {Error} err
 * @param {Response} [res]
 * @returns {Boolean}
 */
RequestBase.prototype._shouldRetry = function(err, res) {
  if (!this._maxRetries || this._retries++ >= this._maxRetries) {
    return false;
  }
  if (this._retryCallback) {
    try {
      var override = this._retryCallback(err, res);
      if (override === true) return true;
      if (override === false) return false;
      // undefined falls back to defaults
    } catch(e) {
      console.error(e);
    }
  }
  if (res && res.status && res.status >= 500 && res.status != 501) return true;
  if (err) {
    if (err.code && ~ERROR_CODES.indexOf(err.code)) return true;
    // Superagent timeout
    if (err.timeout && err.code == 'ECONNABORTED') return true;
    if (err.crossDomain) return true;
  }
  return false;
};

/**
 * Retry request
 *
 * @return {Request} for chaining
 * @api private
 */

RequestBase.prototype._retry = function() {

  this.clearTimeout();

  // node
  if (this.req) {
    this.req = null;
    this.req = this.request();
  }

  this._aborted = false;
  this.timedout = false;

  return this._end();
};

/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} [reject]
 * @return {Request}
 */

RequestBase.prototype.then = function then(resolve, reject) {
  if (!this._fullfilledPromise) {
    var self = this;
    if (this._endCalled) {
      console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises");
    }
    this._fullfilledPromise = new Promise(function(innerResolve, innerReject) {
      self.end(function(err, res) {
        if (err) innerReject(err);
        else innerResolve(res);
      });
    });
  }
  return this._fullfilledPromise.then(resolve, reject);
};

RequestBase.prototype.catch = function(cb) {
  return this.then(undefined, cb);
};

/**
 * Allow for extension
 */

RequestBase.prototype.use = function use(fn) {
  fn(this);
  return this;
};

RequestBase.prototype.ok = function(cb) {
  if ('function' !== typeof cb) throw Error("Callback required");
  this._okCallback = cb;
  return this;
};

RequestBase.prototype._isResponseOK = function(res) {
  if (!res) {
    return false;
  }

  if (this._okCallback) {
    return this._okCallback(res);
  }

  return res.status >= 200 && res.status < 300;
};

/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

RequestBase.prototype.get = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */

RequestBase.prototype.getHeader = RequestBase.prototype.get;

/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.set = function(field, val){
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 */
RequestBase.prototype.unset = function(field){
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Write the field `name` and `val`, or multiple fields with one object
 * for "multipart/form-data" request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 *
 * request.post('/upload')
 *   .field({ foo: 'bar', baz: 'qux' })
 *   .end(callback);
 * ```
 *
 * @param {String|Object} name
 * @param {String|Blob|File|Buffer|fs.ReadStream} val
 * @return {Request} for chaining
 * @api public
 */
RequestBase.prototype.field = function(name, val) {
  // name should be either a string or an object.
  if (null === name || undefined === name) {
    throw new Error('.field(name, val) name can not be empty');
  }

  if (this._data) {
    console.error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObject(name)) {
    for (var key in name) {
      this.field(key, name[key]);
    }
    return this;
  }

  if (Array.isArray(val)) {
    for (var i in val) {
      this.field(name, val[i]);
    }
    return this;
  }

  // val should be defined now
  if (null === val || undefined === val) {
    throw new Error('.field(name, val) val can not be empty');
  }
  if ('boolean' === typeof val) {
    val = '' + val;
  }
  this._getFormData().append(name, val);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */
RequestBase.prototype.abort = function(){
  if (this._aborted) {
    return this;
  }
  this._aborted = true;
  this.xhr && this.xhr.abort(); // browser
  this.req && this.req.abort(); // node
  this.clearTimeout();
  this.emit('abort');
  return this;
};

RequestBase.prototype._auth = function(user, pass, options, base64Encoder) {
  switch (options.type) {
    case 'basic':
      this.set('Authorization', 'Basic ' + base64Encoder(user + ':' + pass));
      break;

    case 'auto':
      this.username = user;
      this.password = pass;
      break;

    case 'bearer': // usage would be .auth(accessToken, { type: 'bearer' })
      this.set('Authorization', 'Bearer ' + user);
      break;
  }
  return this;
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

RequestBase.prototype.withCredentials = function(on) {
  // This is browser-only functionality. Node side is no-op.
  if (on == undefined) on = true;
  this._withCredentials = on;
  return this;
};

/**
 * Set the max redirects to `n`. Does noting in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.redirects = function(n){
  this._maxRedirects = n;
  return this;
};

/**
 * Maximum size of buffered response body, in bytes. Counts uncompressed size.
 * Default 200MB.
 *
 * @param {Number} n
 * @return {Request} for chaining
 */
RequestBase.prototype.maxResponseSize = function(n){
  if ('number' !== typeof n) {
    throw TypeError("Invalid argument");
  }
  this._maxResponseSize = n;
  return this;
};

/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */

RequestBase.prototype.toJSON = function() {
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header,
  };
};

/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.send = function(data){
  var isObj = isObject(data);
  var type = this._header['content-type'];

  if (this._formData) {
    console.error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObj && !this._data) {
    if (Array.isArray(data)) {
      this._data = [];
    } else if (!this._isHost(data)) {
      this._data = {};
    }
  } else if (data && this._data && this._isHost(this._data)) {
    throw Error("Can't merge these send calls");
  }

  // merge
  if (isObj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? this._data + '&' + data
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!isObj || this._isHost(data)) {
    return this;
  }

  // default to json
  if (!type) this.type('json');
  return this;
};

/**
 * Sort `querystring` by the sort function
 *
 *
 * Examples:
 *
 *       // default order
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery()
 *         .end(callback)
 *
 *       // customized sort function
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery(function(a, b){
 *           return a.length - b.length;
 *         })
 *         .end(callback)
 *
 *
 * @param {Function} sort
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.sortQuery = function(sort) {
  // _sort default to true but otherwise can be a function or boolean
  this._sort = typeof sort === 'undefined' ? true : sort;
  return this;
};

/**
 * Compose querystring to append to req.url
 *
 * @api private
 */
RequestBase.prototype._finalizeQueryString = function(){
  var query = this._query.join('&');
  if (query) {
    this.url += (this.url.indexOf('?') >= 0 ? '&' : '?') + query;
  }
  this._query.length = 0; // Makes the call idempotent

  if (this._sort) {
    var index = this.url.indexOf('?');
    if (index >= 0) {
      var queryArr = this.url.substring(index + 1).split('&');
      if ('function' === typeof this._sort) {
        queryArr.sort(this._sort);
      } else {
        queryArr.sort();
      }
      this.url = this.url.substring(0, index) + '?' + queryArr.join('&');
    }
  }
};

// For backwards compat only
RequestBase.prototype._appendQueryString = function() {console.trace("Unsupported");}

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

RequestBase.prototype._timeoutError = function(reason, timeout, errno){
  if (this._aborted) {
    return;
  }
  var err = new Error(reason + timeout + 'ms exceeded');
  err.timeout = timeout;
  err.code = 'ECONNABORTED';
  err.errno = errno;
  this.timedout = true;
  this.abort();
  this.callback(err);
};

RequestBase.prototype._setTimeouts = function() {
  var self = this;

  // deadline
  if (this._timeout && !this._timer) {
    this._timer = setTimeout(function(){
      self._timeoutError('Timeout of ', self._timeout, 'ETIME');
    }, this._timeout);
  }
  // response timeout
  if (this._responseTimeout && !this._responseTimeoutTimer) {
    this._responseTimeoutTimer = setTimeout(function(){
      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');
    }, this._responseTimeout);
  }
};

},{"./is-object":176}],178:[function(require,module,exports){
'use strict';

/**
 * Module dependencies.
 */

var utils = require('./utils');

/**
 * Expose `ResponseBase`.
 */

module.exports = ResponseBase;

/**
 * Initialize a new `ResponseBase`.
 *
 * @api public
 */

function ResponseBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in ResponseBase.prototype) {
    obj[key] = ResponseBase.prototype[key];
  }
  return obj;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

ResponseBase.prototype.get = function(field) {
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

ResponseBase.prototype._setHeaderProperties = function(header){
    // TODO: moar!
    // TODO: make this a util

    // content-type
    var ct = header['content-type'] || '';
    this.type = utils.type(ct);

    // params
    var params = utils.params(ct);
    for (var key in params) this[key] = params[key];

    this.links = {};

    // links
    try {
        if (header.link) {
            this.links = utils.parseLinks(header.link);
        }
    } catch (err) {
        // ignore
    }
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

ResponseBase.prototype._setStatusProperties = function(status){
    var type = status / 100 | 0;

    // status / class
    this.status = this.statusCode = status;
    this.statusType = type;

    // basics
    this.info = 1 == type;
    this.ok = 2 == type;
    this.redirect = 3 == type;
    this.clientError = 4 == type;
    this.serverError = 5 == type;
    this.error = (4 == type || 5 == type)
        ? this.toError()
        : false;

    // sugar
    this.accepted = 202 == status;
    this.noContent = 204 == status;
    this.badRequest = 400 == status;
    this.unauthorized = 401 == status;
    this.notAcceptable = 406 == status;
    this.forbidden = 403 == status;
    this.notFound = 404 == status;
};

},{"./utils":179}],179:[function(require,module,exports){
'use strict';

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

exports.type = function(str){
  return str.split(/ *; */).shift();
};

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.params = function(str){
  return str.split(/ *; */).reduce(function(obj, str){
    var parts = str.split(/ *= */);
    var key = parts.shift();
    var val = parts.shift();

    if (key && val) obj[key] = val;
    return obj;
  }, {});
};

/**
 * Parse Link header fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.parseLinks = function(str){
  return str.split(/ *, */).reduce(function(obj, str){
    var parts = str.split(/ *; */);
    var url = parts[0].slice(1, -1);
    var rel = parts[1].split(/ *= */)[1].slice(1, -1);
    obj[rel] = url;
    return obj;
  }, {});
};

/**
 * Strip content related fields from `header`.
 *
 * @param {Object} header
 * @return {Object} header
 * @api private
 */

exports.cleanHeader = function(header, changesOrigin){
  delete header['content-type'];
  delete header['content-length'];
  delete header['transfer-encoding'];
  delete header['host'];
  // secuirty
  if (changesOrigin) {
    delete header['authorization'];
    delete header['cookie'];
  }
  return header;
};

},{}],180:[function(require,module,exports){
(function (global){
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global global, define, System, Reflect, Promise */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
var __makeTemplateObject;
var __importStar;
var __importDefault;
(function (factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function (exports) { factory(createExporter(root, createExporter(exports))); });
    }
    else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
    }
    else {
        factory(createExporter(root));
    }
    function createExporter(exports, previous) {
        if (exports !== root) {
            if (typeof Object.create === "function") {
                Object.defineProperty(exports, "__esModule", { value: true });
            }
            else {
                exports.__esModule = true;
            }
        }
        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
    }
})
(function (exporter) {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

    __extends = function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    __rest = function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    };

    __decorate = function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    __param = function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };

    __metadata = function (metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    };

    __awaiter = function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };

    __generator = function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };

    __exportStar = function (m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    };

    __values = function (o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    };

    __read = function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    };

    __await = function (v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    };

    __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    };

    __asyncDelegator = function (o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    };

    __asyncValues = function (o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    };

    __makeTemplateObject = function (cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    __importStar = function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result["default"] = mod;
        return result;
    };

    __importDefault = function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };

    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],181:[function(require,module,exports){
"use strict";
var util = require('./util');
var arrays = require('./arrays');
var LinkedList = (function () {
    /**
    * Creates an empty Linked List.
    * @class A linked list is a data structure consisting of a group of nodes
    * which together represent a sequence.
    * @constructor
    */
    function LinkedList() {
        /**
        * First node in the list
        * @type {Object}
        * @private
        */
        this.firstNode = null;
        /**
        * Last node in the list
        * @type {Object}
        * @private
        */
        this.lastNode = null;
        /**
        * Number of elements in the list
        * @type {number}
        * @private
        */
        this.nElements = 0;
    }
    /**
    * Adds an element to this list.
    * @param {Object} item element to be added.
    * @param {number=} index optional index to add the element. If no index is specified
    * the element is added to the end of this list.
    * @return {boolean} true if the element was added or false if the index is invalid
    * or if the element is undefined.
    */
    LinkedList.prototype.add = function (item, index) {
        if (util.isUndefined(index)) {
            index = this.nElements;
        }
        if (index < 0 || index > this.nElements || util.isUndefined(item)) {
            return false;
        }
        var newNode = this.createNode(item);
        if (this.nElements === 0) {
            // First node in the list.
            this.firstNode = newNode;
            this.lastNode = newNode;
        }
        else if (index === this.nElements) {
            // Insert at the end.
            this.lastNode.next = newNode;
            this.lastNode = newNode;
        }
        else if (index === 0) {
            // Change first node.
            newNode.next = this.firstNode;
            this.firstNode = newNode;
        }
        else {
            var prev = this.nodeAtIndex(index - 1);
            newNode.next = prev.next;
            prev.next = newNode;
        }
        this.nElements++;
        return true;
    };
    /**
    * Returns the first element in this list.
    * @return {*} the first element of the list or undefined if the list is
    * empty.
    */
    LinkedList.prototype.first = function () {
        if (this.firstNode !== null) {
            return this.firstNode.element;
        }
        return undefined;
    };
    /**
    * Returns the last element in this list.
    * @return {*} the last element in the list or undefined if the list is
    * empty.
    */
    LinkedList.prototype.last = function () {
        if (this.lastNode !== null) {
            return this.lastNode.element;
        }
        return undefined;
    };
    /**
     * Returns the element at the specified position in this list.
     * @param {number} index desired index.
     * @return {*} the element at the given index or undefined if the index is
     * out of bounds.
     */
    LinkedList.prototype.elementAtIndex = function (index) {
        var node = this.nodeAtIndex(index);
        if (node === null) {
            return undefined;
        }
        return node.element;
    };
    /**
     * Returns the index in this list of the first occurrence of the
     * specified element, or -1 if the List does not contain this element.
     * <p>If the elements inside this list are
     * not comparable with the === operator a custom equals function should be
     * provided to perform searches, the function must receive two arguments and
     * return true if they are equal, false otherwise. Example:</p>
     *
     * <pre>
     * const petsAreEqualByName = function(pet1, pet2) {
     *  return pet1.name === pet2.name;
     * }
     * </pre>
     * @param {Object} item element to search for.
     * @param {function(Object,Object):boolean=} equalsFunction Optional
     * function used to check if two elements are equal.
     * @return {number} the index in this list of the first occurrence
     * of the specified element, or -1 if this list does not contain the
     * element.
     */
    LinkedList.prototype.indexOf = function (item, equalsFunction) {
        var equalsF = equalsFunction || util.defaultEquals;
        if (util.isUndefined(item)) {
            return -1;
        }
        var currentNode = this.firstNode;
        var index = 0;
        while (currentNode !== null) {
            if (equalsF(currentNode.element, item)) {
                return index;
            }
            index++;
            currentNode = currentNode.next;
        }
        return -1;
    };
    /**
       * Returns true if this list contains the specified element.
       * <p>If the elements inside the list are
       * not comparable with the === operator a custom equals function should be
       * provided to perform searches, the function must receive two arguments and
       * return true if they are equal, false otherwise. Example:</p>
       *
       * <pre>
       * const petsAreEqualByName = function(pet1, pet2) {
       *  return pet1.name === pet2.name;
       * }
       * </pre>
       * @param {Object} item element to search for.
       * @param {function(Object,Object):boolean=} equalsFunction Optional
       * function used to check if two elements are equal.
       * @return {boolean} true if this list contains the specified element, false
       * otherwise.
       */
    LinkedList.prototype.contains = function (item, equalsFunction) {
        return (this.indexOf(item, equalsFunction) >= 0);
    };
    /**
     * Removes the first occurrence of the specified element in this list.
     * <p>If the elements inside the list are
     * not comparable with the === operator a custom equals function should be
     * provided to perform searches, the function must receive two arguments and
     * return true if they are equal, false otherwise. Example:</p>
     *
     * <pre>
     * const petsAreEqualByName = function(pet1, pet2) {
     *  return pet1.name === pet2.name;
     * }
     * </pre>
     * @param {Object} item element to be removed from this list, if present.
     * @return {boolean} true if the list contained the specified element.
     */
    LinkedList.prototype.remove = function (item, equalsFunction) {
        var equalsF = equalsFunction || util.defaultEquals;
        if (this.nElements < 1 || util.isUndefined(item)) {
            return false;
        }
        var previous = null;
        var currentNode = this.firstNode;
        while (currentNode !== null) {
            if (equalsF(currentNode.element, item)) {
                if (currentNode === this.firstNode) {
                    this.firstNode = this.firstNode.next;
                    if (currentNode === this.lastNode) {
                        this.lastNode = null;
                    }
                }
                else if (currentNode === this.lastNode) {
                    this.lastNode = previous;
                    previous.next = currentNode.next;
                    currentNode.next = null;
                }
                else {
                    previous.next = currentNode.next;
                    currentNode.next = null;
                }
                this.nElements--;
                return true;
            }
            previous = currentNode;
            currentNode = currentNode.next;
        }
        return false;
    };
    /**
     * Removes all of the elements from this list.
     */
    LinkedList.prototype.clear = function () {
        this.firstNode = null;
        this.lastNode = null;
        this.nElements = 0;
    };
    /**
     * Returns true if this list is equal to the given list.
     * Two lists are equal if they have the same elements in the same order.
     * @param {LinkedList} other the other list.
     * @param {function(Object,Object):boolean=} equalsFunction optional
     * function used to check if two elements are equal. If the elements in the lists
     * are custom objects you should provide a function, otherwise
     * the === operator is used to check equality between elements.
     * @return {boolean} true if this list is equal to the given list.
     */
    LinkedList.prototype.equals = function (other, equalsFunction) {
        var eqF = equalsFunction || util.defaultEquals;
        if (!(other instanceof LinkedList)) {
            return false;
        }
        if (this.size() !== other.size()) {
            return false;
        }
        return this.equalsAux(this.firstNode, other.firstNode, eqF);
    };
    /**
    * @private
    */
    LinkedList.prototype.equalsAux = function (n1, n2, eqF) {
        while (n1 !== null) {
            if (!eqF(n1.element, n2.element)) {
                return false;
            }
            n1 = n1.next;
            n2 = n2.next;
        }
        return true;
    };
    /**
     * Removes the element at the specified position in this list.
     * @param {number} index given index.
     * @return {*} removed element or undefined if the index is out of bounds.
     */
    LinkedList.prototype.removeElementAtIndex = function (index) {
        if (index < 0 || index >= this.nElements) {
            return undefined;
        }
        var element;
        if (this.nElements === 1) {
            //First node in the list.
            element = this.firstNode.element;
            this.firstNode = null;
            this.lastNode = null;
        }
        else {
            var previous = this.nodeAtIndex(index - 1);
            if (previous === null) {
                element = this.firstNode.element;
                this.firstNode = this.firstNode.next;
            }
            else if (previous.next === this.lastNode) {
                element = this.lastNode.element;
                this.lastNode = previous;
            }
            if (previous !== null) {
                element = previous.next.element;
                previous.next = previous.next.next;
            }
        }
        this.nElements--;
        return element;
    };
    /**
     * Executes the provided function once for each element present in this list in order.
     * @param {function(Object):*} callback function to execute, it is
     * invoked with one argument: the element value, to break the iteration you can
     * optionally return false.
     */
    LinkedList.prototype.forEach = function (callback) {
        var currentNode = this.firstNode;
        while (currentNode !== null) {
            if (callback(currentNode.element) === false) {
                break;
            }
            currentNode = currentNode.next;
        }
    };
    /**
     * Reverses the order of the elements in this linked list (makes the last
     * element first, and the first element last).
     */
    LinkedList.prototype.reverse = function () {
        var previous = null;
        var current = this.firstNode;
        var temp = null;
        while (current !== null) {
            temp = current.next;
            current.next = previous;
            previous = current;
            current = temp;
        }
        temp = this.firstNode;
        this.firstNode = this.lastNode;
        this.lastNode = temp;
    };
    /**
     * Returns an array containing all of the elements in this list in proper
     * sequence.
     * @return {Array.<*>} an array containing all of the elements in this list,
     * in proper sequence.
     */
    LinkedList.prototype.toArray = function () {
        var array = [];
        var currentNode = this.firstNode;
        while (currentNode !== null) {
            array.push(currentNode.element);
            currentNode = currentNode.next;
        }
        return array;
    };
    /**
     * Returns the number of elements in this list.
     * @return {number} the number of elements in this list.
     */
    LinkedList.prototype.size = function () {
        return this.nElements;
    };
    /**
     * Returns true if this list contains no elements.
     * @return {boolean} true if this list contains no elements.
     */
    LinkedList.prototype.isEmpty = function () {
        return this.nElements <= 0;
    };
    LinkedList.prototype.toString = function () {
        return arrays.toString(this.toArray());
    };
    /**
     * @private
     */
    LinkedList.prototype.nodeAtIndex = function (index) {
        if (index < 0 || index >= this.nElements) {
            return null;
        }
        if (index === (this.nElements - 1)) {
            return this.lastNode;
        }
        var node = this.firstNode;
        for (var i = 0; i < index; i++) {
            node = node.next;
        }
        return node;
    };
    /**
     * @private
     */
    LinkedList.prototype.createNode = function (item) {
        return {
            element: item,
            next: null
        };
    };
    return LinkedList;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = LinkedList; // End of linked list

},{"./arrays":183,"./util":184}],182:[function(require,module,exports){
"use strict";
var LinkedList_1 = require('./LinkedList');
var Queue = (function () {
    /**
     * Creates an empty queue.
     * @class A queue is a First-In-First-Out (FIFO) data structure, the first
     * element added to the queue will be the first one to be removed. This
     * implementation uses a linked list as a container.
     * @constructor
     */
    function Queue() {
        this.list = new LinkedList_1.default();
    }
    /**
     * Inserts the specified element into the end of this queue.
     * @param {Object} elem the element to insert.
     * @return {boolean} true if the element was inserted, or false if it is undefined.
     */
    Queue.prototype.enqueue = function (elem) {
        return this.list.add(elem);
    };
    /**
     * Inserts the specified element into the end of this queue.
     * @param {Object} elem the element to insert.
     * @return {boolean} true if the element was inserted, or false if it is undefined.
     */
    Queue.prototype.add = function (elem) {
        return this.list.add(elem);
    };
    /**
     * Retrieves and removes the head of this queue.
     * @return {*} the head of this queue, or undefined if this queue is empty.
     */
    Queue.prototype.dequeue = function () {
        if (this.list.size() !== 0) {
            var el = this.list.first();
            this.list.removeElementAtIndex(0);
            return el;
        }
        return undefined;
    };
    /**
     * Retrieves, but does not remove, the head of this queue.
     * @return {*} the head of this queue, or undefined if this queue is empty.
     */
    Queue.prototype.peek = function () {
        if (this.list.size() !== 0) {
            return this.list.first();
        }
        return undefined;
    };
    /**
     * Returns the number of elements in this queue.
     * @return {number} the number of elements in this queue.
     */
    Queue.prototype.size = function () {
        return this.list.size();
    };
    /**
     * Returns true if this queue contains the specified element.
     * <p>If the elements inside this stack are
     * not comparable with the === operator, a custom equals function should be
     * provided to perform searches, the function must receive two arguments and
     * return true if they are equal, false otherwise. Example:</p>
     *
     * <pre>
     * const petsAreEqualByName (pet1, pet2) {
     *  return pet1.name === pet2.name;
     * }
     * </pre>
     * @param {Object} elem element to search for.
     * @param {function(Object,Object):boolean=} equalsFunction optional
     * function to check if two elements are equal.
     * @return {boolean} true if this queue contains the specified element,
     * false otherwise.
     */
    Queue.prototype.contains = function (elem, equalsFunction) {
        return this.list.contains(elem, equalsFunction);
    };
    /**
     * Checks if this queue is empty.
     * @return {boolean} true if and only if this queue contains no items; false
     * otherwise.
     */
    Queue.prototype.isEmpty = function () {
        return this.list.size() <= 0;
    };
    /**
     * Removes all of the elements from this queue.
     */
    Queue.prototype.clear = function () {
        this.list.clear();
    };
    /**
     * Executes the provided function once for each element present in this queue in
     * FIFO order.
     * @param {function(Object):*} callback function to execute, it is
     * invoked with one argument: the element value, to break the iteration you can
     * optionally return false.
     */
    Queue.prototype.forEach = function (callback) {
        this.list.forEach(callback);
    };
    return Queue;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Queue; // End of queue

},{"./LinkedList":181}],183:[function(require,module,exports){
"use strict";
var util = require('./util');
/**
 * Returns the position of the first occurrence of the specified item
 * within the specified array.4
 * @param {*} array the array in which to search the element.
 * @param {Object} item the element to search.
 * @param {function(Object,Object):boolean=} equalsFunction optional function used to
 * check equality between 2 elements.
 * @return {number} the position of the first occurrence of the specified element
 * within the specified array, or -1 if not found.
 */
function indexOf(array, item, equalsFunction) {
    var equals = equalsFunction || util.defaultEquals;
    var length = array.length;
    for (var i = 0; i < length; i++) {
        if (equals(array[i], item)) {
            return i;
        }
    }
    return -1;
}
exports.indexOf = indexOf;
/**
 * Returns the position of the last occurrence of the specified element
 * within the specified array.
 * @param {*} array the array in which to search the element.
 * @param {Object} item the element to search.
 * @param {function(Object,Object):boolean=} equalsFunction optional function used to
 * check equality between 2 elements.
 * @return {number} the position of the last occurrence of the specified element
 * within the specified array or -1 if not found.
 */
function lastIndexOf(array, item, equalsFunction) {
    var equals = equalsFunction || util.defaultEquals;
    var length = array.length;
    for (var i = length - 1; i >= 0; i--) {
        if (equals(array[i], item)) {
            return i;
        }
    }
    return -1;
}
exports.lastIndexOf = lastIndexOf;
/**
 * Returns true if the specified array contains the specified element.
 * @param {*} array the array in which to search the element.
 * @param {Object} item the element to search.
 * @param {function(Object,Object):boolean=} equalsFunction optional function to
 * check equality between 2 elements.
 * @return {boolean} true if the specified array contains the specified element.
 */
function contains(array, item, equalsFunction) {
    return indexOf(array, item, equalsFunction) >= 0;
}
exports.contains = contains;
/**
 * Removes the first ocurrence of the specified element from the specified array.
 * @param {*} array the array in which to search element.
 * @param {Object} item the element to search.
 * @param {function(Object,Object):boolean=} equalsFunction optional function to
 * check equality between 2 elements.
 * @return {boolean} true if the array changed after this call.
 */
function remove(array, item, equalsFunction) {
    var index = indexOf(array, item, equalsFunction);
    if (index < 0) {
        return false;
    }
    array.splice(index, 1);
    return true;
}
exports.remove = remove;
/**
 * Returns the number of elements in the specified array equal
 * to the specified object.
 * @param {Array} array the array in which to determine the frequency of the element.
 * @param {Object} item the element whose frequency is to be determined.
 * @param {function(Object,Object):boolean=} equalsFunction optional function used to
 * check equality between 2 elements.
 * @return {number} the number of elements in the specified array
 * equal to the specified object.
 */
function frequency(array, item, equalsFunction) {
    var equals = equalsFunction || util.defaultEquals;
    var length = array.length;
    var freq = 0;
    for (var i = 0; i < length; i++) {
        if (equals(array[i], item)) {
            freq++;
        }
    }
    return freq;
}
exports.frequency = frequency;
/**
 * Returns true if the two specified arrays are equal to one another.
 * Two arrays are considered equal if both arrays contain the same number
 * of elements, and all corresponding pairs of elements in the two
 * arrays are equal and are in the same order.
 * @param {Array} array1 one array to be tested for equality.
 * @param {Array} array2 the other array to be tested for equality.
 * @param {function(Object,Object):boolean=} equalsFunction optional function used to
 * check equality between elemements in the arrays.
 * @return {boolean} true if the two arrays are equal
 */
function equals(array1, array2, equalsFunction) {
    var equals = equalsFunction || util.defaultEquals;
    if (array1.length !== array2.length) {
        return false;
    }
    var length = array1.length;
    for (var i = 0; i < length; i++) {
        if (!equals(array1[i], array2[i])) {
            return false;
        }
    }
    return true;
}
exports.equals = equals;
/**
 * Returns shallow a copy of the specified array.
 * @param {*} array the array to copy.
 * @return {Array} a copy of the specified array
 */
function copy(array) {
    return array.concat();
}
exports.copy = copy;
/**
 * Swaps the elements at the specified positions in the specified array.
 * @param {Array} array The array in which to swap elements.
 * @param {number} i the index of one element to be swapped.
 * @param {number} j the index of the other element to be swapped.
 * @return {boolean} true if the array is defined and the indexes are valid.
 */
function swap(array, i, j) {
    if (i < 0 || i >= array.length || j < 0 || j >= array.length) {
        return false;
    }
    var temp = array[i];
    array[i] = array[j];
    array[j] = temp;
    return true;
}
exports.swap = swap;
function toString(array) {
    return '[' + array.toString() + ']';
}
exports.toString = toString;
/**
 * Executes the provided function once for each element present in this array
 * starting from index 0 to length - 1.
 * @param {Array} array The array in which to iterate.
 * @param {function(Object):*} callback function to execute, it is
 * invoked with one argument: the element value, to break the iteration you can
 * optionally return false.
 */
function forEach(array, callback) {
    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
        var ele = array_1[_i];
        if (callback(ele) === false) {
            return;
        }
    }
}
exports.forEach = forEach;

},{"./util":184}],184:[function(require,module,exports){
"use strict";
var _hasOwnProperty = Object.prototype.hasOwnProperty;
exports.has = function (obj, prop) {
    return _hasOwnProperty.call(obj, prop);
};
/**
 * Default function to compare element order.
 * @function
 */
function defaultCompare(a, b) {
    if (a < b) {
        return -1;
    }
    else if (a === b) {
        return 0;
    }
    else {
        return 1;
    }
}
exports.defaultCompare = defaultCompare;
/**
 * Default function to test equality.
 * @function
 */
function defaultEquals(a, b) {
    return a === b;
}
exports.defaultEquals = defaultEquals;
/**
 * Default function to convert an object to a string.
 * @function
 */
function defaultToString(item) {
    if (item === null) {
        return 'COLLECTION_NULL';
    }
    else if (isUndefined(item)) {
        return 'COLLECTION_UNDEFINED';
    }
    else if (isString(item)) {
        return '$s' + item;
    }
    else {
        return '$o' + item.toString();
    }
}
exports.defaultToString = defaultToString;
/**
* Joins all the properies of the object using the provided join string
*/
function makeString(item, join) {
    if (join === void 0) { join = ','; }
    if (item === null) {
        return 'COLLECTION_NULL';
    }
    else if (isUndefined(item)) {
        return 'COLLECTION_UNDEFINED';
    }
    else if (isString(item)) {
        return item.toString();
    }
    else {
        var toret = '{';
        var first = true;
        for (var prop in item) {
            if (exports.has(item, prop)) {
                if (first) {
                    first = false;
                }
                else {
                    toret = toret + join;
                }
                toret = toret + prop + ':' + item[prop];
            }
        }
        return toret + '}';
    }
}
exports.makeString = makeString;
/**
 * Checks if the given argument is a function.
 * @function
 */
function isFunction(func) {
    return (typeof func) === 'function';
}
exports.isFunction = isFunction;
/**
 * Checks if the given argument is undefined.
 * @function
 */
function isUndefined(obj) {
    return (typeof obj) === 'undefined';
}
exports.isUndefined = isUndefined;
/**
 * Checks if the given argument is a string.
 * @function
 */
function isString(obj) {
    return Object.prototype.toString.call(obj) === '[object String]';
}
exports.isString = isString;
/**
 * Reverses a compare function.
 * @function
 */
function reverseCompareFunction(compareFunction) {
    if (!isFunction(compareFunction)) {
        return function (a, b) {
            if (a < b) {
                return 1;
            }
            else if (a === b) {
                return 0;
            }
            else {
                return -1;
            }
        };
    }
    else {
        return function (d, v) {
            return compareFunction(d, v) * -1;
        };
    }
}
exports.reverseCompareFunction = reverseCompareFunction;
/**
 * Returns an equal function given a compare function.
 * @function
 */
function compareToEquals(compareFunction) {
    return function (a, b) {
        return compareFunction(a, b) === 0;
    };
}
exports.compareToEquals = compareToEquals;

},{}],185:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var common_1 = require("@plexus-interop/common");
var protocol_1 = require("@plexus-interop/protocol");
var MethodInvocationContext = /** @class */ (function () {
    function MethodInvocationContext(consumerApplicationId, consumerConnectionId, cancellationToken) {
        if (consumerConnectionId === void 0) { consumerConnectionId = protocol_1.UniqueId.generateNew(); }
        if (cancellationToken === void 0) { cancellationToken = new common_1.CancellationToken(); }
        this.consumerApplicationId = consumerApplicationId;
        this.consumerConnectionId = consumerConnectionId;
        this.cancellationToken = cancellationToken;
    }
    return MethodInvocationContext;
}());
exports.MethodInvocationContext = MethodInvocationContext;
},{"@plexus-interop/common":243,"@plexus-interop/protocol":305}],186:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Completion = /** @class */ (function () {
    function Completion() {
    }
    return Completion;
}());
exports.Completion = Completion;
},{}],187:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DiscoveryMode;
(function (DiscoveryMode) {
    DiscoveryMode[DiscoveryMode["Offline"] = 0] = "Offline";
    DiscoveryMode[DiscoveryMode["Online"] = 1] = "Online";
})(DiscoveryMode = exports.DiscoveryMode || (exports.DiscoveryMode = {}));
},{}],188:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var MethodType;
(function (MethodType) {
    MethodType[MethodType["Unary"] = 0] = "Unary";
    MethodType[MethodType["ServerStreaming"] = 1] = "ServerStreaming";
    MethodType[MethodType["ClientStreaming"] = 2] = "ClientStreaming";
    MethodType[MethodType["DuplexStreaming"] = 3] = "DuplexStreaming";
})(MethodType = exports.MethodType || (exports.MethodType = {}));
},{}],189:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./Completion"), exports);
tslib_1.__exportStar(require("./MethodType"), exports);
tslib_1.__exportStar(require("./DiscoveryMode"), exports);
},{"./Completion":186,"./DiscoveryMode":187,"./MethodType":188,"tslib":180}],190:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
tslib_1.__exportStar(require("./dto"), exports);
tslib_1.__exportStar(require("./MethodInvocationContext"), exports);
},{"./MethodInvocationContext":185,"./dto":189,"tslib":180}],191:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var protocol_1 = require("@plexus-interop/protocol");
var common_1 = require("@plexus-interop/common");
var ClientDtoUtils = /** @class */ (function () {
    function ClientDtoUtils() {
    }
    ClientDtoUtils.targetInvocationHash = function (metaInfo) {
        var alias = !!metaInfo.serviceAlias ? metaInfo.serviceAlias : 'default';
        return metaInfo.serviceId + "." + alias + "." + metaInfo.methodId;
    };
    ClientDtoUtils.providedMethodToInvocationInfo = function (providedMethod) {
        if (providedMethod.providedService) {
            return {
                serviceId: providedMethod.providedService.serviceId,
                serviceAlias: providedMethod.providedService.serviceAlias,
                methodId: providedMethod.methodId,
                applicationId: providedMethod.providedService.applicationId,
                connectionId: providedMethod.providedService.connectionId
            };
        }
        else {
            return {
                methodId: providedMethod.methodId
            };
        }
    };
    ClientDtoUtils.toError = function (error) {
        if (common_1.isString(error)) {
            return new protocol_1.ClientError(error);
        }
        var message = error.message && common_1.isString(error.message) ? error.message : 'Unknown';
        var details = error.stack && common_1.isString(error.stack) ? error.stack : (error.details && common_1.isString(error.details) ? error.details : 'Unknown');
        return new protocol_1.ClientError(message, details);
    };
    return ClientDtoUtils;
}());
exports.ClientDtoUtils = ClientDtoUtils;
},{"@plexus-interop/common":243,"@plexus-interop/protocol":305}],192:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var protocol_1 = require("@plexus-interop/protocol");
var BaseInvocationClientImpl = /** @class */ (function () {
    function BaseInvocationClientImpl(invocation, log) {
        this.invocation = invocation;
        this.log = log;
    }
    BaseInvocationClientImpl.prototype.error = function (clientError) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        /* istanbul ignore if */
                        if (this.log.isDebugEnabled()) {
                            this.log.debug("Client reported error, closing invocation", JSON.stringify(clientError));
                        }
                        return [4 /*yield*/, this.close(new protocol_1.ErrorCompletion(clientError))];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    BaseInvocationClientImpl.prototype.cancel = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.log.debug("Client cancelled operation, closing invocation");
                        return [4 /*yield*/, this.close(new protocol_1.CancelledCompletion())];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    BaseInvocationClientImpl.prototype.close = function (completion) {
        if (completion === void 0) { completion = new protocol_1.SuccessCompletion(); }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.invocation.close(completion)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    return BaseInvocationClientImpl;
}());
exports.BaseInvocationClientImpl = BaseInvocationClientImpl;
},{"@plexus-interop/protocol":305,"tslib":180}],193:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var transport_common_1 = require("@plexus-interop/transport-common");
var DelegateInvocationObserver = /** @class */ (function (_super) {
    tslib_1.__extends(DelegateInvocationObserver, _super);
    function DelegateInvocationObserver(base, subscriptionHandler, startFailedHandler) {
        var _this = _super.call(this, base, subscriptionHandler, startFailedHandler) || this;
        _this.base = base;
        return _this;
    }
    DelegateInvocationObserver.prototype.streamCompleted = function () {
        this.base.streamCompleted();
    };
    return DelegateInvocationObserver;
}(transport_common_1.DelegateChannelObserver));
exports.DelegateInvocationObserver = DelegateInvocationObserver;
},{"@plexus-interop/transport-common":315,"tslib":180}],194:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var LoggingInvocationObserver = /** @class */ (function () {
    function LoggingInvocationObserver(baseObserver, log) {
        this.baseObserver = baseObserver;
        this.log = log;
    }
    LoggingInvocationObserver.prototype.streamCompleted = function () {
        this.log.trace('Stream completed');
        this.baseObserver.streamCompleted();
    };
    LoggingInvocationObserver.prototype.next = function (payload) {
        this.log.trace("Response payload of " + payload.byteLength + " received");
        this.baseObserver.next(payload);
    };
    LoggingInvocationObserver.prototype.error = function (e) {
        this.log.error("Error received", e);
        this.baseObserver.error(e);
    };
    LoggingInvocationObserver.prototype.complete = function () {
        this.log.trace("Completion received");
        this.baseObserver.complete();
    };
    return LoggingInvocationObserver;
}());
exports.LoggingInvocationObserver = LoggingInvocationObserver;
},{}],195:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var generic_1 = require("../generic");
var DefaultConnectionDetailsService_1 = require("./DefaultConnectionDetailsService");
var transport_common_1 = require("@plexus-interop/transport-common");
var websocket_transport_1 = require("@plexus-interop/websocket-transport");
var ContainerAwareClientAPIBuilder = /** @class */ (function (_super) {
    tslib_1.__extends(ContainerAwareClientAPIBuilder, _super);
    function ContainerAwareClientAPIBuilder(connectionDetailsService) {
        if (connectionDetailsService === void 0) { connectionDetailsService = new DefaultConnectionDetailsService_1.DefaultConnectionDetailsService(); }
        var _this = _super.call(this) || this;
        _this.connectionDetailsService = connectionDetailsService;
        return _this;
    }
    ContainerAwareClientAPIBuilder.prototype.connect = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var details_1, e_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(!this.applicationInstanceId || !this.transportConnectionProvider)) return [3 /*break*/, 4];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.connectionDetailsService.getConnectionDetails()];
                    case 2:
                        details_1 = _a.sent();
                        if (!this.applicationInstanceId && details_1.appInstanceId) {
                            this.log.info('Using App instance ID from container');
                            this.applicationInstanceId = transport_common_1.UniqueId.fromString(details_1.appInstanceId);
                        }
                        if (!this.transportConnectionProvider && (details_1.ws && details_1.ws.port)) {
                            this.log.info('Transport connection provider from container');
                            this.transportConnectionProvider = function () { return new websocket_transport_1.WebSocketConnectionFactory(new WebSocket("ws://127.0.0.1:" + details_1.ws.port)).connect(); };
                        }
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _a.sent();
                        this.log.info('Failed to discover container connection details', e_1);
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/, _super.prototype.connect.call(this)];
                }
            });
        });
    };
    return ContainerAwareClientAPIBuilder;
}(generic_1.GenericClientApiBuilder));
exports.ContainerAwareClientAPIBuilder = ContainerAwareClientAPIBuilder;
},{"../generic":212,"./DefaultConnectionDetailsService":196,"@plexus-interop/transport-common":315,"@plexus-interop/websocket-transport":336,"tslib":180}],196:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = require("@plexus-interop/common");
var DefaultConnectionDetailsService = /** @class */ (function () {
    function DefaultConnectionDetailsService() {
        this.log = common_1.LoggerFactory.getLogger('DefaultConnectionDetailsService');
    }
    DefaultConnectionDetailsService.prototype.getConnectionDetails = function () {
        var globalObj = self;
        if (globalObj.plexus && globalObj.plexus.getConnectionDetails) {
            this.log.info('Detected connection details service, provided by container');
            return globalObj.plexus.getConnectionDetails();
        }
        else {
            return Promise.reject('Container is not providing \'self.plexus.getConnectionDetails(): Promise<ConnectionDetails>\' API');
        }
    };
    DefaultConnectionDetailsService.prototype.getMetadataUrl = function () {
        var _this = this;
        return this.getConnectionDetails()
            .then(function (details) { return _this.getDefaultUrl("ws://127.0.0.1:" + details.ws.port); });
    };
    DefaultConnectionDetailsService.prototype.getDefaultUrl = function (baseUrl) {
        return baseUrl + "/metadata/interop";
    };
    return DefaultConnectionDetailsService;
}());
exports.DefaultConnectionDetailsService = DefaultConnectionDetailsService;
},{"@plexus-interop/common":243}],197:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
tslib_1.__exportStar(require("./ContainerAwareClientAPIBuilder"), exports);
tslib_1.__exportStar(require("./DefaultConnectionDetailsService"), exports);
},{"./ContainerAwareClientAPIBuilder":195,"./DefaultConnectionDetailsService":196,"tslib":180}],198:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Feature;
(function (Feature) {
    Feature["SEND_UNARY"] = "SEND_UNARY";
    Feature["SEND_RAW_UNARY"] = "SEND_RAW_UNARY";
    Feature["SEND_BIDI_STREAM"] = "SEND_BIDI_STREAM";
    Feature["SEND_RAW_BIDI_STREAM"] = "SEND_RAW_BIDI_STREAM";
    Feature["SEND_SERVER_STREAM"] = "SEND_SERVER_STREAM";
    Feature["SEND_RAW_SERVER_STREAM"] = "SEND_RAW_SERVER_STREAM";
    Feature["DISCOVER_SERVICE"] = "DISCOVER_SERVICE";
    Feature["DISCOVER_METHOD"] = "DISCOVER_METHOD";
})(Feature = exports.Feature || (exports.Feature = {}));
},{}],199:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Base class for all generated clients
 *
 */
var GenericClientApiBase = /** @class */ (function () {
    function GenericClientApiBase(client) {
        this.client = client;
    }
    GenericClientApiBase.prototype.supported = function (apiFeature) {
        return this.client.supported(apiFeature);
    };
    GenericClientApiBase.prototype.getConnectionId = function () {
        return this.client.getConnectionId();
    };
    GenericClientApiBase.prototype.sendUnaryRequest = function (invocationInfo, request, responseHandler, requestType, responseType) {
        return this.client.sendUnaryRequest(invocationInfo, request, responseHandler, requestType, responseType);
    };
    GenericClientApiBase.prototype.sendRawUnaryRequest = function (invocationInfo, request, responseHandler) {
        return this.client.sendRawUnaryRequest(invocationInfo, request, responseHandler);
    };
    GenericClientApiBase.prototype.sendBidirectionalStreamingRequest = function (invocationInfo, responseObserver, requestType, responseType) {
        return this.client.sendBidirectionalStreamingRequest(invocationInfo, responseObserver, requestType, responseType);
    };
    GenericClientApiBase.prototype.sendRawBidirectionalStreamingRequest = function (invocationInfo, responseObserver) {
        return this.client.sendRawBidirectionalStreamingRequest(invocationInfo, responseObserver);
    };
    GenericClientApiBase.prototype.sendServerStreamingRequest = function (invocationInfo, request, responseObserver, requestType, responseType) {
        return this.client.sendServerStreamingRequest(invocationInfo, request, responseObserver, requestType, responseType);
    };
    GenericClientApiBase.prototype.sendRawServerStreamingRequest = function (invocationInfo, request, responseObserver) {
        return this.client.sendRawServerStreamingRequest(invocationInfo, request, responseObserver);
    };
    GenericClientApiBase.prototype.discoverService = function (discoveryRequest) {
        return this.client.discoverService(discoveryRequest);
    };
    GenericClientApiBase.prototype.discoverMethod = function (discoveryRequest) {
        return this.client.discoverMethod(discoveryRequest);
    };
    GenericClientApiBase.prototype.disconnect = function (completion) {
        return this.client.disconnect(completion);
    };
    return GenericClientApiBase;
}());
exports.GenericClientApiBase = GenericClientApiBase;
},{}],200:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var transport_common_1 = require("@plexus-interop/transport-common");
var GenericClientFactory_1 = require("../../generic/GenericClientFactory");
var GenericClientApiImpl_1 = require("./GenericClientApiImpl");
var GenericInvocationsHost_1 = require("./GenericInvocationsHost");
var common_1 = require("@plexus-interop/common");
var InvocationHandlersRegistry_1 = require("./handlers/InvocationHandlersRegistry");
var static_1 = require("@plexus-interop/io/dist/main/src/static");
// tslint:disable:member-ordering
var GenericClientApiBuilder = /** @class */ (function () {
    function GenericClientApiBuilder(marshallerProvider) {
        if (marshallerProvider === void 0) { marshallerProvider = new static_1.ProtoMarshallerProvider(); }
        var _this = this;
        this.marshallerProvider = marshallerProvider;
        this.log = common_1.LoggerFactory.getLogger('GenericClientApiBuilder');
        this.clientApiDecorator = function (client) { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
            return [2 /*return*/, client];
        }); }); };
        this.handlersRegistry = new InvocationHandlersRegistry_1.InvocationHandlersRegistry(this.marshallerProvider);
    }
    GenericClientApiBuilder.prototype.withClientApiDecorator = function (clientApiDecorator) {
        this.clientApiDecorator = clientApiDecorator;
        return this;
    };
    GenericClientApiBuilder.prototype.withApplicationId = function (appId) {
        this.applicationId = appId;
        return this;
    };
    GenericClientApiBuilder.prototype.withAppInstanceId = function (instanceId) {
        this.applicationInstanceId = instanceId;
        return this;
    };
    GenericClientApiBuilder.prototype.withClientDetails = function (clientId) {
        this.applicationId = clientId.applicationId;
        this.applicationInstanceId = clientId.applicationInstanceId;
        return this;
    };
    GenericClientApiBuilder.prototype.withBidiStreamingHandler = function (handler) {
        this.handlersRegistry.registerBidiStreamingGenericHandler(handler);
        return this;
    };
    GenericClientApiBuilder.prototype.withTypeAwareBidiStreamingHandler = function (handler, requestType, responseType) {
        this.handlersRegistry.registerBidiStreamingHandler(handler, requestType, responseType);
        return this;
    };
    GenericClientApiBuilder.prototype.withServerStreamingHandler = function (handler) {
        this.handlersRegistry.registerServerStreamingGenericHandler(handler);
        return this;
    };
    GenericClientApiBuilder.prototype.withTypeAwareServerStreamingHandler = function (handler, requestType, responseType) {
        this.handlersRegistry.registerServerStreamingHandler(handler, requestType, responseType);
        return this;
    };
    GenericClientApiBuilder.prototype.withUnaryHandler = function (handler) {
        this.handlersRegistry.registerUnaryGenericHandler(handler);
        return this;
    };
    GenericClientApiBuilder.prototype.withTypeAwareUnaryHandler = function (handler, requestType, responseType) {
        this.handlersRegistry.registerUnaryHandler(handler, requestType, responseType);
        return this;
    };
    GenericClientApiBuilder.prototype.withTransportConnectionProvider = function (provider) {
        this.transportConnectionProvider = provider;
        return this;
    };
    GenericClientApiBuilder.prototype.connect = function () {
        var _this = this;
        if (!this.applicationInstanceId) {
            this.applicationInstanceId = transport_common_1.UniqueId.generateNew();
        }
        var appInfo = {
            applicationId: this.applicationId,
            applicationInstanceId: this.applicationInstanceId
        };
        return this.validateState()
            .then(function () { return _this.transportConnectionProvider(); })
            .then(function (connection) {
            _this.log.info('Connection established');
            return new GenericClientFactory_1.GenericClientFactory(connection).createClient(appInfo);
        })
            .then(function (genericClient) {
            var actionsHost = new GenericInvocationsHost_1.GenericInvocationsHost(genericClient, _this.handlersRegistry);
            return actionsHost.start()
                .then(function () { return new GenericClientApiImpl_1.GenericClientApiImpl(genericClient, _this.marshallerProvider, _this.handlersRegistry); })
                .then(function (client) { return _this.clientApiDecorator(client); });
        })
            .catch(function (error) {
            _this.log.error('Unable to create client', error);
            throw error;
        });
    };
    GenericClientApiBuilder.prototype.validateState = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                if (!this.marshallerProvider) {
                    throw 'Marshaller Provider is not defined';
                }
                if (!this.transportConnectionProvider) {
                    throw 'Transport Connection Provider is not defined';
                }
                if (!this.applicationId || !this.applicationInstanceId) {
                    throw 'Application ID is not defined';
                }
                return [2 /*return*/];
            });
        });
    };
    return GenericClientApiBuilder;
}());
exports.GenericClientApiBuilder = GenericClientApiBuilder;
},{"../../generic/GenericClientFactory":215,"./GenericClientApiImpl":201,"./GenericInvocationsHost":202,"./handlers/InvocationHandlersRegistry":204,"@plexus-interop/common":243,"@plexus-interop/io/dist/main/src/static":283,"@plexus-interop/transport-common":315,"tslib":180}],201:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var ClientDtoUtils_1 = require("./../../ClientDtoUtils");
var StreamingInvocationClientImpl_1 = require("./handlers/streaming/StreamingInvocationClientImpl");
var protocol_1 = require("@plexus-interop/protocol");
var common_1 = require("@plexus-interop/common");
var DelegateInvocationObserver_1 = require("../../api/DelegateInvocationObserver");
var LoggingInvocationObserver_1 = require("../LoggingInvocationObserver");
var InvocationExecutor_1 = require("./InvocationExecutor");
var GenericClientApiImpl = /** @class */ (function () {
    function GenericClientApiImpl(genericClient, marshallerProvider, handlersRegistry) {
        this.genericClient = genericClient;
        this.marshallerProvider = marshallerProvider;
        this.handlersRegistry = handlersRegistry;
        this.log = common_1.LoggerFactory.getLogger('GenericClientApi');
    }
    GenericClientApiImpl.prototype.supported = function (feature) {
        return true;
    };
    GenericClientApiImpl.prototype.getConnectionId = function () {
        return this.genericClient.getConnectionId();
    };
    GenericClientApiImpl.prototype.getMarshallerProvider = function () {
        return this.marshallerProvider;
    };
    GenericClientApiImpl.prototype.discoverService = function (discoveryRequest) {
        this.log.debug('Service Discovery request');
        return this.genericClient.discoverService(discoveryRequest);
    };
    GenericClientApiImpl.prototype.discoverMethod = function (discoveryRequest) {
        this.log.debug('Method Discovery request');
        return this.genericClient.discoverMethod(discoveryRequest);
    };
    GenericClientApiImpl.prototype.sendRawUnaryRequest = function (genericRequest, request, responseHandler) {
        return this.sendUnaryRequestInternal(this.toInvocationHash(genericRequest), this.requestInvocation(genericRequest), request, responseHandler);
    };
    GenericClientApiImpl.prototype.sendUnaryRequest = function (genericRequest, request, responseHandler, requestType, responseType) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var requestMarshaller, responseMarshaller;
            return tslib_1.__generator(this, function (_a) {
                requestMarshaller = this.marshallerProvider.getMarshaller(requestType);
                responseMarshaller = this.marshallerProvider.getMarshaller(responseType);
                return [2 /*return*/, this.sendRawUnaryRequest(genericRequest, common_1.Arrays.toArrayBuffer(requestMarshaller.encode(request)), {
                        value: function (responsePayload) { return responseHandler.value(responseMarshaller.decode(new Uint8Array(responsePayload))); },
                        error: responseHandler.error
                    })];
            });
        });
    };
    GenericClientApiImpl.prototype.sendRawServerStreamingRequest = function (genericRequest, request, responseObserver) {
        return this.sendServerStreamingRequestInternal(this.toInvocationHash(genericRequest), this.requestInvocation(genericRequest), request, responseObserver);
    };
    GenericClientApiImpl.prototype.sendServerStreamingRequest = function (genericRequest, request, responseObserver, requestType, responseType) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var requestMarshaller, responseMarshaller, encoded;
            return tslib_1.__generator(this, function (_a) {
                requestMarshaller = this.marshallerProvider.getMarshaller(requestType);
                responseMarshaller = this.marshallerProvider.getMarshaller(responseType);
                encoded = common_1.Arrays.toArrayBuffer(requestMarshaller.encode(request));
                return [2 /*return*/, this.sendRawServerStreamingRequest(genericRequest, encoded, {
                        next: function (res) { return responseObserver.next(responseMarshaller.decode(new Uint8Array(res))); },
                        complete: function () { return responseObserver.complete(); },
                        error: function (e) { return responseObserver.error(e); },
                        streamCompleted: function () { return responseObserver.streamCompleted(); }
                    })];
            });
        });
    };
    GenericClientApiImpl.prototype.sendRawBidirectionalStreamingRequest = function (request, responseObserver) {
        return this.sendBidirectionalStreamingRequestInternal(this.toInvocationHash(request), this.requestInvocation(request), responseObserver);
    };
    GenericClientApiImpl.prototype.sendBidirectionalStreamingRequest = function (genericRequest, responseObserver, requestType, responseType) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var requestMarshaller, responseMarshaller, baseClient;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestMarshaller = this.marshallerProvider.getMarshaller(requestType);
                        responseMarshaller = this.marshallerProvider.getMarshaller(responseType);
                        return [4 /*yield*/, this.sendRawBidirectionalStreamingRequest(genericRequest, {
                                next: function (responsePayload) { return responseObserver.next(responseMarshaller.decode(new Uint8Array(responsePayload))); },
                                error: responseObserver.error.bind(responseObserver),
                                complete: responseObserver.complete.bind(responseObserver),
                                streamCompleted: responseObserver.streamCompleted.bind(responseObserver)
                            })];
                    case 1:
                        baseClient = _a.sent();
                        return [2 /*return*/, {
                                error: baseClient.error.bind(baseClient),
                                cancel: baseClient.cancel.bind(baseClient),
                                next: function (request) { return baseClient.next(common_1.Arrays.toArrayBuffer(requestMarshaller.encode(request))); },
                                complete: baseClient.complete.bind(baseClient)
                            }];
                }
            });
        });
    };
    GenericClientApiImpl.prototype.sendBidirectionalStreamingRequestInternal = function (strInfo, requestInvocation, responseObserver) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var logger, invocation;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        logger = common_1.LoggerFactory.getLogger("Invocation Request [" + strInfo + "]");
                        logger.debug("Sending request for invocation");
                        return [4 /*yield*/, requestInvocation()];
                    case 1:
                        invocation = _a.sent();
                        logger.debug("Invocation created");
                        return [4 /*yield*/, new Promise(function (resolve, reject) {
                                invocation.open(new DelegateInvocationObserver_1.DelegateInvocationObserver(new LoggingInvocationObserver_1.LoggingInvocationObserver(responseObserver, logger), function (s) { return resolve(s); }, function (e) { return reject(e); }));
                            })];
                    case 2:
                        _a.sent();
                        logger.debug('Invocation opened');
                        return [2 /*return*/, new StreamingInvocationClientImpl_1.StreamingInvocationClientImpl(invocation, logger)];
                }
            });
        });
    };
    GenericClientApiImpl.prototype.sendServerStreamingRequestInternal = function (strInfo, requestInvocation, request, responseObserver) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var streamingClient;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.sendBidirectionalStreamingRequestInternal(strInfo, requestInvocation, responseObserver)];
                    case 1:
                        streamingClient = _a.sent();
                        return [4 /*yield*/, streamingClient.next(request)];
                    case 2:
                        _a.sent();
                        streamingClient.complete().catch(function (e) { return responseObserver.error(e); });
                        return [2 /*return*/, streamingClient];
                }
            });
        });
    };
    GenericClientApiImpl.prototype.sendUnaryRequestInternal = function (strInfo, requestInvocation, request, responseHandler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var responseObserver;
            return tslib_1.__generator(this, function (_a) {
                responseObserver = this.createUnaryObserver(responseHandler);
                return [2 /*return*/, this.sendServerStreamingRequestInternal(strInfo, requestInvocation, request, responseObserver)];
            });
        });
    };
    GenericClientApiImpl.prototype.disconnect = function (completion) {
        return this.genericClient.disconnect(completion);
    };
    GenericClientApiImpl.prototype.invokeUnaryHandler = function (invocationContext, actionReference, requestPayload) {
        return new InvocationExecutor_1.InvocationExecutor(this.handlersRegistry).invokeUnaryHandler(invocationContext, actionReference, requestPayload);
    };
    GenericClientApiImpl.prototype.invokeRawUnaryHandler = function (invocationContext, actionReference, requestPayloadBuffer) {
        return new InvocationExecutor_1.InvocationExecutor(this.handlersRegistry).invokeRawUnaryHandler(invocationContext, actionReference, requestPayloadBuffer);
    };
    GenericClientApiImpl.prototype.isDiscovered = function (request) {
        return !!request.providedService;
    };
    GenericClientApiImpl.prototype.toInvocationHash = function (request) {
        return this.isDiscovered(request) ?
            ClientDtoUtils_1.ClientDtoUtils.targetInvocationHash(ClientDtoUtils_1.ClientDtoUtils.providedMethodToInvocationInfo(request))
            : ClientDtoUtils_1.ClientDtoUtils.targetInvocationHash(request);
    };
    GenericClientApiImpl.prototype.requestInvocation = function (request) {
        var _this = this;
        return this.isDiscovered(request) ?
            function () { return _this.genericClient.requestDiscoveredInvocation(request); }
            : function () { return _this.genericClient.requestInvocation(request); };
    };
    GenericClientApiImpl.prototype.createUnaryObserver = function (responseHandler) {
        var _this = this;
        var result = null;
        return {
            next: function (v) {
                _this.log.trace("Received value of " + v.byteLength + " bytes");
                result = v;
            },
            streamCompleted: function () { return _this.log.trace('Incoming stream completed'); },
            error: responseHandler.error.bind(responseHandler),
            complete: function () {
                if (result === null) {
                    var errorText = 'No messages received before completion';
                    _this.log.error(errorText);
                    responseHandler.error(new protocol_1.ClientError(errorText));
                }
                else {
                    responseHandler.value(result);
                }
                _this.log.debug('Unary operation completed');
            }
        };
    };
    return GenericClientApiImpl;
}());
exports.GenericClientApiImpl = GenericClientApiImpl;
},{"../../api/DelegateInvocationObserver":193,"../LoggingInvocationObserver":194,"./../../ClientDtoUtils":191,"./InvocationExecutor":203,"./handlers/streaming/StreamingInvocationClientImpl":206,"@plexus-interop/common":243,"@plexus-interop/protocol":305,"tslib":180}],202:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = require("@plexus-interop/common");
var InvocationExecutor_1 = require("./InvocationExecutor");
var GenericInvocationsHost = /** @class */ (function () {
    function GenericInvocationsHost(genericClient, handlersRegistry) {
        this.genericClient = genericClient;
        this.handlersRegistry = handlersRegistry;
        this.log = common_1.LoggerFactory.getLogger('GenericInvocationHost');
    }
    GenericInvocationsHost.prototype.start = function () {
        var _this = this;
        return this.genericClient.acceptInvocations({
            next: function (invocation) { return _this.handleInvocation(invocation); },
            error: function (e) { return _this.log.error('Error on invocations subscription', e); },
            complete: function () { return _this.log.debug('Invocations subscription completed'); }
        })
            .then(function () { return _this.log.debug('Started to listen invocations'); })
            .catch(function (e) {
            _this.log.error('Error on opening invocations subscription', e);
            throw e;
        });
    };
    GenericInvocationsHost.prototype.handleInvocation = function (invocation) {
        new InvocationExecutor_1.InvocationExecutor(this.handlersRegistry).handleGenericInvocation(invocation);
    };
    return GenericInvocationsHost;
}());
exports.GenericInvocationsHost = GenericInvocationsHost;
},{"./InvocationExecutor":203,"@plexus-interop/common":243}],203:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var common_1 = require("@plexus-interop/common");
var StreamingInvocationHost_1 = require("./handlers/streaming/StreamingInvocationHost");
var transport_common_1 = require("@plexus-interop/transport-common");
var protocol_1 = require("@plexus-interop/protocol");
var InvocationExecutor = /** @class */ (function () {
    function InvocationExecutor(handlersRegistry) {
        this.handlersRegistry = handlersRegistry;
        this.log = common_1.LoggerFactory.getLogger('InvocationExecutor');
    }
    InvocationExecutor.prototype.handleGenericInvocation = function (invocation) {
        this.log.trace("Received invocation");
        new StreamingInvocationHost_1.StreamingInvocationHost(this.handlersRegistry).executeGenericHandler(invocation);
    };
    InvocationExecutor.prototype.handleInvocation = function (invocation) {
        this.log.trace("Received invocation");
        new StreamingInvocationHost_1.StreamingInvocationHost(this.handlersRegistry).executeTypeAwareHandler(invocation);
    };
    InvocationExecutor.prototype.invokeRawUnaryHandler = function (invocationContext, actionReference, requestPayloadBuffer) {
        return this.internalInvokeUnaryHandler(invocationContext, actionReference, requestPayloadBuffer, false);
    };
    InvocationExecutor.prototype.invokeUnaryHandler = function (invocationContext, actionReference, requestPayload) {
        return this.internalInvokeUnaryHandler(invocationContext, actionReference, requestPayload, true);
    };
    InvocationExecutor.prototype.internalInvokeUnaryHandler = function (invocationContext, actionReference, requestPayload, isTyped) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var invocation = {
                uuid: function () { return transport_common_1.UniqueId.generateNew(); },
                sendMessage: function (response) { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
                    return [2 /*return*/, resolve(response)];
                }); }); },
                open: function (observer) {
                    observer.started(new common_1.AnonymousSubscription());
                    observer.next(requestPayload);
                    observer.streamCompleted();
                    observer.complete();
                },
                getMetaInfo: function () {
                    var metaInfo = tslib_1.__assign({}, actionReference, { consumerApplicationId: invocationContext.consumerApplicationId, consumerConnectionId: invocationContext.consumerConnectionId });
                    return metaInfo;
                },
                close: function (completion) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                    return tslib_1.__generator(this, function (_a) {
                        if (!protocol_1.ClientProtocolHelper.isSuccessCompletion(completion || new protocol_1.SuccessCompletion())) {
                            reject(completion);
                            return [2 /*return*/, new protocol_1.ErrorCompletion()];
                        }
                        else {
                            return [2 /*return*/, new protocol_1.SuccessCompletion()];
                        }
                        return [2 /*return*/];
                    });
                }); }
            };
            isTyped ? _this.handleInvocation(invocation) : _this.handleGenericInvocation(invocation);
        });
    };
    return InvocationExecutor;
}());
exports.InvocationExecutor = InvocationExecutor;
},{"./handlers/streaming/StreamingInvocationHost":207,"@plexus-interop/common":243,"@plexus-interop/protocol":305,"@plexus-interop/transport-common":315,"tslib":180}],204:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var converters_1 = require("./unary/converters");
var common_1 = require("@plexus-interop/common");
var converters_2 = require("./streaming/converters");
/**
 * Holder for both typed/untyped invocation handlers
 */
var InvocationHandlersRegistry = /** @class */ (function () {
    function InvocationHandlersRegistry(marshallerProvider) {
        this.marshallerProvider = marshallerProvider;
        this.log = common_1.LoggerFactory.getLogger('InvocationHandler');
        // tslint:disable-next-line:typedef
        this.typeAwareHandlers = new Map();
        // tslint:disable-next-line:typedef
        this.genericHandlers = new Map();
    }
    InvocationHandlersRegistry.prototype.registerServerStreamingHandler = function (handler, requestType, responseType) {
        this.typeAwareHandlers.set(this.actionHash(this.toActionRef(handler)), new converters_2.ServerStreamingConverter(this.log).convert(handler));
        this.registerServerStreamingGenericHandler(converters_2.toGenericStreamingHandler(handler, requestType, responseType, this.marshallerProvider));
    };
    InvocationHandlersRegistry.prototype.registerServerStreamingGenericHandler = function (handler) {
        this.registerBidiStreamingGenericHandler(new converters_2.ServerStreamingConverter(this.log).convert(handler));
    };
    InvocationHandlersRegistry.prototype.registerUnaryGenericHandler = function (handler) {
        this.registerBidiStreamingGenericHandler(new converters_1.UnaryHandlerConverter(this.log).convert(handler));
    };
    InvocationHandlersRegistry.prototype.registerUnaryHandler = function (handler, requestType, responseType) {
        this.typeAwareHandlers.set(this.actionHash(this.toActionRef(handler)), new converters_1.UnaryHandlerConverter(this.log).convert(handler));
        this.registerUnaryGenericHandler(converters_1.toGenericUnaryHandler(handler, requestType, responseType, this.marshallerProvider));
    };
    InvocationHandlersRegistry.prototype.registerBidiStreamingHandler = function (handler, requestType, responseType) {
        this.registerBidiStreamingGenericHandler(converters_2.toGenericBidiStreamingHandler(handler, requestType, responseType, this.marshallerProvider));
    };
    InvocationHandlersRegistry.prototype.registerBidiStreamingGenericHandler = function (handler) {
        this.genericHandlers.set(this.actionHash(this.toActionRef(handler)), handler);
    };
    InvocationHandlersRegistry.prototype.getTypeAwareBidiStreamingHandler = function (actionRef) {
        return this.typeAwareHandlers.get(this.actionHash(actionRef));
    };
    InvocationHandlersRegistry.prototype.getRawBidiStreamingHandler = function (actionRef) {
        return this.genericHandlers.get(this.actionHash(actionRef));
    };
    InvocationHandlersRegistry.prototype.actionHash = function (actionRef) {
        var alias = actionRef.serviceAlias || 'default';
        return actionRef.serviceId + "." + alias + "." + actionRef.methodId;
    };
    InvocationHandlersRegistry.prototype.toActionRef = function (handlerRef) {
        return {
            serviceId: handlerRef.serviceInfo.serviceId,
            serviceAlias: handlerRef.serviceInfo.serviceAlias,
            methodId: handlerRef.methodId
        };
    };
    return InvocationHandlersRegistry;
}());
exports.InvocationHandlersRegistry = InvocationHandlersRegistry;
},{"./streaming/converters":208,"./unary/converters":210,"@plexus-interop/common":243}],205:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
tslib_1.__exportStar(require("./streaming"), exports);
tslib_1.__exportStar(require("./unary"), exports);
tslib_1.__exportStar(require("./InvocationHandlersRegistry"), exports);
},{"./InvocationHandlersRegistry":204,"./streaming":209,"./unary":211,"tslib":180}],206:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var protocol_1 = require("@plexus-interop/protocol");
var BaseInvocationClientImpl_1 = require("../../../BaseInvocationClientImpl");
var StreamingInvocationClientImpl = /** @class */ (function (_super) {
    tslib_1.__extends(StreamingInvocationClientImpl, _super);
    function StreamingInvocationClientImpl(invocation, log) {
        return _super.call(this, invocation, log) || this;
    }
    StreamingInvocationClientImpl.prototype.next = function (value) {
        this.log.trace("Sending new message of " + value.byteLength + " bytes");
        return this.invocation.sendMessage(value);
    };
    StreamingInvocationClientImpl.prototype.complete = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var completion;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.log.trace("Complete operation requested");
                        return [4 /*yield*/, this.invocation.close(new protocol_1.SuccessCompletion())];
                    case 1:
                        completion = _a.sent();
                        if (!protocol_1.ClientProtocolHelper.isSuccessCompletion(completion)) {
                            this.log.error("Completed with errors", completion ? completion.error : 'Completion is empty');
                            throw completion && completion.error ? completion.error : new protocol_1.ClientError('Completed with errors');
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    return StreamingInvocationClientImpl;
}(BaseInvocationClientImpl_1.BaseInvocationClientImpl));
exports.StreamingInvocationClientImpl = StreamingInvocationClientImpl;
},{"../../../BaseInvocationClientImpl":192,"@plexus-interop/protocol":305,"tslib":180}],207:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var StreamingInvocationClientImpl_1 = require("./StreamingInvocationClientImpl");
var common_1 = require("@plexus-interop/common");
var ClientDtoUtils_1 = require("../../../../ClientDtoUtils");
var client_api_1 = require("@plexus-interop/client-api");
var StreamingInvocationHost = /** @class */ (function () {
    function StreamingInvocationHost(handlersRegistry) {
        this.handlersRegistry = handlersRegistry;
        this.logger = common_1.LoggerFactory.getLogger('StreamingInvocationHost');
    }
    StreamingInvocationHost.prototype.executeTypeAwareHandler = function (invocation, cancellationToken) {
        if (cancellationToken === void 0) { cancellationToken = new common_1.CancellationToken(); }
        this.execute(true, invocation, cancellationToken);
    };
    StreamingInvocationHost.prototype.executeGenericHandler = function (invocation, cancellationToken) {
        if (cancellationToken === void 0) { cancellationToken = new common_1.CancellationToken(); }
        this.execute(false, invocation, cancellationToken);
    };
    StreamingInvocationHost.prototype.execute = function (isTypeAware, invocation, cancellationToken) {
        var _this = this;
        if (cancellationToken === void 0) { cancellationToken = new common_1.CancellationToken(); }
        this.logger.debug('Handling invocation started');
        var baseRequestObserver = null;
        invocation.open({
            started: function (s) {
                _this.logger.trace('Invocation opened');
                var metaInfo = invocation.getMetaInfo();
                var actionRef = {
                    serviceAlias: metaInfo.serviceAlias,
                    methodId: metaInfo.methodId,
                    serviceId: metaInfo.serviceId
                };
                var hash = ClientDtoUtils_1.ClientDtoUtils.targetInvocationHash(metaInfo);
                _this.logger = common_1.LoggerFactory.getLogger("Invocation Host [" + hash + "]");
                var invocationHandler = isTypeAware ? _this.handlersRegistry.getTypeAwareBidiStreamingHandler(actionRef) : _this.handlersRegistry.getRawBidiStreamingHandler(actionRef);
                if (invocationHandler) {
                    var invocationContext = new client_api_1.MethodInvocationContext(metaInfo.consumerApplicationId, metaInfo.consumerConnectionId, cancellationToken);
                    baseRequestObserver = invocationHandler.handle(invocationContext, new StreamingInvocationClientImpl_1.StreamingInvocationClientImpl(invocation, _this.logger));
                }
                else {
                    _this.logger.error("No handler found for hash [" + hash + "]");
                }
            },
            startFailed: function (e) { return _this.logger.error('Could not open invocation', e); },
            next: function (requestPayload) {
                if (!isTypeAware) {
                    _this.logger.trace("Received message of " + requestPayload.byteLength + " bytes");
                }
                else {
                    _this.logger.trace("Received message object");
                }
                _this.handleClientAction(baseRequestObserver, function () { return baseRequestObserver.next(requestPayload); });
            },
            complete: function () {
                _this.logger.trace('Received remote completion');
                _this.handleClientAction(baseRequestObserver, function () { return baseRequestObserver.complete(); });
            },
            streamCompleted: function () {
                _this.logger.trace('Received remote stream completion');
                _this.handleClientAction(baseRequestObserver, function () { return baseRequestObserver.streamCompleted(); });
            },
            error: function (invocationError) {
                _this.logger.error("Received invocation error, passing to client", invocationError);
                cancellationToken.cancel('Invocation error received');
                _this.handleClientAction(baseRequestObserver, function () { return baseRequestObserver.error(invocationError); });
            }
        });
    };
    StreamingInvocationHost.prototype.handleClientAction = function (nullableClient, func) {
        if (nullableClient === null) {
            this.logger.error('Client is not initialized');
        }
        else {
            try {
                func();
            }
            catch (error) {
                this.logger.error('Internal client\'s execution error', error);
            }
        }
    };
    return StreamingInvocationHost;
}());
exports.StreamingInvocationHost = StreamingInvocationHost;
},{"../../../../ClientDtoUtils":191,"./StreamingInvocationClientImpl":206,"@plexus-interop/client-api":190,"@plexus-interop/common":243}],208:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var ClientDtoUtils_1 = require("../../../../ClientDtoUtils");
var common_1 = require("@plexus-interop/common");
var ServerStreamingConverter = /** @class */ (function () {
    function ServerStreamingConverter(log) {
        if (log === void 0) { log = common_1.LoggerFactory.getLogger('ServerStreamingConverter'); }
        this.log = log;
    }
    ServerStreamingConverter.prototype.convert = function (baseHandler) {
        var _this = this;
        return {
            serviceInfo: baseHandler.serviceInfo,
            methodId: baseHandler.methodId,
            handle: function (invocationContext, invocationHostClient) {
                return {
                    next: function (request) {
                        try {
                            baseHandler.handle(invocationContext, request, invocationHostClient);
                        }
                        catch (executionError) {
                            _this.log.error('Execution error', executionError);
                            invocationHostClient.error(ClientDtoUtils_1.ClientDtoUtils.toError(executionError));
                        }
                    },
                    streamCompleted: function () { return _this.log.debug('Messages stream completed'); },
                    error: function (e) { return _this.log.error('Error received', e); },
                    complete: function () { return _this.log.debug('Invocation completed'); }
                };
            }
        };
    };
    return ServerStreamingConverter;
}());
exports.ServerStreamingConverter = ServerStreamingConverter;
function toGenericStreamingHandler(typedHandler, requestType, responseType, marshallerProvider) {
    var requestMarshaller = marshallerProvider.getMarshaller(requestType);
    var responseMarshaller = marshallerProvider.getMarshaller(responseType);
    return tslib_1.__assign({}, typedHandler, { handle: function (invocationContext, requestPayload, hostClient) {
            var typedPayload = requestMarshaller.decode(new Uint8Array(requestPayload));
            typedHandler.handle(invocationContext, typedPayload, {
                next: function (response) { return hostClient.next(common_1.Arrays.toArrayBuffer(responseMarshaller.encode(response))); },
                complete: hostClient.complete.bind(hostClient),
                error: hostClient.error.bind(hostClient),
                cancel: hostClient.cancel.bind(hostClient)
            });
        } });
}
exports.toGenericStreamingHandler = toGenericStreamingHandler;
function toGenericBidiStreamingHandler(typedHandler, requestType, responseType, marshallerProvider) {
    var requestMarshaller = marshallerProvider.getMarshaller(requestType);
    var responseMarshaller = marshallerProvider.getMarshaller(responseType);
    return tslib_1.__assign({}, typedHandler, { handle: function (invocationContext, hostClient) {
            var baseObserver = typedHandler.handle(invocationContext, {
                next: function (typedResponse) { return hostClient.next(common_1.Arrays.toArrayBuffer(responseMarshaller.encode(typedResponse))); },
                complete: hostClient.complete.bind(hostClient),
                error: hostClient.error.bind(hostClient),
                cancel: hostClient.cancel.bind(hostClient)
            });
            return {
                next: function (requestPayload) { return baseObserver.next(requestMarshaller.decode(new Uint8Array(requestPayload))); },
                complete: baseObserver.complete.bind(baseObserver),
                error: baseObserver.error.bind(baseObserver),
                streamCompleted: baseObserver.streamCompleted.bind(baseObserver)
            };
        } });
}
exports.toGenericBidiStreamingHandler = toGenericBidiStreamingHandler;
},{"../../../../ClientDtoUtils":191,"@plexus-interop/common":243,"tslib":180}],209:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./StreamingInvocationHost"), exports);
},{"./StreamingInvocationHost":207,"tslib":180}],210:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var common_1 = require("@plexus-interop/common");
var common_2 = require("@plexus-interop/common");
var ClientDtoUtils_1 = require("../../../../ClientDtoUtils");
function toGenericUnaryHandler(handler, requestType, responseType, marshallerProvider) {
    var _this = this;
    var requestMarshaller = marshallerProvider.getMarshaller(requestType);
    var responseMarshaller = marshallerProvider.getMarshaller(responseType);
    return tslib_1.__assign({}, handler, { handle: function (invocationContext, request) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var payload, rawResponse;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        payload = requestMarshaller.decode(new Uint8Array(request));
                        return [4 /*yield*/, handler.handle(invocationContext, payload)];
                    case 1:
                        rawResponse = _a.sent();
                        return [2 /*return*/, common_1.Arrays.toArrayBuffer(responseMarshaller.encode(rawResponse))];
                }
            });
        }); } });
}
exports.toGenericUnaryHandler = toGenericUnaryHandler;
var UnaryHandlerConverter = /** @class */ (function () {
    function UnaryHandlerConverter(log) {
        if (log === void 0) { log = common_2.LoggerFactory.getLogger('UnaryHandlerConverter'); }
        this.log = log;
    }
    UnaryHandlerConverter.prototype.convert = function (unary) {
        var _this = this;
        return {
            serviceInfo: unary.serviceInfo,
            methodId: unary.methodId,
            handle: function (invocationContext, invocationHostClient) {
                return {
                    next: function (request) {
                        try {
                            unary.handle(invocationContext, request).then(function (response) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                                var error_1;
                                return tslib_1.__generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            _a.trys.push([0, 3, , 4]);
                                            return [4 /*yield*/, invocationHostClient.next(response)];
                                        case 1:
                                            _a.sent();
                                            return [4 /*yield*/, invocationHostClient.complete()];
                                        case 2:
                                            _a.sent();
                                            return [3 /*break*/, 4];
                                        case 3:
                                            error_1 = _a.sent();
                                            this.log.error('Unable to send response', error_1);
                                            return [3 /*break*/, 4];
                                        case 4: return [2 /*return*/];
                                    }
                                });
                            }); }).catch(function (error) {
                                _this.log.error('Execution error', error);
                                invocationHostClient.error(ClientDtoUtils_1.ClientDtoUtils.toError(error));
                            });
                        }
                        catch (executionError) {
                            _this.log.error('Execution error', executionError);
                            invocationHostClient.error(ClientDtoUtils_1.ClientDtoUtils.toError(executionError));
                        }
                    },
                    streamCompleted: function () { return _this.log.debug('Stream completed'); },
                    error: function (e) { return _this.log.error('Error received', e); },
                    complete: function () { return _this.log.debug('Invocation completed'); }
                };
            }
        };
    };
    return UnaryHandlerConverter;
}());
exports.UnaryHandlerConverter = UnaryHandlerConverter;
},{"../../../../ClientDtoUtils":191,"@plexus-interop/common":243,"tslib":180}],211:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./converters"), exports);
},{"./converters":210,"tslib":180}],212:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./GenericClientApi"), exports);
tslib_1.__exportStar(require("./GenericClientApiImpl"), exports);
tslib_1.__exportStar(require("./GenericClientApiBase"), exports);
tslib_1.__exportStar(require("./GenericInvocationsHost"), exports);
tslib_1.__exportStar(require("./GenericClientApiBuilder"), exports);
tslib_1.__exportStar(require("./handlers"), exports);
},{"./GenericClientApi":198,"./GenericClientApiBase":199,"./GenericClientApiBuilder":200,"./GenericClientApiImpl":201,"./GenericInvocationsHost":202,"./handlers":205,"tslib":180}],213:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
tslib_1.__exportStar(require("./generic"), exports);
tslib_1.__exportStar(require("@plexus-interop/client-api"), exports);
tslib_1.__exportStar(require("@plexus-interop/io"), exports);
tslib_1.__exportStar(require("./DelegateInvocationObserver"), exports);
tslib_1.__exportStar(require("./container"), exports);
},{"./DelegateInvocationObserver":193,"./container":197,"./generic":212,"@plexus-interop/client-api":190,"@plexus-interop/io":281,"tslib":180}],214:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AcceptedInvocation = /** @class */ (function () {
    function AcceptedInvocation(genericInvocation) {
        this.genericInvocation = genericInvocation;
    }
    AcceptedInvocation.prototype.uuid = function () {
        return this.genericInvocation.uuid();
    };
    AcceptedInvocation.prototype.sendMessage = function (data) {
        return this.genericInvocation.sendMessage(data);
    };
    AcceptedInvocation.prototype.open = function (observer) {
        this.genericInvocation.acceptInvocation(observer);
    };
    AcceptedInvocation.prototype.close = function (completion) {
        return this.genericInvocation.close(completion);
    };
    AcceptedInvocation.prototype.getMetaInfo = function () {
        return this.genericInvocation.getMetaInfo();
    };
    return AcceptedInvocation;
}());
exports.AcceptedInvocation = AcceptedInvocation;
},{}],215:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var common_1 = require("@plexus-interop/common");
var GenericClientImpl_1 = require("./GenericClientImpl");
var SingleMessageRequst_1 = require("./SingleMessageRequst");
var protocol_1 = require("@plexus-interop/protocol");
var GenericClientFactory = /** @class */ (function () {
    function GenericClientFactory(transportConnection) {
        this.transportConnection = transportConnection;
        this.log = common_1.LoggerFactory.getLogger('GenericClientFactory');
    }
    GenericClientFactory.prototype.createClient = function (request) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            var requestPayload;
            return tslib_1.__generator(this, function (_a) {
                requestPayload = protocol_1.ClientProtocolHelper.connectRequestPayload(request);
                this.log.debug('Sending client connect request');
                return [2 /*return*/, new SingleMessageRequst_1.SingleMessageRequest(this.transportConnection, this.log)
                        .execute(requestPayload, function (responsePayload) { return protocol_1.ClientProtocolHelper.decodeConnectResponse(responsePayload); })
                        .then(function (response) {
                        _this.log.info('Client connected');
                        return new GenericClientImpl_1.GenericClientImpl(protocol_1.UniqueId.fromProperties(response.connectionId), _this.transportConnection);
                    })];
            });
        });
    };
    return GenericClientFactory;
}());
exports.GenericClientFactory = GenericClientFactory;
},{"./GenericClientImpl":216,"./SingleMessageRequst":222,"@plexus-interop/common":243,"@plexus-interop/protocol":305,"tslib":180}],216:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var GenericInvocation_1 = require("./GenericInvocation");
var Subscription_1 = require("rxjs/Subscription");
var RequestedInvocation_1 = require("./RequestedInvocation");
var common_1 = require("@plexus-interop/common");
var AcceptedInvocation_1 = require("./AcceptedInvocation");
var SingleMessageRequst_1 = require("./SingleMessageRequst");
var protocol_1 = require("@plexus-interop/protocol");
var protocol_2 = require("@plexus-interop/protocol");
var RequestedDiscoveredInvocation_1 = require("./RequestedDiscoveredInvocation");
var ClientState;
(function (ClientState) {
    ClientState["CREATED"] = "CREATED";
    ClientState["LISTEN"] = "LISTEN";
    ClientState["CLOSED"] = "CLOSED";
})(ClientState || (ClientState = {}));
var GenericClientImpl = /** @class */ (function () {
    function GenericClientImpl(connectionId, transportConnection) {
        var _this = this;
        this.connectionId = connectionId;
        this.transportConnection = transportConnection;
        this.cancellationToken = new common_1.CancellationToken();
        this.log = common_1.LoggerFactory.getLogger('GenericClient');
        this.state = new common_1.StateMaschineBase(ClientState.CREATED, [
            {
                from: ClientState.CREATED, to: ClientState.LISTEN
            },
            {
                from: ClientState.CREATED, to: ClientState.CLOSED, preHandler: function () { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
                    return [2 /*return*/, this.cancellationToken.cancel('Closed')];
                }); }); }
            },
            {
                from: ClientState.LISTEN, to: ClientState.CLOSED, preHandler: function () { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
                    return [2 /*return*/, this.cancellationToken.cancel('Closed')];
                }); }); }
            }
        ], this.log);
        this.log.trace('Created');
    }
    GenericClientImpl.prototype.getConnectionId = function () {
        return this.connectionId;
    };
    GenericClientImpl.prototype.requestInvocation = function (invocationInfo) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channel;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.log.debug('Invocation requested');
                        return [4 /*yield*/, this.transportConnection.createChannel()];
                    case 1:
                        channel = _a.sent();
                        return [2 /*return*/, new RequestedInvocation_1.RequestedInvocation(new GenericInvocation_1.GenericInvocation(channel), invocationInfo)];
                }
            });
        });
    };
    GenericClientImpl.prototype.requestDiscoveredInvocation = function (methodReference) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channel;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.log.debug('Discovered Invocation requested');
                        return [4 /*yield*/, this.transportConnection.createChannel()];
                    case 1:
                        channel = _a.sent();
                        return [2 /*return*/, new RequestedDiscoveredInvocation_1.RequestedDiscoveredInvocation(new GenericInvocation_1.GenericInvocation(channel), methodReference)];
                }
            });
        });
    };
    GenericClientImpl.prototype.acceptInvocations = function (observer) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            var channelsObserver;
            return tslib_1.__generator(this, function (_a) {
                this.log.debug('Accept invocation requested');
                this.state.throwIfNot(ClientState.CREATED);
                channelsObserver = {
                    next: function (channel) {
                        observer.next(new AcceptedInvocation_1.AcceptedInvocation(new GenericInvocation_1.GenericInvocation(channel)));
                    },
                    error: function (e) { return observer.error(e); },
                    complete: function () { return observer.complete(); }
                };
                this.state.go(ClientState.LISTEN);
                this.startIncomingChannelsListener(channelsObserver);
                return [2 /*return*/, new Subscription_1.Subscription(function () {
                        _this.log.debug('Unsubscribe received');
                        if (_this.state.is(ClientState.LISTEN)) {
                            _this.state.go(ClientState.CLOSED);
                        }
                    })];
            });
        });
    };
    GenericClientImpl.prototype.discoverService = function (discoveryRequest) {
        var _this = this;
        var requestPayload = protocol_1.ClientProtocolHelper.discoveryServiceRequestPayload(discoveryRequest);
        return new SingleMessageRequst_1.SingleMessageRequest(this.transportConnection, this.log)
            .execute(requestPayload, function (responsePayload) { return protocol_1.ClientProtocolHelper.decodeServiceDiscoveryResponse(responsePayload); })
            .then(function (response) {
            _this.log.debug("Discovery Service response received");
            return response;
        });
    };
    GenericClientImpl.prototype.discoverMethod = function (discoveryRequest) {
        var _this = this;
        var requestPayload = protocol_1.ClientProtocolHelper.discoveryMethodRequestPayload(discoveryRequest);
        return new SingleMessageRequst_1.SingleMessageRequest(this.transportConnection, this.log)
            .execute(requestPayload, function (responsePayload) { return protocol_1.ClientProtocolHelper.decodeMethodDiscoveryResponse(responsePayload); })
            .then(function (response) {
            _this.log.debug("Discovery Method response received");
            return response;
        });
    };
    GenericClientImpl.prototype.disconnect = function (completion) {
        if (completion === void 0) { completion = new protocol_2.SuccessCompletion(); }
        return this.transportConnection.disconnect(completion);
    };
    GenericClientImpl.prototype.startIncomingChannelsListener = function (observer) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                this.log.debug('Started to listen for channels');
                this.transportConnection.subscribeToChannels({
                    next: function (channel) {
                        if (_this.state.is(ClientState.LISTEN)) {
                            _this.log.debug('Channel received');
                            observer.next(channel);
                        }
                        else {
                            _this.log.warn("State is " + _this.state.getCurrent() + ", skip incoming channel");
                        }
                    },
                    complete: function () {
                        _this.log.debug('Channels subscription completed');
                        observer.complete();
                    },
                    error: function (e) {
                        _this.log.error('Error while receceivign channel', e);
                        _this.state.go(ClientState.CLOSED);
                    }
                });
                return [2 /*return*/];
            });
        });
    };
    return GenericClientImpl;
}());
exports.GenericClientImpl = GenericClientImpl;
},{"./AcceptedInvocation":214,"./GenericInvocation":217,"./RequestedDiscoveredInvocation":220,"./RequestedInvocation":221,"./SingleMessageRequst":222,"@plexus-interop/common":243,"@plexus-interop/protocol":305,"rxjs/Subscription":129,"tslib":180}],217:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var transport_common_1 = require("@plexus-interop/transport-common");
var protocol_1 = require("@plexus-interop/protocol");
var protocol_2 = require("@plexus-interop/protocol");
var InvocationState_1 = require("./InvocationState");
var Subscription_1 = require("rxjs/Subscription");
var common_1 = require("@plexus-interop/common");
var ClientDtoUtils_1 = require("../ClientDtoUtils");
var GenericInvocation = /** @class */ (function () {
    function GenericInvocation(sourceChannel, baseReadToken, invocationTimeout) {
        if (baseReadToken === void 0) { baseReadToken = new common_1.CancellationToken(); }
        if (invocationTimeout === void 0) { invocationTimeout = -1; }
        this.sourceChannel = sourceChannel;
        this.invocationTimeout = invocationTimeout;
        this.sentMessagesCounter = 0;
        this.sendCompletionReceived = false;
        this.readCancellationToken = new common_1.CancellationToken(baseReadToken);
        this.log = common_1.LoggerFactory.getLogger('Invocation');
        this.stateMachine = new common_1.StateMaschineBase(InvocationState_1.InvocationState.CREATED, [
            // initialization states
            {
                from: InvocationState_1.InvocationState.CREATED, to: InvocationState_1.InvocationState.START_REQUESTED
            }, {
                from: InvocationState_1.InvocationState.START_REQUESTED, to: InvocationState_1.InvocationState.REMOTE_STARTING
            }, {
                from: InvocationState_1.InvocationState.REMOTE_STARTING, to: InvocationState_1.InvocationState.OPEN
            }, {
                from: InvocationState_1.InvocationState.CREATED, to: InvocationState_1.InvocationState.ACCEPTING_INVOCATION_INFO
            }, {
                from: InvocationState_1.InvocationState.ACCEPTING_INVOCATION_INFO, to: InvocationState_1.InvocationState.OPEN
            }, {
                from: InvocationState_1.InvocationState.START_REQUESTED, to: InvocationState_1.InvocationState.OPEN
            },
            // active states
            {
                from: InvocationState_1.InvocationState.OPEN, to: InvocationState_1.InvocationState.COMPLETION_RECEIVED
            }, {
                from: InvocationState_1.InvocationState.COMPLETION_RECEIVED, to: InvocationState_1.InvocationState.COMPLETED
            }, {
                from: InvocationState_1.InvocationState.OPEN, to: InvocationState_1.InvocationState.COMPLETED
            }
        ]);
    }
    GenericInvocation.prototype.start = function (metaInfo, invocationObserver) {
        var _this = this;
        this.metaInfo = metaInfo;
        this.log.trace('Start basic invocation');
        this.startInvocationInternal(function () { return _this.sendStartInvocationRequest(metaInfo); }, invocationObserver);
    };
    GenericInvocation.prototype.startDiscovered = function (methodReference, invocationObserver) {
        var _this = this;
        this.log.trace('Start discovered invocation');
        this.metaInfo = ClientDtoUtils_1.ClientDtoUtils.providedMethodToInvocationInfo(methodReference);
        this.startInvocationInternal(function () { return _this.sendStartDiscoveredInvocationRequest(methodReference); }, invocationObserver);
    };
    GenericInvocation.prototype.acceptInvocation = function (invocationObserver) {
        var _this = this;
        this.log.debug('Accept of invocation requested');
        this.stateMachine.throwIfNot(InvocationState_1.InvocationState.CREATED);
        this.stateMachine.go(InvocationState_1.InvocationState.ACCEPTING_INVOCATION_INFO);
        this.openSubscription(invocationObserver)
            .catch(function (e) { return _this.log.error('Failed to open channel subscription', e); });
    };
    GenericInvocation.prototype.uuid = function () {
        return this.id;
    };
    GenericInvocation.prototype.getMetaInfo = function () {
        return this.metaInfo;
    };
    GenericInvocation.prototype.close = function (completion) {
        if (completion === void 0) { completion = new protocol_1.SuccessCompletion(); }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            var error_1, errorText;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        /* istanbul ignore if */
                        if (this.log.isDebugEnabled()) {
                            this.log.debug('Close invocation requested', JSON.stringify(completion));
                        }
                        if (this.stateMachine.is(InvocationState_1.InvocationState.COMPLETED)) {
                            this.log.warn('Already completed');
                            return [2 /*return*/, Promise.resolve(completion)];
                        }
                        this.stateMachine.throwIfNot(InvocationState_1.InvocationState.OPEN, InvocationState_1.InvocationState.COMPLETION_RECEIVED);
                        this.stateMachine.go(InvocationState_1.InvocationState.COMPLETED);
                        this.log.trace('Sending completion message');
                        this.sourceChannel.sendMessage(protocol_2.ClientProtocolHelper.sendCompletionPayload({}));
                        if (!protocol_2.ClientProtocolHelper.isSuccessCompletion(completion)) return [3 /*break*/, 4];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        this.log.trace('Waiting for send completion from remote');
                        return [4 /*yield*/, this.waitForIt(function () { return _this.sendCompletionReceived; })];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        error_1 = _a.sent();
                        errorText = 'Unable to wait for send completion, trying to terminate';
                        this.log.error(errorText, error_1);
                        this.terminate(errorText);
                        return [2 /*return*/, Promise.reject(error_1)];
                    case 4:
                        this.log.trace('Sending channel close message');
                        return [2 /*return*/, this.closeChannel(completion)];
                }
            });
        });
    };
    GenericInvocation.prototype.sendMessage = function (data) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var headerPayload;
            return tslib_1.__generator(this, function (_a) {
                this.stateMachine.throwIfNot(InvocationState_1.InvocationState.OPEN, InvocationState_1.InvocationState.COMPLETION_RECEIVED);
                this.log.trace("Sending message of " + data.byteLength + " bytes");
                headerPayload = protocol_2.ClientProtocolHelper.messageHeaderPayload({
                    length: data.byteLength
                });
                this.sourceChannel.sendMessage(headerPayload);
                this.sourceChannel.sendMessage(data);
                this.sentMessagesCounter++;
                return [2 /*return*/];
            });
        });
    };
    // public methods below are NOT a part of API, for unit tests only
    GenericInvocation.prototype.currentState = function () {
        return this.stateMachine.getCurrent();
    };
    GenericInvocation.prototype.getSentMessagesCounter = function () {
        return this.sentMessagesCounter;
    };
    GenericInvocation.prototype.setUuid = function (id) {
        this.log.debug("Set id, " + id.toString());
        this.log = common_1.LoggerFactory.getLogger("Invocation [" + id.toString() + "]");
        this.id = id;
    };
    GenericInvocation.prototype.startInvocationInternal = function (sendRequest, invocationObserver) {
        var _this = this;
        this.log.debug('Invocation start requested');
        this.stateMachine.throwIfNot(InvocationState_1.InvocationState.CREATED);
        this.setUuid(transport_common_1.UniqueId.generateNew());
        var subscriptionStartedPromise = this.openSubscription(invocationObserver);
        this.stateMachine.goAsync(InvocationState_1.InvocationState.START_REQUESTED, {
            preHandler: function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, subscriptionStartedPromise];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, sendRequest()];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            }); }
        })
            .catch(function (e) { return _this.log.error('Invocation start failed', e); });
    };
    GenericInvocation.prototype.terminate = function (message) {
        this.log.error('Terminating channel');
        this.closeChannel(new protocol_1.ErrorCompletion(new protocol_1.ClientError(message)));
    };
    GenericInvocation.prototype.waitForIt = function (check) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, common_1.AsyncHelper.waitFor(check, this.readCancellationToken, transport_common_1.Defaults.STATUS_CHECK_INTERVAL, this.invocationTimeout)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    GenericInvocation.prototype.closeChannel = function (completion) {
        var _this = this;
        return this.sourceChannel.close(completion).then(function (channelCompletion) {
            _this.log.debug('Channel closed');
            _this.closeInternal();
            var result = protocol_1.ClientProtocolUtils.createSummarizedCompletion(completion, channelCompletion, _this.checkInternalStatus());
            if (_this.log.isTraceEnabled()) {
                _this.log.trace("Completion result " + JSON.stringify(result));
            }
            return result;
        }).catch(function (e) {
            /* istanbul ignore if */
            if (_this.log.isDebugEnabled()) {
                _this.log.debug('Error during channel closure', e);
            }
            _this.closeInternal();
            throw e;
        });
    };
    GenericInvocation.prototype.handleRemoteSentCompleted = function (invocationObserver) {
        this.log.debug('Source channel subscription completed');
        invocationObserver.streamCompleted();
        this.sendCompletionReceived = true;
        switch (this.stateMachine.getCurrent()) {
            case InvocationState_1.InvocationState.OPEN:
                this.log.debug('Open state, switching to COMPLETION_RECEIVED');
                this.stateMachine.go(InvocationState_1.InvocationState.COMPLETION_RECEIVED);
                break;
            case InvocationState_1.InvocationState.COMPLETED:
                this.log.debug('Already completed');
                break;
            default:
                throw new Error("Can't handle completion, invalid state " + this.stateMachine.getCurrent());
        }
    };
    GenericInvocation.prototype.closeInternal = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                this.readCancellationToken.cancel('Invocation closed');
                return [2 /*return*/];
            });
        });
    };
    GenericInvocation.prototype.openSubscription = function (invocationObserver) {
        var _this = this;
        this.log.trace("Starting listening of incoming messages");
        return new Promise(function (resolve, reject) {
            _this.sourceChannel.open({
                started: function (sourceSubscription) {
                    _this.log.debug('Source channel subscription started');
                    resolve(sourceSubscription);
                },
                startFailed: function (error) {
                    _this.log.error('Unable to open source channel', error);
                    invocationObserver.startFailed(error);
                    reject(error);
                },
                next: function (message) {
                    try {
                        _this.handleIncomingMessage(message, invocationObserver);
                    }
                    catch (e) {
                        var errorText = 'Error while processing of incoming message';
                        _this.log.error(errorText, e);
                        _this.terminate(errorText);
                        invocationObserver.error(e);
                    }
                },
                complete: function () {
                    _this.log.debug('Remote channel closed');
                    invocationObserver.complete();
                },
                error: function (e) {
                    _this.log.error('Error from source channel received', e);
                    _this.closeInternal();
                    invocationObserver.error(e);
                }
            });
        });
    };
    GenericInvocation.prototype.handleIncomingMessage = function (data, invocationObserver) {
        var _this = this;
        this.log.trace("Received message of " + data.byteLength + " bytes");
        if (this.readCancellationToken.isCancelled()) {
            this.log.warn("Read cancelled with '" + this.readCancellationToken.getReason() + "', drop message");
            return;
        }
        if (this.pendingHeader) {
            this.log.trace("Received message payload of " + data.byteLength + " length");
            this.pendingHeader = null;
            this.sourceChannel.sendMessage(protocol_2.ClientProtocolHelper.messageReceivedPayload({
                invocationId: this.uuid()
            }));
            invocationObserver.next(data);
        }
        else if (this.stateMachine.is(InvocationState_1.InvocationState.START_REQUESTED)) {
            this.log.debug('Received invocation starting message');
            protocol_2.ClientProtocolHelper.decodeInvocationStarting(data);
            this.stateMachine.go(InvocationState_1.InvocationState.REMOTE_STARTING);
        }
        else if (this.stateMachine.is(InvocationState_1.InvocationState.REMOTE_STARTING)) {
            this.log.debug('Received invocation started message');
            protocol_2.ClientProtocolHelper.decodeInvocationStarted(data);
            this.stateMachine.go(InvocationState_1.InvocationState.OPEN);
            // requested invocation started
            invocationObserver.started(new Subscription_1.Subscription(function () { return _this.close(); }));
        }
        else if (this.stateMachine.is(InvocationState_1.InvocationState.ACCEPTING_INVOCATION_INFO)) {
            var envelopObject = protocol_2.ClientProtocolHelper.decodeBrokerEnvelop(data);
            if (envelopObject.invocationStartRequested) {
                if (this.log.isTraceEnabled()) {
                    this.log.trace("Received invocation request message " + JSON.stringify(envelopObject.invocationStartRequested));
                }
                this.metaInfo = protocol_2.ClientProtocolHelper.toInvocationInfo(envelopObject.invocationStartRequested);
                // accepted invocation started
                this.setUuid(transport_common_1.UniqueId.generateNew());
                this.stateMachine.go(InvocationState_1.InvocationState.OPEN);
                this.sourceChannel.sendMessage(protocol_2.ClientProtocolHelper.invocationStartedMessagePayload({
                    invocationId: this.uuid()
                }));
                invocationObserver.started(new Subscription_1.Subscription(function () { return _this.close(); }));
            }
            else {
                this.log.warn("Unknown message received " + JSON.stringify(envelopObject));
            }
        }
        else if (this.stateMachine.isOneOf(InvocationState_1.InvocationState.OPEN, InvocationState_1.InvocationState.COMPLETED, InvocationState_1.InvocationState.COMPLETION_RECEIVED)) {
            var envelopObject = protocol_2.ClientProtocolHelper.decodeInvocationEnvelop(data);
            if (envelopObject.message) {
                this.log.trace("Received message header");
                this.pendingHeader = envelopObject.message;
            }
            else if (envelopObject.confirmation) {
                this.log.trace("Received message delivery confirmation");
                this.sentMessagesCounter--;
            }
            else if (envelopObject.sendCompletion) {
                this.log.trace("Received send completion");
                this.handleRemoteSentCompleted(invocationObserver);
            }
            else {
                this.log.warn("Unknown message received " + JSON.stringify(envelopObject));
            }
        }
        else {
            throw new Error("Unexpected state, " + this.currentState());
        }
    };
    GenericInvocation.prototype.checkInternalStatus = function () {
        if (this.sentMessagesCounter !== 0) {
            var message = "Confirmation not received for all messages, " + this.sentMessagesCounter;
            return {
                status: protocol_1.clientProtocol.Completion.Status.Failed,
                error: {
                    message: message
                }
            };
        }
        else {
            return {
                status: protocol_1.clientProtocol.Completion.Status.Completed
            };
        }
    };
    GenericInvocation.prototype.sendStartInvocationRequest = function (metaInfo) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var payload;
            return tslib_1.__generator(this, function (_a) {
                this.log.trace('Sending start request to channel');
                payload = protocol_2.ClientProtocolHelper.invocationStartRequestPayload(metaInfo);
                return [2 /*return*/, this.sourceChannel.sendMessage(payload)];
            });
        });
    };
    GenericInvocation.prototype.sendStartDiscoveredInvocationRequest = function (methodReference) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var payload;
            return tslib_1.__generator(this, function (_a) {
                this.log.trace('Sending start discovered request to channel');
                payload = protocol_2.ClientProtocolHelper.discoveredInvocationStartRequestPayload(methodReference);
                return [2 /*return*/, this.sourceChannel.sendMessage(payload)];
            });
        });
    };
    return GenericInvocation;
}());
exports.GenericInvocation = GenericInvocation;
},{"../ClientDtoUtils":191,"./InvocationState":219,"@plexus-interop/common":243,"@plexus-interop/protocol":305,"@plexus-interop/transport-common":315,"rxjs/Subscription":129,"tslib":180}],218:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var common_1 = require("@plexus-interop/common");
var InvocationObserverConverter = /** @class */ (function (_super) {
    tslib_1.__extends(InvocationObserverConverter, _super);
    function InvocationObserverConverter(source, converter) {
        var _this = _super.call(this, source, converter) || this;
        _this.baseSource = source;
        return _this;
    }
    InvocationObserverConverter.prototype.streamCompleted = function () {
        return this.baseSource.streamCompleted();
    };
    return InvocationObserverConverter;
}(common_1.ConversionObserver));
exports.InvocationObserverConverter = InvocationObserverConverter;
},{"@plexus-interop/common":243,"tslib":180}],219:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// tslint:disable-next-line:variable-name
var InvocationState;
(function (InvocationState) {
    InvocationState["CREATED"] = "CREATED";
    InvocationState["START_REQUESTED"] = "START_REQUESTED";
    InvocationState["REMOTE_STARTING"] = "REMOTE_STARTING";
    InvocationState["ACCEPTING_INVOCATION_INFO"] = "ACCEPTING_INVOCATION_INFO";
    InvocationState["OPEN"] = "OPEN";
    InvocationState["COMPLETION_RECEIVED"] = "COMPLETION_RECEIVED";
    InvocationState["COMPLETED"] = "COMPLETED";
})(InvocationState = exports.InvocationState || (exports.InvocationState = {}));
},{}],220:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var RequestedDiscoveredInvocation = /** @class */ (function () {
    function RequestedDiscoveredInvocation(genericInvocation, methodReference) {
        this.genericInvocation = genericInvocation;
        this.methodReference = methodReference;
    }
    RequestedDiscoveredInvocation.prototype.uuid = function () {
        return this.genericInvocation.uuid();
    };
    RequestedDiscoveredInvocation.prototype.sendMessage = function (data) {
        return this.genericInvocation.sendMessage(data);
    };
    RequestedDiscoveredInvocation.prototype.open = function (observer) {
        return this.genericInvocation.startDiscovered(this.methodReference, observer);
    };
    RequestedDiscoveredInvocation.prototype.close = function (completion) {
        return this.genericInvocation.close(completion);
    };
    RequestedDiscoveredInvocation.prototype.getMetaInfo = function () {
        return this.genericInvocation.getMetaInfo();
    };
    return RequestedDiscoveredInvocation;
}());
exports.RequestedDiscoveredInvocation = RequestedDiscoveredInvocation;
},{}],221:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var RequestedInvocation = /** @class */ (function () {
    function RequestedInvocation(genericInvocation, metaInfo) {
        this.genericInvocation = genericInvocation;
        this.metaInfo = metaInfo;
    }
    RequestedInvocation.prototype.uuid = function () {
        return this.genericInvocation.uuid();
    };
    RequestedInvocation.prototype.sendMessage = function (data) {
        return this.genericInvocation.sendMessage(data);
    };
    RequestedInvocation.prototype.open = function (observer) {
        return this.genericInvocation.start(this.metaInfo, observer);
    };
    RequestedInvocation.prototype.close = function (completion) {
        return this.genericInvocation.close(completion);
    };
    RequestedInvocation.prototype.getMetaInfo = function () {
        return this.genericInvocation.getMetaInfo();
    };
    return RequestedInvocation;
}());
exports.RequestedInvocation = RequestedInvocation;
},{}],222:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var protocol_1 = require("@plexus-interop/protocol");
/**
 * Represents Single Request to Broker
 */
var SingleMessageRequest = /** @class */ (function () {
    function SingleMessageRequest(transportConnection, log) {
        this.transportConnection = transportConnection;
        this.log = log;
    }
    SingleMessageRequest.prototype.execute = function (requestPayload, decodeFn) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        (function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                            var _this = this;
                            var channel_1, error_1;
                            return tslib_1.__generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        _a.trys.push([0, 2, , 3]);
                                        return [4 /*yield*/, this.transportConnection.createChannel()];
                                    case 1:
                                        channel_1 = _a.sent();
                                        channel_1.open({
                                            startFailed: function (e) { return reject(e); },
                                            started: function () {
                                                _this.log.debug('Channel is open, sending connection request');
                                                channel_1.sendLastMessage(requestPayload)
                                                    .then(function (completion) {
                                                    if (!protocol_1.ClientProtocolHelper.isSuccessCompletion(completion)) {
                                                        /* istanbul ignore if */
                                                        if (_this.log.isDebugEnabled()) {
                                                            _this.log.debug('Received non successful completion', completion);
                                                        }
                                                        reject(completion.error);
                                                    }
                                                });
                                            },
                                            next: function (data) {
                                                try {
                                                    _this.log.trace('Received single message response');
                                                    var message = decodeFn(data);
                                                    resolve(message);
                                                }
                                                catch (decodingError) {
                                                    _this.log.error('Unable to decode message', decodingError);
                                                    reject(decodingError);
                                                }
                                            },
                                            complete: function () { return _this.log.debug('Channel closed'); },
                                            error: function (e) { return reject(e); }
                                        });
                                        return [3 /*break*/, 3];
                                    case 2:
                                        error_1 = _a.sent();
                                        this.log.error('Unable to open channel', error_1);
                                        reject(error_1);
                                        return [3 /*break*/, 3];
                                    case 3: return [2 /*return*/];
                                }
                            });
                        }); })();
                    })];
            });
        });
    };
    return SingleMessageRequest;
}());
exports.SingleMessageRequest = SingleMessageRequest;
},{"@plexus-interop/protocol":305,"tslib":180}],223:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
tslib_1.__exportStar(require("./GenericClientFactory"), exports);
tslib_1.__exportStar(require("./GenericClientFactory"), exports);
tslib_1.__exportStar(require("./InvocationObserverConverter"), exports);
},{"./GenericClientFactory":215,"./InvocationObserverConverter":218,"tslib":180}],224:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
tslib_1.__exportStar(require("./generic"), exports);
tslib_1.__exportStar(require("./api"), exports);
},{"./api":213,"./generic":223,"tslib":180}],225:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
tslib_1.__exportStar(require("./client"), exports);
var transport_common_1 = require("@plexus-interop/transport-common");
exports.UniqueId = transport_common_1.UniqueId;
var common_1 = require("@plexus-interop/common");
exports.ReadOnlyCancellationToken = common_1.ReadOnlyCancellationToken;
},{"./client":224,"@plexus-interop/common":243,"@plexus-interop/transport-common":315,"tslib":180}],226:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Temporary Mock Implementation before we agree on final state of returned Remote Peers
 */
var PartialPeerDescriptor = /** @class */ (function () {
    function PartialPeerDescriptor(applicationName, id, isConnected) {
        if (isConnected === void 0) { isConnected = true; }
        this.applicationName = applicationName;
        this.id = id;
        this.isConnected = isConnected;
    }
    PartialPeerDescriptor.prototype.getApiMetadata = function () {
        // TODO
        throw new Error('Method not implemented.');
    };
    PartialPeerDescriptor.prototype.onApiMetadataChanged = function (callback) {
        // TODO
        throw new Error('Method not implemented.');
    };
    return PartialPeerDescriptor;
}());
exports.PartialPeerDescriptor = PartialPeerDescriptor;
},{}],227:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var client_api_1 = require("./api/client-api");
var client_1 = require("@plexus-interop/client");
var listeners_1 = require("./listeners");
var InvokeHandler_1 = require("./actions/InvokeHandler");
var SubscribeHandler_1 = require("./actions/SubscribeHandler");
var DiscoverMethodsHandler_1 = require("./actions/DiscoverMethodsHandler");
var PlexusInteropPeer = /** @class */ (function () {
    function PlexusInteropPeer(genericClientApi, registryService, plexusAppMetadata) {
        this.genericClientApi = genericClientApi;
        this.registryService = registryService;
        this.plexusAppMetadata = plexusAppMetadata;
        this.statusChangedListeners = new listeners_1.ConnectionStatusListeners();
        this.id = this.genericClientApi.getConnectionId().toString();
        this.isConnected = true;
    }
    PlexusInteropPeer.prototype.onConnectionStatusChanged = function (callback) {
        return this.statusChangedListeners.addListener(callback);
    };
    PlexusInteropPeer.prototype.disconnect = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.genericClientApi.disconnect()];
                    case 1:
                        _a.sent();
                        this.statusChangedListeners.notifyListeners(client_api_1.ConnectionStatus.Disconnected);
                        return [2 /*return*/];
                }
            });
        });
    };
    PlexusInteropPeer.prototype.invoke = function (method, args) {
        return new InvokeHandler_1.InvokeHandler(this.registryService, this.genericClientApi, this.plexusAppMetadata).handle(method, args);
    };
    PlexusInteropPeer.prototype.subscribe = function (stream, observer, args) {
        return new SubscribeHandler_1.SubscribeHandler(this.registryService, this.genericClientApi, this.plexusAppMetadata).handle(stream, observer, args);
    };
    PlexusInteropPeer.prototype.discoverMethods = function () {
        return new DiscoverMethodsHandler_1.DiscoverMethodsHandler(this.genericClientApi, this.registryService)
            .discoverMethods(client_1.MethodType.Unary);
    };
    PlexusInteropPeer.prototype.discoverStreams = function () {
        return new DiscoverMethodsHandler_1.DiscoverMethodsHandler(this.genericClientApi, this.registryService)
            .discoverMethods(client_1.MethodType.ServerStreaming);
    };
    // TODO: Not Implemented =>
    PlexusInteropPeer.prototype.onMethodRegistered = function (callback) {
        throw new Error('Method not implemented.');
    };
    PlexusInteropPeer.prototype.onMethodUnregistered = function (callback) {
        throw new Error('Method not implemented.');
    };
    PlexusInteropPeer.prototype.onStreamRegistered = function (callback) {
        throw new Error('Method not implemented.');
    };
    PlexusInteropPeer.prototype.onStreamUnregistered = function (callback) {
        throw new Error('Method not implemented.');
    };
    PlexusInteropPeer.prototype.onPeerConnected = function (callback) {
        throw new Error('Method not implemented.');
    };
    PlexusInteropPeer.prototype.register = function (methodImplementation) {
        throw new Error('Method not implemented.');
    };
    PlexusInteropPeer.prototype.registerStream = function (streamImplementation) {
        throw new Error('Method not implemented.');
    };
    PlexusInteropPeer.prototype.publishApiMetadata = function (apiMetadata) {
        throw new Error('Method not implemented.');
    };
    PlexusInteropPeer.prototype.getApiMetadata = function () {
        throw new Error('Method not implemented.');
    };
    PlexusInteropPeer.prototype.onApiMetadataChanged = function (callback) {
        throw new Error('Method not implemented.');
    };
    PlexusInteropPeer.prototype.onDisconnected = function (callback) {
        throw new Error('Method not implemented.');
    };
    PlexusInteropPeer.prototype.discoverPeers = function () {
        throw new Error('Method not implemented.');
    };
    PlexusInteropPeer.prototype.onPeerDisconnected = function (callback) {
        throw new Error('Method not implemented.');
    };
    return PlexusInteropPeer;
}());
exports.PlexusInteropPeer = PlexusInteropPeer;
},{"./actions/DiscoverMethodsHandler":230,"./actions/InvokeHandler":231,"./actions/SubscribeHandler":232,"./api/client-api":234,"./listeners":235,"@plexus-interop/client":225,"tslib":180}],228:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var client_api_1 = require("./api/client-api");
var client_1 = require("@plexus-interop/client");
var PlexusInteropPeer_1 = require("./PlexusInteropPeer");
var registration_1 = require("./registration");
var PlexusInteropPlatform = /** @class */ (function () {
    function PlexusInteropPlatform(registryService, marshallerProvider, connectionProvider) {
        this.registryService = registryService;
        this.marshallerProvider = marshallerProvider;
        this.connectionProvider = connectionProvider;
        this.type = 'Plexus Interop';
        this.version = '0.0.1';
    }
    PlexusInteropPlatform.prototype.isFeatureSupported = function (feature) {
        switch (feature) {
            case client_api_1.InteropFeature.DiscoverMethods:
            case client_api_1.InteropFeature.DiscoverStreams:
            case client_api_1.InteropFeature.RegisterMethodOnConnect:
            case client_api_1.InteropFeature.RegisterStreamOnConnect:
            case client_api_1.InteropFeature.InvokeMethod:
            case client_api_1.InteropFeature.SubscribeStream:
                return true;
            default:
                return false;
        }
    };
    PlexusInteropPlatform.prototype.connect = function (applicationName, apiMetadata, methods, streams) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            var hostAppMetadata, clientBuilder, genericClient, peer;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        hostAppMetadata = this.registryService.getApplication(applicationName);
                        clientBuilder = new client_1.GenericClientApiBuilder(this.marshallerProvider)
                            .withApplicationId(hostAppMetadata.id)
                            .withTransportConnectionProvider(this.connectionProvider);
                        methods = methods || [];
                        methods.forEach(function (method) { return registration_1.registerMethod(method, clientBuilder, _this.registryService); });
                        streams = streams || [];
                        streams.forEach(function (stream) { return registration_1.registerStream(stream, clientBuilder, _this.registryService); });
                        return [4 /*yield*/, clientBuilder.connect()];
                    case 1:
                        genericClient = _a.sent();
                        peer = new PlexusInteropPeer_1.PlexusInteropPeer(genericClient, this.registryService, hostAppMetadata);
                        peer.disconnect = peer.disconnect.bind(peer);
                        peer.invoke = peer.invoke.bind(peer);
                        peer.subscribe = peer.subscribe.bind(peer);
                        peer.onConnectionStatusChanged = peer.onConnectionStatusChanged.bind(peer);
                        peer.discoverMethods = peer.discoverMethods.bind(peer);
                        peer.discoverStreams = peer.discoverStreams.bind(peer);
                        peer.disconnect = peer.disconnect.bind(peer);
                        return [2 /*return*/, peer];
                }
            });
        });
    };
    return PlexusInteropPlatform;
}());
exports.PlexusInteropPlatform = PlexusInteropPlatform;
},{"./PlexusInteropPeer":227,"./api/client-api":234,"./registration":237,"@plexus-interop/client":225,"tslib":180}],229:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var types_1 = require("../types");
var metadata_1 = require("../metadata");
var client_1 = require("@plexus-interop/client");
var DiscoverMethodHandler = /** @class */ (function () {
    function DiscoverMethodHandler(registryService, genericClienApi, app) {
        this.registryService = registryService;
        this.genericClienApi = genericClienApi;
        this.app = app;
    }
    DiscoverMethodHandler.prototype.findRequestInfo = function (method) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var methodAlias, providedMethod, requestInfo, discovered, methods, providerAppRef_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        methodAlias = types_1.isMethod(method) ? method.name : method;
                        providedMethod = metadata_1.getProvidedMethodByAlias(methodAlias, this.registryService, this.app);
                        return [4 /*yield*/, this.genericClienApi.discoverMethod({
                                consumedMethod: metadata_1.toConsumedMethodRef(providedMethod),
                                discoveryMode: client_1.DiscoveryMode.Online
                            })];
                    case 1:
                        discovered = _a.sent();
                        methods = discovered.methods || [];
                        if (types_1.isMethod(method)) {
                            providerAppRef_1 = this.registryService.getApplication(method.peer.applicationName);
                            methods = methods.filter(function (m) {
                                if (m.providedMethod && m.providedMethod.providedService) {
                                    var id = m.providedMethod.providedService.applicationId;
                                    var connectionId = m.providedMethod.providedService.connectionId;
                                    var connectionIdString = client_1.UniqueId.fromProperties(connectionId).toString();
                                    return id === providerAppRef_1.id && connectionIdString === method.peer.id;
                                }
                                else {
                                    return false;
                                }
                            });
                        }
                        if (methods.length > 0) {
                            requestInfo = methods[0].providedMethod;
                        }
                        else {
                            throw new Error("Handler for action [" + methodAlias + "] is not found");
                        }
                        return [2 /*return*/, requestInfo];
                }
            });
        });
    };
    return DiscoverMethodHandler;
}());
exports.DiscoverMethodHandler = DiscoverMethodHandler;
},{"../metadata":236,"../types":238,"@plexus-interop/client":225,"tslib":180}],230:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var client_api_1 = require("@plexus-interop/client-api");
var metadata_1 = require("../metadata");
var PartialPeerDescriptor_1 = require("../PartialPeerDescriptor");
var protocol_1 = require("@plexus-interop/protocol");
var DiscoverMethodsHandler = /** @class */ (function () {
    function DiscoverMethodsHandler(genericClienApi, registryService) {
        this.genericClienApi = genericClienApi;
        this.registryService = registryService;
    }
    DiscoverMethodsHandler.prototype.discoverMethods = function (type) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            var provided, methods;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.genericClienApi.discoverMethod({
                            discoveryMode: client_api_1.DiscoveryMode.Online
                        })];
                    case 1:
                        provided = _a.sent();
                        methods = provided.methods || [];
                        return [2 /*return*/, methods
                                .filter(function (m) { return !type || type === m.methodType; })
                                .map(function (m) { return _this.plexusMethodToCommon(m); })];
                }
            });
        });
    };
    DiscoverMethodsHandler.prototype.plexusMethodToCommon = function (pm) {
        var providedMethod = pm.providedMethod;
        var providedService = providedMethod.providedService;
        var appId = providedService.applicationId;
        var connectionId = protocol_1.UniqueId.fromProperties(providedService.connectionId).toString();
        return {
            name: metadata_1.getAlias(pm.options) || providedMethod.methodId,
            acceptType: pm.inputMessageId,
            returnType: pm.outputMessageId,
            peer: new PartialPeerDescriptor_1.PartialPeerDescriptor(metadata_1.getAppAliasById(appId, this.registryService) || appId, connectionId)
        };
    };
    return DiscoverMethodsHandler;
}());
exports.DiscoverMethodsHandler = DiscoverMethodsHandler;
},{"../PartialPeerDescriptor":226,"../metadata":236,"@plexus-interop/client-api":190,"@plexus-interop/protocol":305,"tslib":180}],231:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var types_1 = require("../types");
var metadata_1 = require("../metadata");
var DiscoverMethodHandler_1 = require("./DiscoverMethodHandler");
var PartialPeerDescriptor_1 = require("../PartialPeerDescriptor");
var InvokeHandler = /** @class */ (function () {
    function InvokeHandler(registryService, genericClienApi, app) {
        this.registryService = registryService;
        this.genericClienApi = genericClienApi;
        this.app = app;
    }
    InvokeHandler.prototype.handle = function (method, args) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            var methodAlias, providedMethod, requestType, responseType, requestInfo, providerId;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        methodAlias = types_1.isMethod(method) ? method.name : method;
                        providedMethod = metadata_1.getProvidedMethodByAlias(methodAlias, this.registryService, this.app);
                        requestType = providedMethod.method.requestMessage.id;
                        responseType = providedMethod.method.responseMessage.id;
                        return [4 /*yield*/, new DiscoverMethodHandler_1.DiscoverMethodHandler(this.registryService, this.genericClienApi, this.app)
                                .findRequestInfo(method)];
                    case 1:
                        requestInfo = _a.sent();
                        providerId = providedMethod.providedService.application.id;
                        return [2 /*return*/, new Promise(function (resolve, reject) {
                                _this.genericClienApi.sendUnaryRequest(requestInfo, args, {
                                    value: function (v) { return resolve({
                                        result: v,
                                        arguments: args,
                                        method: {
                                            name: methodAlias,
                                            peer: new PartialPeerDescriptor_1.PartialPeerDescriptor(metadata_1.getAppAliasById(providerId, _this.registryService) || providerId, providerId)
                                        }
                                    }); },
                                    error: function (e) { return reject(e); }
                                }, requestType, responseType);
                            })];
                }
            });
        });
    };
    return InvokeHandler;
}());
exports.InvokeHandler = InvokeHandler;
},{"../PartialPeerDescriptor":226,"../metadata":236,"../types":238,"./DiscoverMethodHandler":229,"tslib":180}],232:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var types_1 = require("../types");
var metadata_1 = require("../metadata");
var DiscoverMethodHandler_1 = require("./DiscoverMethodHandler");
var SubscribeHandler = /** @class */ (function () {
    function SubscribeHandler(registryService, genericClienApi, app) {
        this.registryService = registryService;
        this.genericClienApi = genericClienApi;
        this.app = app;
    }
    SubscribeHandler.prototype.handle = function (method, observer, args) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            var asyncNop, methodAlias, providedMethod, requestType, responseType, requestInfo, invocation;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        asyncNop = function () { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
                            return [2 /*return*/];
                        }); }); };
                        observer.next = observer.next || asyncNop;
                        observer.error = observer.error || asyncNop;
                        observer.completed = observer.completed || asyncNop;
                        methodAlias = types_1.isMethod(method) ? method.name : method;
                        providedMethod = metadata_1.getProvidedMethodByAlias(methodAlias, this.registryService, this.app);
                        requestType = providedMethod.method.requestMessage.id;
                        responseType = providedMethod.method.responseMessage.id;
                        return [4 /*yield*/, new DiscoverMethodHandler_1.DiscoverMethodHandler(this.registryService, this.genericClienApi, this.app)
                                .findRequestInfo(method)];
                    case 1:
                        requestInfo = _a.sent();
                        return [4 /*yield*/, this.genericClienApi.sendServerStreamingRequest(requestInfo, args, {
                                next: function (v) { return observer.next(v); },
                                error: function (e) { return observer.error(e); },
                                streamCompleted: function () { return observer.completed(); },
                                complete: function () { }
                            }, requestType, responseType)];
                    case 2:
                        invocation = _a.sent();
                        return [2 /*return*/, {
                                arguments: args,
                                unsubscribe: function () { return invocation.cancel(); },
                                stream: metadata_1.toMethodDefinition(providedMethod)
                            }];
                }
            });
        });
    };
    return SubscribeHandler;
}());
exports.SubscribeHandler = SubscribeHandler;
},{"../metadata":236,"../types":238,"./DiscoverMethodHandler":229,"tslib":180}],233:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var websocket_transport_1 = require("@plexus-interop/websocket-transport");
var metadata_1 = require("@plexus-interop/metadata");
var dynamic_1 = require("@plexus-interop/io/dist/main/src/dynamic");
var PlexusInteropPlatform_1 = require("../PlexusInteropPlatform");
var detect_1 = require("@plexus-interop/common/dist/main/src/ws/detect");
var remote_1 = require("@plexus-interop/remote");
var InteropPlatformFactory = /** @class */ (function () {
    function InteropPlatformFactory() {
    }
    InteropPlatformFactory.prototype.createPlatform = function (config) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            var wsCtor, metadataWsUrl, connectionProvider, interopProvider, marshallerProvider;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        wsCtor = detect_1.webSocketCtor();
                        metadataWsUrl = config.webSocketUrl + "/metadata/interop";
                        connectionProvider = function () { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
                            return [2 /*return*/, new websocket_transport_1.WebSocketConnectionFactory(new wsCtor(config.webSocketUrl)).connect()];
                        }); }); };
                        interopProvider = new metadata_1.UrlInteropRegistryProvider(metadataWsUrl, -1, new remote_1.WebSocketDataProvider(detect_1.webSocketCtor()));
                        return [4 /*yield*/, interopProvider.start()];
                    case 1:
                        _a.sent();
                        marshallerProvider = new dynamic_1.DynamicBinaryMarshallerProvider(interopProvider.getCurrent());
                        return [2 /*return*/, new PlexusInteropPlatform_1.PlexusInteropPlatform(new metadata_1.InteropRegistryService(interopProvider), marshallerProvider, connectionProvider)];
                }
            });
        });
    };
    return InteropPlatformFactory;
}());
exports.InteropPlatformFactory = InteropPlatformFactory;
},{"../PlexusInteropPlatform":228,"@plexus-interop/common/dist/main/src/ws/detect":273,"@plexus-interop/io/dist/main/src/dynamic":280,"@plexus-interop/metadata":287,"@plexus-interop/remote":309,"@plexus-interop/websocket-transport":336,"tslib":180}],234:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var InteropFeature;
(function (InteropFeature) {
    InteropFeature["InvokeMethod"] = "InvokeMethod";
    InteropFeature["SubscribeStream"] = "SubscribeStream";
    InteropFeature["RegisterMethod"] = "RegisterMethod";
    InteropFeature["RegisterMethodOnConnect"] = "RegisterMethodOnConnect";
    InteropFeature["RegisterStream"] = "RegisterStream";
    InteropFeature["RegisterStreamOnConnect"] = "RegisterStreamOnConnect";
    InteropFeature["DiscoverPeers"] = "DiscoverPeers";
    InteropFeature["DiscoverMethods"] = "DiscoverMethods";
    InteropFeature["DiscoverStreams"] = "DiscoverStreams";
    InteropFeature["ListenPeerConnected"] = "ListenPeerConnected";
    InteropFeature["ListenMethodRegistered"] = "ListenMethodRegistered";
    InteropFeature["ListenStreamRegistered"] = "ListenStreamRegistered";
})(InteropFeature = exports.InteropFeature || (exports.InteropFeature = {}));
/**
 * Specifies the Peer's connection statuses.
 * State diagram:
+---------------------------------------------+
|                                             |
| Disconnected+---->Connecting+---->Connected |
|      ^                +               +     |
|      |                |               |     |
|      ^----------------+               |     |
|      |                                |     |
|      +                                |     |
| Disconnecting<------------------------+     |
|                                             |
+---------------------------------------------+
 */
var ConnectionStatus;
(function (ConnectionStatus) {
    ConnectionStatus["Connecting"] = "Connecting";
    ConnectionStatus["Connected"] = "Connected";
    ConnectionStatus["Disconnecting"] = "Disconnecting";
    ConnectionStatus["Disconnected"] = "Disconnected";
})(ConnectionStatus = exports.ConnectionStatus || (exports.ConnectionStatus = {}));
},{}],235:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var common_1 = require("@plexus-interop/common");
var logger = common_1.LoggerFactory.getLogger('PeerListener');
var GenericListenerHolder = /** @class */ (function () {
    function GenericListenerHolder() {
        this.listeners = [];
    }
    GenericListenerHolder.prototype.addListener = function (callback) {
        var _this = this;
        this.listeners.push(callback);
        return {
            unsubscribe: function () { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.removeListener(callback)];
            }); }); }
        };
    };
    GenericListenerHolder.prototype.notifyListeners = function (update) {
        this.listeners.forEach(function (l) {
            try {
                l(update);
            }
            catch (error) {
                logger.warn('Listener raised error', error);
            }
        });
    };
    GenericListenerHolder.prototype.reset = function () {
        this.listeners.length = 0;
    };
    GenericListenerHolder.prototype.removeListener = function (callback) {
        this.listeners = this.listeners.filter(function (l) { return l !== callback; });
    };
    return GenericListenerHolder;
}());
exports.GenericListenerHolder = GenericListenerHolder;
var ConnectionStatusListeners = /** @class */ (function (_super) {
    tslib_1.__extends(ConnectionStatusListeners, _super);
    function ConnectionStatusListeners() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ConnectionStatusListeners;
}(GenericListenerHolder));
exports.ConnectionStatusListeners = ConnectionStatusListeners;
var ErrorListeners = /** @class */ (function (_super) {
    tslib_1.__extends(ErrorListeners, _super);
    function ErrorListeners() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ErrorListeners;
}(GenericListenerHolder));
exports.ErrorListeners = ErrorListeners;
},{"@plexus-interop/common":243,"tslib":180}],236:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var PartialPeerDescriptor_1 = require("./PartialPeerDescriptor");
var isAliasOption = function (o) { return o.id.endsWith('alias'); };
function getProvidedMethodByAlias(actionAlias, registryService, consumerAppMetadata) {
    var methods = !!consumerAppMetadata ?
        registryService.getMatchingProvidedMethodsForApp(consumerAppMetadata)
        : registryService.getProvidedMethods();
    var provideMethod = methods.find(function (pm) { return !!pm.options && !!pm.options.find(function (o) { return isAliasOption(o) && o.value === actionAlias; }); });
    if (!provideMethod) {
        throw new Error("Provided Method not found for " + actionAlias);
    }
    return provideMethod;
}
exports.getProvidedMethodByAlias = getProvidedMethodByAlias;
function getAppAliasById(appId, registryService) {
    var app = registryService.getApplication(appId);
    return getAlias(app.options);
}
exports.getAppAliasById = getAppAliasById;
function toConsumedMethodRef(providedMethod) {
    return {
        consumedService: {
            serviceId: providedMethod.providedService.service.id,
            serviceAlias: providedMethod.providedService.service.serviceAlias
        },
        methodId: providedMethod.method.name
    };
}
exports.toConsumedMethodRef = toConsumedMethodRef;
function toMethodDefinition(providedMethod) {
    return {
        name: providedMethod.method.name,
        peer: new PartialPeerDescriptor_1.PartialPeerDescriptor(providedMethod.providedService.application.id, providedMethod.providedService.application.id, false)
    };
}
exports.toMethodDefinition = toMethodDefinition;
function getAlias(options) {
    if (!!options) {
        var option = options.find(isAliasOption);
        if (option) {
            return option.value;
        }
    }
    return undefined;
}
exports.getAlias = getAlias;
},{"./PartialPeerDescriptor":226}],237:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var metadata_1 = require("./metadata");
var PartialPeerDescriptor_1 = require("./PartialPeerDescriptor");
var protocol_1 = require("@plexus-interop/protocol");
function registerMethod(commonApiMethod, clientBuilder, registryService) {
    var _this = this;
    var providedMethod = metadata_1.getProvidedMethodByAlias(commonApiMethod.name, registryService);
    var requestType = providedMethod.method.requestMessage.id;
    var responseType = providedMethod.method.responseMessage.id;
    clientBuilder.withTypeAwareUnaryHandler({
        serviceInfo: {
            serviceId: providedMethod.providedService.service.id,
            serviceAlias: providedMethod.providedService.alias
        },
        methodId: providedMethod.method.name,
        handle: function (invocationContext, request) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var appId, response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        appId = invocationContext.consumerApplicationId;
                        return [4 /*yield*/, (commonApiMethod.onInvoke(request, new PartialPeerDescriptor_1.PartialPeerDescriptor(metadata_1.getAppAliasById(appId, registryService) || appId, appId)) /* Return empty result if no response received */ || Promise.resolve({}))];
                    case 1:
                        response = _a.sent();
                        return [2 /*return*/, response];
                }
            });
        }); }
    }, requestType, responseType);
}
exports.registerMethod = registerMethod;
function registerStream(commonApiStream, clientBuilder, registryService) {
    var _this = this;
    var providedMethod = metadata_1.getProvidedMethodByAlias(commonApiStream.name, registryService);
    var requestType = providedMethod.method.requestMessage.id;
    var responseType = providedMethod.method.responseMessage.id;
    clientBuilder.withTypeAwareServerStreamingHandler({
        serviceInfo: {
            serviceId: providedMethod.providedService.service.id,
            serviceAlias: providedMethod.providedService.alias
        },
        methodId: providedMethod.method.name,
        handle: function (invocationContext, request, invocationHostClient) {
            var appId = invocationContext.consumerApplicationId;
            var consumerPeer = new PartialPeerDescriptor_1.PartialPeerDescriptor(metadata_1.getAppAliasById(appId, registryService) || appId, appId);
            var subscriptionPromise = commonApiStream.onSubscriptionRequested({
                next: function (v) { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
                    return [2 /*return*/, invocationHostClient.next(v)];
                }); }); },
                error: function (e) { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
                    return [2 /*return*/, invocationHostClient.error(new protocol_1.ClientError(e.message, e.stack))];
                }); }); },
                completed: function () { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
                    return [2 /*return*/, invocationHostClient.complete()];
                }); }); }
            }, consumerPeer, request);
            if (subscriptionPromise) {
                subscriptionPromise.then(function (subscription) {
                    invocationContext.cancellationToken.onCancel(function () { return subscription.unsubscribe(); });
                })
                    .catch(function (e) { return invocationHostClient.error(new protocol_1.ClientError(e.message, e.stack)); });
            }
        }
    }, requestType, responseType);
}
exports.registerStream = registerStream;
},{"./PartialPeerDescriptor":226,"./metadata":236,"@plexus-interop/protocol":305,"tslib":180}],238:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isMethod(m) {
    return !!m.peer;
}
exports.isMethod = isMethod;
},{}],239:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var CacheEntry = /** @class */ (function () {
    function CacheEntry(value, ttl, onEvict) {
        if (ttl === void 0) { ttl = -1; }
        if (onEvict === void 0) { onEvict = function () { }; }
        this.value = value;
        this.ttl = ttl;
        this.onEvict = onEvict;
    }
    return CacheEntry;
}());
exports.CacheEntry = CacheEntry;
},{}],240:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var CacheEntryDescriptor = /** @class */ (function () {
    function CacheEntryDescriptor(entry, expirationTime, cleanUpTimeOutId) {
        this.entry = entry;
        this.expirationTime = expirationTime;
        this.cleanUpTimeOutId = cleanUpTimeOutId;
    }
    return CacheEntryDescriptor;
}());
exports.CacheEntryDescriptor = CacheEntryDescriptor;
},{}],241:[function(require,module,exports){
(function (global){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var CacheEntryDescriptor_1 = require("./CacheEntryDescriptor");
var logger_1 = require("../logger");
var globalObj = typeof window !== 'undefined' ? window : global;
var InMemoryCache = /** @class */ (function () {
    function InMemoryCache() {
        this.log = logger_1.LoggerFactory.getLogger('InMemoryCache');
        this.storage = new Map();
    }
    InMemoryCache.prototype.set = function (key, entry) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            var existing, cleanUpTimeout;
            return tslib_1.__generator(this, function (_a) {
                existing = this.storage.get(key);
                if (existing) {
                    this.log.trace(key + " already exist, cleaning up and calling dispose");
                    clearTimeout(existing.cleanUpTimeOutId);
                    existing.entry.onEvict(existing.entry.value);
                }
                cleanUpTimeout = -1;
                if (entry.ttl > 0) {
                    cleanUpTimeout = globalObj.setTimeout(function () { return _this.cleanEntry(key); }, entry.ttl);
                }
                this.storage.set(key, new CacheEntryDescriptor_1.CacheEntryDescriptor(entry, entry.ttl > 0 ? Date.now() + entry.ttl : -1, cleanUpTimeout));
                return [2 /*return*/];
            });
        });
    };
    InMemoryCache.prototype.resetTtl = function (key) {
        var _this = this;
        var descriptor = this.storage.get(key);
        if (descriptor && descriptor.entry.ttl > 0) {
            clearTimeout(descriptor.cleanUpTimeOutId);
            descriptor.cleanUpTimeOutId =
                globalObj.setTimeout(function () { return _this.cleanEntry(key); }, descriptor.entry.ttl);
        }
        return false;
    };
    InMemoryCache.prototype.has = function (key) {
        return this.storage.has(key);
    };
    InMemoryCache.prototype.keys = function () {
        var result = [];
        this.storage.forEach(function (v, k) { return result.push(k); });
        return result;
    };
    InMemoryCache.prototype.get = function (key) {
        var descriptor = this.storage.get(key);
        if (descriptor) {
            return descriptor.entry.value;
        }
        else {
            return undefined;
        }
    };
    InMemoryCache.prototype.cleanEntry = function (key) {
        var descriptor = this.storage.get(key);
        if (descriptor) {
            this.log.trace("[" + descriptor.entry.ttl + "] passed for [" + key + "] element, cleaning up");
            descriptor.entry.onEvict(descriptor.entry.value);
            this.storage.delete(key);
        }
    };
    return InMemoryCache;
}());
exports.InMemoryCache = InMemoryCache;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../logger":247,"./CacheEntryDescriptor":240,"tslib":180}],242:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./CacheEntry"), exports);
tslib_1.__exportStar(require("./InMemoryCache"), exports);
},{"./CacheEntry":239,"./InMemoryCache":241,"tslib":180}],243:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
tslib_1.__exportStar(require("./util"), exports);
tslib_1.__exportStar(require("./logger"), exports);
tslib_1.__exportStar(require("./rx"), exports);
tslib_1.__exportStar(require("./cache"), exports);
},{"./cache":242,"./logger":247,"./rx":251,"./util":266,"tslib":180}],244:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var log = require("loglevel");
var LoggerFactory_1 = require("./LoggerFactory");
var LoggerBase = /** @class */ (function () {
    function LoggerBase(name, loggerDelegates) {
        this.name = name;
        this.loggerDelegates = loggerDelegates;
    }
    LoggerBase.prototype.debug = function (msg) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        /* istanbul ignore if */
        if (log.getLevel() <= LoggerFactory_1.LogLevel.DEBUG) {
            this.log(LoggerFactory_1.LogLevel.DEBUG, msg, args);
        }
    };
    LoggerBase.prototype.info = function (msg) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        this.log(LoggerFactory_1.LogLevel.INFO, msg, args);
    };
    LoggerBase.prototype.error = function (msg) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        this.log(LoggerFactory_1.LogLevel.ERROR, msg, args);
    };
    LoggerBase.prototype.warn = function (msg) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        this.log(LoggerFactory_1.LogLevel.INFO, msg, args);
    };
    LoggerBase.prototype.trace = function (msg) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        /* istanbul ignore if */
        if (log.getLevel() <= LoggerFactory_1.LogLevel.TRACE) {
            this.log(LoggerFactory_1.LogLevel.TRACE, msg, args);
        }
    };
    LoggerBase.prototype.log = function (logLevel, msg, args) {
        var actualMessage = this.name + " " + msg;
        switch (logLevel) {
            case LoggerFactory_1.LogLevel.TRACE:
                log.trace(actualMessage, args);
                break;
            case LoggerFactory_1.LogLevel.DEBUG:
                log.debug(actualMessage, args);
                break;
            case LoggerFactory_1.LogLevel.INFO:
                log.info(actualMessage, args);
                break;
            case LoggerFactory_1.LogLevel.WARN:
                log.warn(actualMessage, args);
                break;
            case LoggerFactory_1.LogLevel.ERROR:
                log.warn(actualMessage, args);
                break;
            case LoggerFactory_1.LogLevel.SILENT:
                /* be silent */
                break;
            default:
                throw "Unkown LogLevel: " + logLevel;
        }
        try {
            this.loggerDelegates.forEach(function (logger) { return logger.log(logLevel, msg, args); });
        }
        catch (error) {
            this.error("Error in log delegates: " + error + ". Swallowed.");
        }
    };
    LoggerBase.prototype.getLogLevel = function () {
        return log.getLevel();
    };
    LoggerBase.prototype.isDebugEnabled = function () {
        return this.getLogLevel() <= LoggerFactory_1.LogLevel.DEBUG;
    };
    LoggerBase.prototype.isTraceEnabled = function () {
        return this.getLogLevel() <= LoggerFactory_1.LogLevel.TRACE;
    };
    return LoggerBase;
}());
exports.LoggerBase = LoggerBase;
},{"./LoggerFactory":245,"loglevel":81}],245:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("loglevel");
var LoggerBase_1 = require("./LoggerBase");
var TimeUtils_1 = require("../util/time/TimeUtils");
var logPrefixer = require('loglevel-plugin-prefix');
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["TRACE"] = 0] = "TRACE";
    LogLevel[LogLevel["DEBUG"] = 1] = "DEBUG";
    LogLevel[LogLevel["INFO"] = 2] = "INFO";
    LogLevel[LogLevel["WARN"] = 3] = "WARN";
    LogLevel[LogLevel["ERROR"] = 4] = "ERROR";
    LogLevel[LogLevel["SILENT"] = 5] = "SILENT";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
var LoggerFactory = /** @class */ (function () {
    function LoggerFactory() {
    }
    LoggerFactory.registerDelegate = function (logger) {
        var newRecipientsLen = LoggerFactory.additionalRecipients.push(logger);
        var registeredRecipientIndex = newRecipientsLen - 1;
        return {
            unregister: function () { return LoggerFactory.additionalRecipients = LoggerFactory.additionalRecipients.splice(registeredRecipientIndex, 1); }
        };
    };
    LoggerFactory.getLogger = function (name) {
        if (name === void 0) { name = 'Anonymous'; }
        return new LoggerBase_1.LoggerBase(name, this.additionalRecipients);
    };
    LoggerFactory.setLogLevel = function (level) {
        /* istanbul ignore if */
        if (level <= LogLevel.DEBUG) {
            logPrefixer.apply(log, {
                template: '%t | [%l] ',
                timestampFormatter: function (date) { return TimeUtils_1.TimeUtils.format(date); }
            });
        }
        log.setLevel(level);
    };
    LoggerFactory.additionalRecipients = [];
    return LoggerFactory;
}());
exports.LoggerFactory = LoggerFactory;
LoggerFactory.setLogLevel(LogLevel.INFO);
},{"../util/time/TimeUtils":270,"./LoggerBase":244,"loglevel":81,"loglevel-plugin-prefix":80}],246:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _1 = require(".");
var PrefixedLogger = /** @class */ (function () {
    function PrefixedLogger(base, prefix) {
        if (prefix === void 0) { prefix = ''; }
        this.base = base;
        this.prefix = prefix;
    }
    PrefixedLogger.prototype.trace = function (msg) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        this.base.trace(this.prefix + " " + msg, args);
    };
    PrefixedLogger.prototype.warn = function (msg) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        this.base.trace(this.prefix + " " + msg, args);
    };
    PrefixedLogger.prototype.error = function (msg) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        this.base.error(this.prefix + " " + msg, args);
    };
    PrefixedLogger.prototype.info = function (msg) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        this.base.info(this.prefix + " " + msg, args);
    };
    PrefixedLogger.prototype.debug = function (msg) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        this.base.debug(this.prefix + " " + msg, args);
    };
    PrefixedLogger.prototype.getLogLevel = function () {
        return this.base.getLogLevel();
    };
    PrefixedLogger.prototype.isDebugEnabled = function () {
        return this.base.getLogLevel() <= _1.LogLevel.DEBUG;
    };
    PrefixedLogger.prototype.isTraceEnabled = function () {
        return this.base.getLogLevel() <= _1.LogLevel.TRACE;
    };
    return PrefixedLogger;
}());
exports.PrefixedLogger = PrefixedLogger;
},{".":247}],247:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./LoggerFactory"), exports);
tslib_1.__exportStar(require("./PrefixedLogger"), exports);
},{"./LoggerFactory":245,"./PrefixedLogger":246,"tslib":180}],248:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AnonymousSubscription = /** @class */ (function () {
    function AnonymousSubscription(unsubscribe) {
        if (unsubscribe === void 0) { unsubscribe = function () { }; }
        this.unsubscribe = unsubscribe;
    }
    return AnonymousSubscription;
}());
exports.AnonymousSubscription = AnonymousSubscription;
},{}],249:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var logger_1 = require("../logger");
var LimitedBufferQueue_1 = require("../util/collections/LimitedBufferQueue");
/**
 * Saves interraction with Observer, until real Observer arrives
 */
var BufferedObserver = /** @class */ (function () {
    function BufferedObserver(limit, log) {
        if (limit === void 0) { limit = 1024 * 10; }
        if (log === void 0) { log = logger_1.LoggerFactory.getLogger('BufferedObserver'); }
        this.limit = limit;
        this.log = log;
        this.completed = false;
        this.buffer = new LimitedBufferQueue_1.LimitedBufferQueue(limit);
    }
    BufferedObserver.prototype.setObserver = function (observer) {
        if (this.baseObserver) {
            throw new Error('Base observer already defined');
        }
        this.baseObserver = observer;
        while (!this.buffer.isEmpty()) {
            observer.next(this.buffer.dequeue());
        }
        if (this.receivedError) {
            observer.error(this.receivedError);
        }
        else if (this.completed) {
            observer.complete();
        }
    };
    BufferedObserver.prototype.next = function (value) {
        if (this.baseObserver) {
            /* istanbul ignore if */
            if (this.log.isTraceEnabled()) {
                this.log.trace("Passing frame to observer");
            }
            this.baseObserver.next(value);
        }
        else {
            /* istanbul ignore if */
            if (this.log.isTraceEnabled()) {
                this.log.trace("No observer, adding to buffer, buffer size " + this.buffer.size());
            }
            this.buffer.enqueue(value);
        }
    };
    BufferedObserver.prototype.error = function (err) {
        if (this.baseObserver) {
            this.baseObserver.error(err);
        }
        else {
            this.receivedError = err;
        }
    };
    BufferedObserver.prototype.complete = function () {
        if (this.baseObserver) {
            this.baseObserver.complete();
        }
        else {
            this.completed = true;
        }
    };
    BufferedObserver.prototype.clear = function () {
        this.buffer.clear();
    };
    return BufferedObserver;
}());
exports.BufferedObserver = BufferedObserver;
},{"../logger":247,"../util/collections/LimitedBufferQueue":263}],250:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ConversionObserver = /** @class */ (function () {
    function ConversionObserver(source, converter) {
        this.source = source;
        this.converter = converter;
    }
    ConversionObserver.prototype.next = function (value) {
        var after = this.converter(value);
        this.source.next(after);
    };
    ConversionObserver.prototype.error = function (err) {
        this.source.error(err);
    };
    ConversionObserver.prototype.complete = function () {
        this.source.complete();
    };
    return ConversionObserver;
}());
exports.ConversionObserver = ConversionObserver;
},{}],251:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
tslib_1.__exportStar(require("./ConversionObserver"), exports);
tslib_1.__exportStar(require("./BufferedObserver"), exports);
tslib_1.__exportStar(require("./AnonymousSubscription"), exports);
},{"./AnonymousSubscription":248,"./BufferedObserver":249,"./ConversionObserver":250,"tslib":180}],252:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ExtendedMap_1 = require("./collections/ExtendedMap");
var Arrays = /** @class */ (function () {
    function Arrays() {
    }
    Arrays.concatenateBuffers = function () {
        var buffers = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            buffers[_i] = arguments[_i];
        }
        var totalLength = buffers.reduce(function (acc, b) { return acc + b.byteLength; }, 0);
        var result = new Uint8Array(totalLength);
        var offset = 0;
        buffers.forEach(function (b) {
            result.set(new Uint8Array(b), offset);
            offset += b.byteLength;
        });
        return result.buffer;
    };
    Arrays.toArrayBuffer = function (typedArray) {
        return new Uint8Array(typedArray).buffer;
    };
    return Arrays;
}());
exports.Arrays = Arrays;
function arrayBufferToString(buf) {
    var binaryString = '';
    var bytes = new Uint8Array(buf);
    var length = bytes.length;
    for (var i = 0; i < length; i++) {
        binaryString += String.fromCharCode(bytes[i]);
    }
    return binaryString;
}
exports.arrayBufferToString = arrayBufferToString;
function stringToArrayBuffer(str) {
    var buf = new ArrayBuffer(str.length);
    var bufView = new Uint8Array(buf);
    for (var i = 0, strLen = str.length; i < strLen; i++) {
        bufView[i] = str.charCodeAt(i);
    }
    return buf;
}
exports.stringToArrayBuffer = stringToArrayBuffer;
function concat(x, y) {
    return x.concat(y);
}
exports.concat = concat;
function flatMap(f, array) {
    return array.map(f).reduce(concat, []);
}
exports.flatMap = flatMap;
function join(first, second, joinFn, predicate) {
    if (predicate === void 0) { predicate = function () { return true; }; }
    var result = [];
    first.forEach(function (x) { return second.forEach(function (y) {
        if (predicate(x, y)) {
            result.push(joinFn(x, y));
        }
    }); });
    return result;
}
exports.join = join;
function distinct(array, key) {
    var seen = new Set();
    return array.filter(function (item) {
        var k = key(item);
        return seen.has(k) ? false : seen.add(k);
    });
}
exports.distinct = distinct;
function toMap(array, keyFn, vFn) {
    var result = ExtendedMap_1.ExtendedMap.create();
    array.forEach(function (v) { return result.set(keyFn(v), vFn(v)); });
    return result;
}
exports.toMap = toMap;
},{"./collections/ExtendedMap":262}],253:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Arrays_1 = require("./Arrays");
/**
 * Provides few additional utility methods for array modification, immutable, all operations create new instance
 */
var ExtendedArray = /** @class */ (function () {
    function ExtendedArray(values) {
        this.values = values;
    }
    ExtendedArray.of = function (values) {
        return new ExtendedArray(values);
    };
    ExtendedArray.prototype.joinWith = function (second, joinFn, predicate) {
        if (predicate === void 0) { predicate = function () { return true; }; }
        return ExtendedArray.of(Arrays_1.join(this.values, second, joinFn, predicate));
    };
    ExtendedArray.prototype.distinct = function (key) {
        if (key === void 0) { key = function (x) { return x; }; }
        return ExtendedArray.of(Arrays_1.distinct(this.values, key));
    };
    ExtendedArray.prototype.toArray = function () {
        return this.values;
    };
    ExtendedArray.prototype.flatMap = function (f) {
        return ExtendedArray.of(this.values.map(f).reduce(Arrays_1.concat, []));
    };
    ExtendedArray.prototype.toMap = function (keyFn, vFn) {
        return Arrays_1.toMap(this.values, keyFn, vFn);
    };
    return ExtendedArray;
}());
exports.ExtendedArray = ExtendedArray;
},{"./Arrays":252}],254:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var GUID = /** @class */ (function () {
    function GUID(str) {
        this.str = str || GUID.getNewGUIDString();
    }
    GUID.getNewGUIDString = function () {
        var d = new Date().getTime();
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            var r = (d + Math.random() * 16) % 16 | 0;
            d = Math.floor(d / 16);
            return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
        });
    };
    GUID.prototype.toString = function () {
        return this.str;
    };
    return GUID;
}());
exports.GUID = GUID;
},{}],255:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var CancellationToken_1 = require("./CancellationToken");
var AsyncHelper = /** @class */ (function () {
    function AsyncHelper() {
    }
    AsyncHelper.waitFor = function (condition, cancellationToken, interval, timeout) {
        if (cancellationToken === void 0) { cancellationToken = new CancellationToken_1.CancellationToken(); }
        if (interval === void 0) { interval = AsyncHelper.STATUS_CHECK_INTERVAL; }
        if (timeout === void 0) { timeout = -1; }
        return new Promise(function (resolve, reject) {
            var rejectTimeout;
            var checkTimeout;
            if (timeout > 0) {
                rejectTimeout = setTimeout(function () {
                    if (checkTimeout) {
                        clearTimeout(checkTimeout);
                    }
                    reject("Waiting timeout " + timeout + "ms passed");
                }, timeout);
            }
            function success() {
                if (rejectTimeout) {
                    clearTimeout(rejectTimeout);
                }
                resolve();
            }
            function check() {
                var result = condition();
                if (result) {
                    success();
                }
                else if (cancellationToken.isCancelled()) {
                    reject(cancellationToken.getReason());
                }
                else {
                    checkTimeout = setTimeout(check, interval);
                }
            }
            check();
        });
    };
    AsyncHelper.STATUS_CHECK_INTERVAL = 0;
    return AsyncHelper;
}());
exports.AsyncHelper = AsyncHelper;
},{"./CancellationToken":256}],256:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var logger_1 = require("../../logger");
var logger = logger_1.LoggerFactory.getLogger('CancellationToken');
var CancellationToken = /** @class */ (function () {
    function CancellationToken(baseToken) {
        this.baseToken = baseToken;
        this.cancelled = false;
        this.reason = 'Not defined';
        this.listeners = [];
    }
    CancellationToken.prototype.throwIfCanceled = function () {
        if (this.isCancelled()) {
            throw Error(this.getReason());
        }
    };
    CancellationToken.prototype.onCancel = function (callback) {
        if (this.listeners.indexOf(callback) === -1) {
            this.listeners.push(callback);
        }
    };
    CancellationToken.prototype.isCancelled = function () {
        if (this.baseToken) {
            return this.cancelled || this.baseToken.isCancelled();
        }
        else {
            return this.cancelled;
        }
    };
    CancellationToken.prototype.cancel = function (reason) {
        if (reason === void 0) { reason = 'Operation cancelled'; }
        if (!this.cancelled) {
            this.reason = reason;
            this.listeners.forEach(function (listener) {
                try {
                    listener(reason);
                }
                catch (error) {
                    logger.warn('Cancellation listener raised error', error);
                }
            });
            this.cancelled = true;
        }
    };
    CancellationToken.prototype.getReason = function () {
        return this.baseToken && this.baseToken.cancelled ? this.baseToken.getReason() : this.reason;
    };
    return CancellationToken;
}());
exports.CancellationToken = CancellationToken;
},{"../../logger":247}],257:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ReadOnlyCancellationToken = /** @class */ (function () {
    function ReadOnlyCancellationToken() {
    }
    return ReadOnlyCancellationToken;
}());
exports.ReadOnlyCancellationToken = ReadOnlyCancellationToken;
},{}],258:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var CancellationToken_1 = require("./CancellationToken");
var ReadWriteCancellationToken = /** @class */ (function () {
    function ReadWriteCancellationToken(readToken, writeToken) {
        if (readToken === void 0) { readToken = new CancellationToken_1.CancellationToken(); }
        if (writeToken === void 0) { writeToken = new CancellationToken_1.CancellationToken(); }
        this.readToken = readToken;
        this.writeToken = writeToken;
    }
    ReadWriteCancellationToken.prototype.cancelRead = function (reason) {
        if (reason === void 0) { reason = 'Read cancelled'; }
        this.readToken.cancel(reason);
    };
    ReadWriteCancellationToken.prototype.cancelWrite = function (reason) {
        if (reason === void 0) { reason = 'Write cancelled'; }
        this.writeToken.cancel(reason);
    };
    ReadWriteCancellationToken.prototype.throwIfCanceled = function () {
        if (this.isCancelled()) {
            throw Error(this.readToken.getReason() || this.writeToken.getReason() || 'Cancelled');
        }
    };
    ReadWriteCancellationToken.prototype.isCancelled = function () {
        return this.readToken.isCancelled() && this.writeToken.isCancelled();
    };
    ReadWriteCancellationToken.prototype.cancel = function (reason) {
        if (reason === void 0) { reason = 'Cancelled'; }
        this.cancelRead(reason);
        this.cancelWrite(reason);
    };
    ReadWriteCancellationToken.prototype.isReadCancelled = function () {
        return this.readToken.isCancelled();
    };
    ReadWriteCancellationToken.prototype.isWriteCancelled = function () {
        return this.writeToken.isCancelled();
    };
    ReadWriteCancellationToken.prototype.getReadToken = function () {
        return this.readToken;
    };
    ReadWriteCancellationToken.prototype.getWriteToken = function () {
        return this.writeToken;
    };
    return ReadWriteCancellationToken;
}());
exports.ReadWriteCancellationToken = ReadWriteCancellationToken;
},{"./CancellationToken":256}],259:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Queue_1 = require("typescript-collections/dist/lib/Queue");
var AsyncHelper_1 = require("./AsyncHelper");
var LoggerFactory_1 = require("../../logger/LoggerFactory");
var SequencedExecutor = /** @class */ (function () {
    function SequencedExecutor(log) {
        if (log === void 0) { log = LoggerFactory_1.LoggerFactory.getLogger('SequencedExecutor'); }
        this.log = log;
        this.outQueue = new Queue_1.default();
        this.currentId = 0;
    }
    SequencedExecutor.prototype.submit = function (task) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            var id;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        id = ++this.currentId;
                        /* istanbul ignore if */
                        if (this.log.isTraceEnabled()) {
                            this.log.trace("Scheduling [" + id + "] task");
                        }
                        this.outQueue.enqueue({
                            id: this.currentId,
                            task: task
                        });
                        if (!(this.outQueue.size() > 1)) return [3 /*break*/, 2];
                        /* istanbul ignore if */
                        if (this.log.isTraceEnabled()) {
                            this.log.trace("Waiting for [" + id + "] task to execute");
                        }
                        return [4 /*yield*/, AsyncHelper_1.AsyncHelper.waitFor(function () { return _this.outQueue.peek().id === id; })];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, , 4, 5]);
                        /* istanbul ignore if */
                        if (this.log.isTraceEnabled()) {
                            this.log.trace("Executing [" + id + "] task");
                        }
                        return [4 /*yield*/, this.outQueue.peek().task()];
                    case 3:
                        _a.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        this.outQueue.dequeue();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    return SequencedExecutor;
}());
exports.SequencedExecutor = SequencedExecutor;
},{"../../logger/LoggerFactory":245,"./AsyncHelper":255,"tslib":180,"typescript-collections/dist/lib/Queue":182}],260:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
tslib_1.__exportStar(require("./CancellationToken"), exports);
tslib_1.__exportStar(require("./ReadOnlyCancellationToken"), exports);
tslib_1.__exportStar(require("./ReadWriteCancellationToken"), exports);
tslib_1.__exportStar(require("./AsyncHelper"), exports);
tslib_1.__exportStar(require("./SequencedExecutor"), exports);
},{"./AsyncHelper":255,"./CancellationToken":256,"./ReadOnlyCancellationToken":257,"./ReadWriteCancellationToken":258,"./SequencedExecutor":259,"tslib":180}],261:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Queue_1 = require("typescript-collections/dist/lib/Queue");
var CancellationToken_1 = require("../async/CancellationToken");
var AsyncHelper_1 = require("../async/AsyncHelper");
var BlockingQueue = /** @class */ (function () {
    function BlockingQueue() {
    }
    return BlockingQueue;
}());
exports.BlockingQueue = BlockingQueue;
var BlockingQueueBase = /** @class */ (function () {
    function BlockingQueueBase(internal) {
        if (internal === void 0) { internal = new Queue_1.default(); }
        this.internal = internal;
    }
    BlockingQueueBase.prototype.blockingDequeue = function (cancellationToken) {
        if (cancellationToken === void 0) { cancellationToken = new CancellationToken_1.CancellationToken(); }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                if (this.internal.size() > 0) {
                    return [2 /*return*/, Promise.resolve(this.internal.dequeue())];
                }
                return [2 /*return*/, AsyncHelper_1.AsyncHelper
                        .waitFor(function () { return _this.internal.size() > 0; }, cancellationToken)
                        .then(function () { return _this.internal.dequeue(); })];
            });
        });
    };
    BlockingQueueBase.prototype.enqueue = function (el) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                this.internal.enqueue(el);
                return [2 /*return*/];
            });
        });
    };
    BlockingQueueBase.prototype.size = function () {
        return this.internal.size();
    };
    BlockingQueueBase.prototype.clear = function () {
        this.internal.clear();
    };
    BlockingQueueBase.prototype.peek = function () {
        return this.internal.peek();
    };
    BlockingQueueBase.prototype.dequeue = function () {
        return this.internal.dequeue();
    };
    return BlockingQueueBase;
}());
exports.BlockingQueueBase = BlockingQueueBase;
},{"../async/AsyncHelper":255,"../async/CancellationToken":256,"tslib":180,"typescript-collections/dist/lib/Queue":182}],262:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
require("core-js/es6/map");
var ObjectUtils_1 = require("../js/ObjectUtils");
var ExtendedMap = /** @class */ (function (_super) {
    tslib_1.__extends(ExtendedMap, _super);
    function ExtendedMap() {
        return _super.call(this) || this;
    }
    ExtendedMap.create = function () {
        var instance = ObjectUtils_1.ObjectUtils.setPrototypeOf(new Map(), ExtendedMap.prototype);
        return instance;
    };
    ExtendedMap.prototype.valuesArray = function () {
        var res = [];
        this.forEach(function (v) { return res.push(v); });
        return res;
    };
    ExtendedMap.prototype.getOrAdd = function (key, producer) {
        var res = this.get(key);
        if (res === undefined) {
            res = producer();
            this.set(key, res);
        }
        return res;
    };
    return ExtendedMap;
}(Map));
exports.ExtendedMap = ExtendedMap;
},{"../js/ObjectUtils":267,"core-js/es6/map":12,"tslib":180}],263:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Queue_1 = require("typescript-collections/dist/lib/Queue");
var LimitedBufferQueue = /** @class */ (function (_super) {
    tslib_1.__extends(LimitedBufferQueue, _super);
    function LimitedBufferQueue(maxBufferSize) {
        if (maxBufferSize === void 0) { maxBufferSize = 1024; }
        var _this = _super.call(this) || this;
        _this.maxBufferSize = maxBufferSize;
        return _this;
    }
    LimitedBufferQueue.prototype.enqueue = function (elem) {
        if (this.size() >= this.maxBufferSize) {
            throw new Error("Buffer reached the limit " + this.maxBufferSize);
        }
        else {
            return _super.prototype.enqueue.call(this, elem);
        }
    };
    return LimitedBufferQueue;
}(Queue_1.default));
exports.LimitedBufferQueue = LimitedBufferQueue;
},{"tslib":180,"typescript-collections/dist/lib/Queue":182}],264:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
tslib_1.__exportStar(require("./BlockingQueue"), exports);
tslib_1.__exportStar(require("./LimitedBufferQueue"), exports);
tslib_1.__exportStar(require("./ExtendedMap"), exports);
},{"./BlockingQueue":261,"./ExtendedMap":262,"./LimitedBufferQueue":263,"tslib":180}],265:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var logger_1 = require("../../logger");
var DomUtils = /** @class */ (function () {
    function DomUtils() {
    }
    DomUtils.iFrameLoaded = function (iFrameElement) {
        return new Promise(function (resolve) {
            iFrameElement.addEventListener('load', function () {
                resolve(iFrameElement);
            }, false);
        });
    };
    DomUtils.getOrCreateHiddenIFrame = function (id, url) {
        var iFrameElement = document.getElementById(id);
        if (iFrameElement) {
            DomUtils.log.debug("iFrame [" + id + "] already exist");
            return Promise.resolve(iFrameElement);
        }
        else {
            iFrameElement = document.createElement('iframe');
            iFrameElement.setAttribute('id', id);
            iFrameElement.setAttribute('src', url);
            iFrameElement.style.cssText = 'position:absolute;width:1px;height:1px;left:-9999px;display:none';
            document.body.appendChild(iFrameElement);
        }
        return DomUtils.iFrameLoaded(iFrameElement);
    };
    DomUtils.getOrigin = function (url) {
        if (url.startsWith('/')) {
            return window.location.origin;
        }
        var parts = url.split('/');
        if (parts.length > 2 && parts[0].indexOf('http') === 0) {
            return parts[0] + '//' + parts[2];
        }
        else {
            throw new Error("Couldn't get origin, unsupported URL - " + url);
        }
    };
    DomUtils.getQueryParam = function (name) {
        var top = DomUtils.getTopWindow(window);
        var value = (new RegExp('[?&]' + encodeURIComponent(name) + '=([^&]*)')).exec(top.location.search);
        return value ? decodeURIComponent(value[1]) : undefined;
    };
    DomUtils.getTopWindow = function (window) {
        try {
            if (window.parent && window.parent !== window) {
                return DomUtils.getTopWindow(window.parent);
            }
            else {
                return window;
            }
        }
        catch (e) {
            // parent from other domain, we should stop here
            return window;
        }
    };
    DomUtils.log = logger_1.LoggerFactory.getLogger('DomUtils');
    return DomUtils;
}());
exports.DomUtils = DomUtils;
},{"../../logger":247}],266:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
tslib_1.__exportStar(require("./Arrays"), exports);
tslib_1.__exportStar(require("./ExtendedArray"), exports);
tslib_1.__exportStar(require("./GUID"), exports);
tslib_1.__exportStar(require("./collections"), exports);
tslib_1.__exportStar(require("./async"), exports);
tslib_1.__exportStar(require("./state"), exports);
tslib_1.__exportStar(require("./types"), exports);
tslib_1.__exportStar(require("./dom/DomUtils"), exports);
tslib_1.__exportStar(require("./time/TimeUtils"), exports);
tslib_1.__exportStar(require("./url/UrlParamsProvider"), exports);
},{"./Arrays":252,"./ExtendedArray":253,"./GUID":254,"./async":260,"./collections":264,"./dom/DomUtils":265,"./state":269,"./time/TimeUtils":270,"./types":271,"./url/UrlParamsProvider":272,"tslib":180}],267:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ObjectUtils = /** @class */ (function () {
    function ObjectUtils() {
    }
    ObjectUtils.setPrototypeOf = setProtoImpl();
    return ObjectUtils;
}());
exports.ObjectUtils = ObjectUtils;
function setProtoImpl() {
    return Object.setPrototypeOf || _proto_supported() ? set_proto_ : copyProperties;
}
function set_proto_(obj, proto) {
    obj.__proto__ = proto;
    return obj;
}
function _proto_supported() {
    return { __proto__: [] } instanceof Array;
}
function copyProperties(obj, proto) {
    for (var prop in proto) {
        if (!obj.hasOwnProperty(prop)) {
            obj[prop] = proto[prop];
        }
    }
    return obj;
}
},{}],268:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var LoggerFactory_1 = require("../../logger/LoggerFactory");
var StateDescriptor = /** @class */ (function () {
    function StateDescriptor(state, inTransitions, outTransitions) {
        if (inTransitions === void 0) { inTransitions = []; }
        if (outTransitions === void 0) { outTransitions = []; }
        this.state = state;
        this.inTransitions = inTransitions;
        this.outTransitions = outTransitions;
    }
    StateDescriptor.prototype.hasOutTransition = function (state) {
        return this.outTransitions.filter(function (transtion) { return transtion.to === state; }).length > 0;
    };
    return StateDescriptor;
}());
var StateMaschineBase = /** @class */ (function () {
    function StateMaschineBase(current, transitions, logger) {
        if (logger === void 0) { logger = LoggerFactory_1.LoggerFactory.getLogger('StateMaschine'); }
        var _this = this;
        this.current = current;
        this.logger = logger;
        this.stateDescriptorsMap = new Map();
        transitions.forEach(function (transition) {
            _this.putIfAbsent(transition.from);
            _this.putIfAbsent(transition.to);
            var fromDescriptor = _this.lookup(transition.from);
            if (fromDescriptor.hasOutTransition(transition.to)) {
                throw "Transition " + transition.from + " -> " + transition.to + " already exists";
            }
            fromDescriptor.outTransitions.push(transition);
        });
    }
    StateMaschineBase.prototype.is = function (state) {
        return this.current === state;
    };
    StateMaschineBase.prototype.isOneOf = function () {
        var states = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            states[_i] = arguments[_i];
        }
        for (var _a = 0, states_1 = states; _a < states_1.length; _a++) {
            var state = states_1[_a];
            if (this.is(state)) {
                return true;
            }
        }
        return false;
    };
    StateMaschineBase.prototype.getCurrent = function () {
        return this.current;
    };
    StateMaschineBase.prototype.canGo = function (state) {
        var descriptor = this.stateDescriptorsMap.get(this.getCurrent());
        if (descriptor) {
            return descriptor.hasOutTransition(state);
        }
        else {
            return false;
        }
    };
    StateMaschineBase.prototype.go = function (to) {
        var _this = this;
        if (!this.canGo(to)) {
            throw new Error("Transition " + this.getCurrent() + " -> " + to + " does not exist");
        }
        var descriptor = this.lookup(this.getCurrent());
        var transition = descriptor.outTransitions.find(function (transition) { return transition.to === to; });
        var old = this.getCurrent();
        if (transition.preHandler) {
            transition.preHandler()
                .then(function () {
                /* istanbul ignore if */
                if (_this.logger.isTraceEnabled()) {
                    _this.logger.trace("Finished pre-handler for " + old + " -> " + to);
                }
            })
                .catch(function (e) { return _this.logger.error("Pre-handler for " + _this.getCurrent() + " -> " + to + " failed", e); });
        }
        this.switchInternal(to);
        if (transition.postHandler) {
            transition.postHandler()
                .then(function () {
                /* istanbul ignore if */
                if (_this.logger.isTraceEnabled()) {
                    _this.logger.trace("Finished post-handler for " + _this.getCurrent() + " -> " + to);
                }
            })
                .catch(function (e) { return _this.logger.error("Post-handler for " + _this.getCurrent() + " -> " + to + " failed", e); });
        }
    };
    StateMaschineBase.prototype.goAsync = function (to, dynamicHandlers) {
        var _this = this;
        if (this.canGo(to)) {
            var descriptor = this.lookup(this.getCurrent());
            var transition_1 = descriptor.outTransitions.find(function (transition) { return transition.to === to; });
            return new Promise(function (resolve, reject) {
                var preHandlePassed = function () {
                    _this.switchInternal(transition_1.to);
                    var postHandlerPromises = [dynamicHandlers ? dynamicHandlers.postHandler : null, transition_1.postHandler]
                        .filter(function (handler) { return !!handler; })
                        .map(function (handler) { return handler; })
                        .map(function (handler) { return handler(); });
                    Promise.all(postHandlerPromises)
                        .then(function () { return resolve(); }, reject);
                };
                var preHandlePromises = [dynamicHandlers ? dynamicHandlers.preHandler : null, transition_1.preHandler]
                    .filter(function (handler) { return !!handler; })
                    .map(function (handler) { return handler; })
                    .map(function (handler) { return handler(); });
                Promise.all(preHandlePromises)
                    .then(preHandlePassed.bind(_this), reject);
            });
        }
        else {
            var error = "Transition " + this.getCurrent() + " -> " + to + " does not exist";
            this.logError(error);
            return Promise.reject(error);
        }
    };
    StateMaschineBase.prototype.throwIfNot = function () {
        var states = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            states[_i] = arguments[_i];
        }
        var result = false;
        for (var _a = 0, states_2 = states; _a < states_2.length; _a++) {
            var state = states_2[_a];
            if (this.is(state)) {
                result = true;
            }
        }
        if (!result) {
            var error = "Current state is " + this.current + " not one of [" + states.join(',') + "]";
            this.logError(error);
            throw new Error(error);
        }
    };
    StateMaschineBase.prototype.logError = function (m) {
        if (this.logger) {
            this.logger.error(m);
        }
    };
    StateMaschineBase.prototype.switchInternal = function (to) {
        /* istanbul ignore if */
        if (this.logger.isTraceEnabled()) {
            this.logger.trace(this.getCurrent() + " -> " + to);
        }
        this.current = to;
    };
    StateMaschineBase.prototype.putIfAbsent = function (state) {
        if (!this.stateDescriptorsMap.has(state)) {
            this.stateDescriptorsMap.set(state, new StateDescriptor(state));
        }
    };
    StateMaschineBase.prototype.lookup = function (state) {
        return this.stateDescriptorsMap.get(state);
    };
    return StateMaschineBase;
}());
exports.StateMaschineBase = StateMaschineBase;
},{"../../logger/LoggerFactory":245}],269:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./StateMaschineBase"), exports);
},{"./StateMaschineBase":268,"tslib":180}],270:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var TimeUtils = /** @class */ (function () {
    function TimeUtils() {
    }
    TimeUtils.timeout = function (ms) {
        return new Promise(function (resolve) { return setTimeout(resolve, ms); });
    };
    TimeUtils.format = function (date) {
        return date.toTimeString().replace(/.*(\d{2}:\d{2}:\d{2}).*/, '$1') + "." + ('000' + date.getMilliseconds()).slice(-3);
    };
    return TimeUtils;
}());
exports.TimeUtils = TimeUtils;
},{}],271:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function isString(value) {
    return value && Object.prototype.toString.call(value) === '[object String]';
}
exports.isString = isString;
},{}],272:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var UrlParamsProvider = /** @class */ (function () {
    function UrlParamsProvider() {
    }
    UrlParamsProvider.getParam = function (name) {
        if (typeof window === 'undefined') {
            return undefined;
        }
        var queryString = this.parseUrlParams(window.location.search);
        return queryString[name];
    };
    UrlParamsProvider.parseUrlParams = function (query) {
        var queryString = {};
        query = query.startsWith('?') ? query.substring(1) : query;
        var vars = query.split('&');
        for (var i = 0; i < vars.length; i++) {
            var pair = vars[i].split('=');
            if (typeof queryString[pair[0]] === 'undefined') {
                queryString[pair[0]] = decodeURIComponent(pair[1]);
            }
            else if (typeof queryString[pair[0]] === 'string') {
                var arr = [queryString[pair[0]], decodeURIComponent(pair[1])];
                queryString[pair[0]] = arr;
            }
            else {
                queryString[pair[0]].push(decodeURIComponent(pair[1]));
            }
        }
        return queryString;
    };
    return UrlParamsProvider;
}());
exports.UrlParamsProvider = UrlParamsProvider;
},{}],273:[function(require,module,exports){
(function (global){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function webSocketCtor() {
    if (typeof window !== 'undefined') {
        var _window = window;
        if (_window && _window.WebSocket) {
            return _window.WebSocket;
        }
    }
    var isNode = typeof global !== 'undefined' && ({}).toString.call(global) === '[object global]';
    if (isNode) {
        var _global = global;
        if (_global && _global.WebSocket) {
            return _global.WebSocket;
        }
        return require('websocket').w3cwebsocket;
    }
    throw new Error('WebSocket API is not found');
}
exports.webSocketCtor = webSocketCtor;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"websocket":"websocket"}],274:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var BinaryMarshallerProvider = /** @class */ (function () {
    function BinaryMarshallerProvider() {
    }
    return BinaryMarshallerProvider;
}());
exports.BinaryMarshallerProvider = BinaryMarshallerProvider;
},{}],275:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./BinaryMarshallerProvider"), exports);
},{"./BinaryMarshallerProvider":274,"tslib":180}],276:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DynamicProtoMarshallerFactory_1 = require("./DynamicProtoMarshallerFactory");
var DynamicBinaryProtoMarshaller_1 = require("./DynamicBinaryProtoMarshaller");
var DynamicBinaryMarshallerProvider = /** @class */ (function () {
    function DynamicBinaryMarshallerProvider(registry) {
        this.registry = registry;
        this.internalProvider = new DynamicProtoMarshallerFactory_1.DynamicProtoMarshallerFactory(registry);
    }
    DynamicBinaryMarshallerProvider.prototype.getMarshaller = function (messageType) {
        return new DynamicBinaryProtoMarshaller_1.DynamicBinaryProtoMarshaller(this.internalProvider.getMarshaller(messageType));
    };
    return DynamicBinaryMarshallerProvider;
}());
exports.DynamicBinaryMarshallerProvider = DynamicBinaryMarshallerProvider;
},{"./DynamicBinaryProtoMarshaller":277,"./DynamicProtoMarshallerFactory":279}],277:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DynamicBinaryProtoMarshaller = /** @class */ (function () {
    function DynamicBinaryProtoMarshaller(internal) {
        this.internal = internal;
    }
    DynamicBinaryProtoMarshaller.prototype.encode = function (messageObj) {
        return new Uint8Array(this.internal.encode(messageObj));
    };
    DynamicBinaryProtoMarshaller.prototype.decode = function (messagePayload) {
        return this.internal.decode(messagePayload.buffer);
    };
    return DynamicBinaryProtoMarshaller;
}());
exports.DynamicBinaryProtoMarshaller = DynamicBinaryProtoMarshaller;
},{}],278:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = require("@plexus-interop/common");
var DynamicProtoMarshaller = /** @class */ (function () {
    function DynamicProtoMarshaller(protoType) {
        this.protoType = protoType;
    }
    DynamicProtoMarshaller.prototype.validate = function (messageObj) {
        var error = this.protoType.verify(messageObj);
        if (error) {
            throw new Error(error);
        }
    };
    DynamicProtoMarshaller.prototype.decode = function (messagePayload) {
        var decoded = this.protoType.decode(new Uint8Array(messagePayload));
        return this.protoType.toObject(decoded);
    };
    DynamicProtoMarshaller.prototype.encode = function (messageObj) {
        return common_1.Arrays.toArrayBuffer(this.protoType.encode(messageObj).finish());
    };
    return DynamicProtoMarshaller;
}());
exports.DynamicProtoMarshaller = DynamicProtoMarshaller;
},{"@plexus-interop/common":243}],279:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var protobuf = require("protobufjs/light");
var DynamicProtoMarshaller_1 = require("./DynamicProtoMarshaller");
/**
 * Dynamic Marshaller, based on Interop Metadata Registry
 */
var DynamicProtoMarshallerFactory = /** @class */ (function () {
    function DynamicProtoMarshallerFactory(registry) {
        this.registry = registry;
        // tslint:disable-next-line:typedef
        this.cache = new Map();
        this.protobufRoot = protobuf.Root.fromJSON(registry.rawMessages);
    }
    DynamicProtoMarshallerFactory.prototype.getMarshaller = function (messageId) {
        if (this.cache.has(messageId)) {
            return this.cache.get(messageId);
        }
        var marshaller = this.createDynamicMarshaller(this.registry, messageId);
        this.cache.set(messageId, marshaller);
        return marshaller;
    };
    DynamicProtoMarshallerFactory.prototype.createDynamicMarshaller = function (registry, messageId) {
        var message = registry.messages.get(messageId);
        if (!message) {
            throw new Error(messageId + " not found in Registry");
        }
        var type = this.protobufRoot.lookupType(messageId);
        return new DynamicProtoMarshaller_1.DynamicProtoMarshaller(type);
    };
    return DynamicProtoMarshallerFactory;
}());
exports.DynamicProtoMarshallerFactory = DynamicProtoMarshallerFactory;
},{"./DynamicProtoMarshaller":278,"protobufjs/light":84}],280:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
tslib_1.__exportStar(require("./DynamicProtoMarshaller"), exports);
tslib_1.__exportStar(require("./DynamicProtoMarshallerFactory"), exports);
tslib_1.__exportStar(require("./DynamicBinaryMarshallerProvider"), exports);
tslib_1.__exportStar(require("./DynamicBinaryProtoMarshaller"), exports);
},{"./DynamicBinaryMarshallerProvider":276,"./DynamicBinaryProtoMarshaller":277,"./DynamicProtoMarshaller":278,"./DynamicProtoMarshallerFactory":279,"tslib":180}],281:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
tslib_1.__exportStar(require("./api"), exports);
},{"./api":275,"tslib":180}],282:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Provides Marshaller based on generated Protobuf message types
 */
var ProtoMarshallerProvider = /** @class */ (function () {
    function ProtoMarshallerProvider() {
    }
    ProtoMarshallerProvider.prototype.getMarshaller = function (messageObj) {
        if (!messageObj) {
            throw new Error('Proto message definition is not provided');
        }
        else if (!messageObj.encode || !messageObj.decode) {
            throw new Error('Encode/Decode is missed for message definition');
        }
        else {
            return {
                encode: function (obj) {
                    return messageObj.encode(obj).finish();
                },
                decode: function (payload) {
                    return messageObj.toObject(messageObj.decode(payload));
                }
            };
        }
    };
    return ProtoMarshallerProvider;
}());
exports.ProtoMarshallerProvider = ProtoMarshallerProvider;
},{}],283:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
tslib_1.__exportStar(require("./ProtoMarshallerProvider"), exports);
},{"./ProtoMarshallerProvider":282,"tslib":180}],284:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = require("@plexus-interop/common");
var AppRegistryService = /** @class */ (function () {
    function AppRegistryService(appRegistryProvider) {
        var _this = this;
        this.appRegistryProvider = appRegistryProvider;
        this.log = common_1.LoggerFactory.getLogger('AppRegistryService');
        this.appsRegistry = appRegistryProvider.getCurrent();
        this.appRegistryProvider.getAppRegistry().subscribe({
            next: function (update) {
                _this.log.debug("App registry updated, apps size [" + update.apps.size + "]");
                _this.appsRegistry = update;
            }
        });
    }
    AppRegistryService.prototype.getApplication = function (id) {
        var result = this.appsRegistry.apps.get(id);
        if (!result) {
            throw new Error("Application with id [" + id + "] is not found in App Registry");
        }
        return result;
    };
    AppRegistryService.prototype.getApplications = function () {
        return this.appsRegistry.apps.valuesArray();
    };
    AppRegistryService.prototype.isAppExist = function (id) {
        return this.appsRegistry.apps.has(id);
    };
    return AppRegistryService;
}());
exports.AppRegistryService = AppRegistryService;
},{"@plexus-interop/common":243}],285:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("rxjs/Observable");
var common_1 = require("@plexus-interop/common");
require("rxjs/add/observable/of");
require("rxjs/add/operator/map");
var JsonAppRegistryProvider = /** @class */ (function () {
    function JsonAppRegistryProvider(jsonMetadata, $jsonMetadata) {
        var _this = this;
        this.current = this.parseRegistry(jsonMetadata);
        this.$registry = ($jsonMetadata || Observable_1.Observable.of(jsonMetadata))
            .map(this.parseRegistry.bind(this));
        this.$registry.subscribe({
            next: function (update) { return _this.current = update; }
        });
    }
    JsonAppRegistryProvider.prototype.getAppRegistry = function () {
        return this.$registry;
    };
    JsonAppRegistryProvider.prototype.getCurrent = function () {
        return this.current;
    };
    JsonAppRegistryProvider.prototype.parseRegistry = function (json) {
        var appsDto = JSON.parse(json);
        return {
            apps: common_1.toMap(appsDto.apps, function (app) { return app.id; }, function (app) { return app; })
        };
    };
    return JsonAppRegistryProvider;
}());
exports.JsonAppRegistryProvider = JsonAppRegistryProvider;
},{"@plexus-interop/common":243,"rxjs/Observable":121,"rxjs/add/observable/of":130,"rxjs/add/operator/map":132}],286:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Observable_1 = require("rxjs/Observable");
var common_1 = require("@plexus-interop/common");
var remote_1 = require("@plexus-interop/remote");
var JsonAppRegistryProvider_1 = require("./JsonAppRegistryProvider");
var UrlAppRegistryProvider = /** @class */ (function () {
    function UrlAppRegistryProvider(url, interval) {
        if (interval === void 0) { interval = -1; }
        this.url = url;
        this.interval = interval;
        this.log = common_1.LoggerFactory.getLogger('UrlAppRegistryProvider');
        this.urlDataLoader = new remote_1.HttpDataLoader();
        this.started = false;
    }
    UrlAppRegistryProvider.prototype.getAppRegistry = function () {
        return this.started ? this.jsonAppRegistryProvider.getAppRegistry() : Observable_1.Observable.throw(new Error('Not started'));
    };
    UrlAppRegistryProvider.prototype.getCurrent = function () {
        if (!this.started) {
            throw new Error('Not started');
        }
        return this.jsonAppRegistryProvider.getCurrent();
    };
    UrlAppRegistryProvider.prototype.start = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.started) {
                            return [2 /*return*/, Promise.reject('Already started')];
                        }
                        this.log.debug("Starting to load metadata from [" + this.url + "] with " + this.interval + " interval");
                        return [4 /*yield*/, this.urlDataLoader.fetchData(this.url)];
                    case 1:
                        response = _a.sent();
                        if (this.interval > 0) {
                            this.jsonAppRegistryProvider = new JsonAppRegistryProvider_1.JsonAppRegistryProvider(response, this.urlDataLoader.fetchWithInterval(this.url, this.interval));
                        }
                        else {
                            this.jsonAppRegistryProvider = new JsonAppRegistryProvider_1.JsonAppRegistryProvider(response);
                        }
                        this.started = true;
                        return [2 /*return*/];
                }
            });
        });
    };
    return UrlAppRegistryProvider;
}());
exports.UrlAppRegistryProvider = UrlAppRegistryProvider;
},{"./JsonAppRegistryProvider":285,"@plexus-interop/common":243,"@plexus-interop/remote":309,"rxjs/Observable":121,"tslib":180}],287:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
tslib_1.__exportStar(require("./apps/json/JsonAppRegistryProvider"), exports);
tslib_1.__exportStar(require("./apps/json/UrlAppRegistryProvider"), exports);
tslib_1.__exportStar(require("./apps/AppRegistryService"), exports);
tslib_1.__exportStar(require("./interop/json/JsonInteropRegistryProvider"), exports);
tslib_1.__exportStar(require("./interop/json/UrlInteropRegistryProvider"), exports);
tslib_1.__exportStar(require("./interop/InteropRegistryService"), exports);
tslib_1.__exportStar(require("./interop/model"), exports);
},{"./apps/AppRegistryService":284,"./apps/json/JsonAppRegistryProvider":285,"./apps/json/UrlAppRegistryProvider":286,"./interop/InteropRegistryService":288,"./interop/json/JsonInteropRegistryProvider":289,"./interop/json/UrlInteropRegistryProvider":292,"./interop/model":295,"tslib":180}],288:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = require("@plexus-interop/common");
var InteropRegistryService = /** @class */ (function () {
    function InteropRegistryService(registryProvider) {
        var _this = this;
        this.registryProvider = registryProvider;
        this.log = common_1.LoggerFactory.getLogger('RegistryService');
        this.appProvidedMethodsCache = common_1.ExtendedMap.create();
        this.updateRegistry(registryProvider.getCurrent());
        this.registryProvider.getRegistry().subscribe({
            next: function (updatedRegistry) { return _this.updateRegistry(updatedRegistry); }
        });
    }
    InteropRegistryService.prototype.getApplication = function (idOrAlias) {
        var aliasOptionPredicate = function (option) { return option.id.endsWith('alias') && idOrAlias === option.value; };
        var appFinder = function (app) { return app.id === idOrAlias || (!!app.options && !!app.options.find(aliasOptionPredicate)); };
        var result = this.registry.applications.valuesArray().find(appFinder);
        if (!result) {
            throw new Error(idOrAlias + " app not found");
        }
        return result;
    };
    InteropRegistryService.prototype.getRegistry = function () {
        return this.registry;
    };
    InteropRegistryService.prototype.getConsumedService = function (appId, serviceReference) {
        var app = this.getApplication(appId);
        var result = app.consumedServices.find(function (consumedService) { return consumedService.service.id === serviceReference.serviceId
            && (!serviceReference.serviceAlias || serviceReference.serviceAlias === consumedService.service.serviceAlias); });
        if (!result) {
            throw new Error("Service not found");
        }
        return result;
    };
    InteropRegistryService.prototype.getConsumedMethod = function (appId, reference) {
        var _this = this;
        var app = this.getApplication(appId);
        var consumedMethods = common_1.flatMap(function (consumedService) { return consumedService.methods.valuesArray(); }, app.consumedServices);
        var result = consumedMethods.find(function (method) {
            return _this.equalsIfExist(reference.methodId, method.method.name)
                && (!reference.consumedService
                    || (_this.equalsIfExist(reference.consumedService.serviceAlias, method.consumedService.service.serviceAlias)
                        && _this.equalsIfExist(reference.consumedService.serviceId, method.consumedService.service.id)));
        });
        if (!result) {
            throw new Error("Service not found");
        }
        return result;
    };
    InteropRegistryService.prototype.getProvidedService = function (reference) {
        var _this = this;
        var result = this.getApplication(reference.applicationId)
            .providedServices.find(function (x) { return _this.equalsIfExist(reference.serviceAlias, x.service.serviceAlias) && _this.equalsIfExist(reference.serviceId, x.service.id); });
        if (!result) {
            throw new Error('Provided Service not found');
        }
        return result;
    };
    InteropRegistryService.prototype.getMatchingProvidedMethods = function (appId, consumedMethodReference) {
        var consumedMethod = this.getConsumedMethod(appId, consumedMethodReference);
        return this.getMatchingProvidedMethodsFromConsumed(consumedMethod);
    };
    InteropRegistryService.prototype.getProvidedServices = function (appId) {
        var app = this.registry.applications.get(appId);
        if (!app) {
            throw new Error("App " + appId + " doesn't exist");
        }
        return app.providedServices;
    };
    InteropRegistryService.prototype.getConsumedServices = function (appId) {
        var app = this.registry.applications.get(appId);
        if (!app) {
            throw new Error("App " + appId + " doesn't exist");
        }
        return app.consumedServices;
    };
    InteropRegistryService.prototype.getMatchingProvidedMethodsForApp = function (app) {
        var _this = this;
        return this.appProvidedMethodsCache.getOrAdd(app.id, function () { return _this.getMatchingProvidedMethodsForAppInternal(app); });
    };
    InteropRegistryService.prototype.getMatchingProvidedMethodsFromConsumed = function (consumedMethod) {
        var _this = this;
        return this.getMatchingProvidedMethodsForApp(consumedMethod.consumedService.application)
            .filter(function (providedMethod) { return _this.equals(consumedMethod.method, providedMethod.method); });
    };
    InteropRegistryService.prototype.getProvidedMethods = function () {
        var allProvidedServices = common_1.flatMap(function (app) { return app.providedServices; }, this.registry.applications.valuesArray());
        return common_1.flatMap(function (service) { return service.methods.valuesArray(); }, allProvidedServices);
    };
    InteropRegistryService.prototype.updateRegistry = function (registry) {
        this.log.debug('Registry updated');
        this.registry = registry;
        this.appProvidedMethodsCache.clear();
    };
    InteropRegistryService.prototype.getMatchingProvidedMethodsForAppInternal = function (app) {
        var allProvidedServices = common_1.flatMap(function (app) { return app.providedServices; }, this.registry.applications.valuesArray());
        var consumedProvidedPairs = common_1.join(app.consumedServices, allProvidedServices, function (consumed, provided) {
            return { consumed: consumed, provided: provided };
        }, 
        // matched by service id app permissions
        function (c, p) { return p.to.isMatch(c.application.id)
            && c.from.isMatch(p.application.id)
            && c.service.id === p.service.id
            && c.alias === p.alias; });
        var result = common_1.flatMap(function (pair) {
            var allMatchedProvidedMethods = common_1.join(pair.consumed.methods.valuesArray(), pair.provided.methods.valuesArray(), function (c, p) { return p; }, 
            // matched by method name
            function (c, p) { return c.method.name === p.method.name; });
            return common_1.distinct(allMatchedProvidedMethods, function (pMethod) { return pMethod.method.name + "-" + pMethod.providedService.application.id; });
        }, consumedProvidedPairs);
        return result;
    };
    InteropRegistryService.prototype.equals = function (x, y) {
        return x.name === y.name && x.service.id === y.service.id;
    };
    InteropRegistryService.prototype.equalsIfExist = function (expect, result) {
        return typeof expect === 'undefined' || expect === result;
    };
    return InteropRegistryService;
}());
exports.InteropRegistryService = InteropRegistryService;
},{"@plexus-interop/common":243}],289:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("rxjs/Observable");
require("rxjs/add/observable/of");
require("rxjs/add/operator/map");
var common_1 = require("@plexus-interop/common");
var MethodType_1 = require("../model/MethodType");
var MethodTypeDto_1 = require("./MethodTypeDto");
var MatchPatternFactory_1 = require("../model/MatchPatternFactory");
var MessagesNamespace_1 = require("./MessagesNamespace");
var JsonInteropRegistryProvider = /** @class */ (function () {
    function JsonInteropRegistryProvider(jsonMetadata, $jsonMetadata) {
        var _this = this;
        this.log = common_1.LoggerFactory.getLogger('JsonInteropRegistryProvider');
        this.current = this.parseRegistry(jsonMetadata);
        this.$registry = ($jsonMetadata || Observable_1.Observable.of(jsonMetadata))
            .map(this.parseRegistry.bind(this));
        this.$registry.subscribe({
            next: function (update) { return _this.current = update; }
        });
    }
    JsonInteropRegistryProvider.prototype.getCurrent = function () {
        return this.current;
    };
    JsonInteropRegistryProvider.prototype.getRegistry = function () {
        return this.$registry;
    };
    JsonInteropRegistryProvider.prototype.parseRegistry = function (jsonRegistry) {
        var _this = this;
        this.log.trace("Parsing JSON registry of " + jsonRegistry.length + " length");
        var registryDto = JSON.parse(jsonRegistry);
        this.log.trace("Finished parsing " + jsonRegistry.length + " length");
        var messages = common_1.ExtendedMap.create();
        var enums = common_1.ExtendedMap.create();
        this.collectMessagesMetadata(registryDto.messages, null, messages, enums);
        var services = common_1.ExtendedArray.of(registryDto.services.map(function (s) { return _this.convertService(messages, s); }))
            .toMap(function (s) { return s.id; }, function (s) { return s; });
        var applications = common_1.ExtendedArray.of(registryDto.applications.map(function (appDto) { return _this.convertApplication(services, appDto); }))
            .toMap(function (a) { return a.id; }, function (a) { return a; });
        return {
            messages: messages,
            enums: enums,
            services: services,
            applications: applications,
            rawMessages: registryDto.messages
        };
    };
    JsonInteropRegistryProvider.prototype.collectMessagesMetadata = function (rawEnries, namespaceId, messagesMap, enumsMap) {
        if (namespaceId === void 0) { namespaceId = null; }
        var nested = rawEnries.nested;
        if (!nested) {
            return;
        }
        for (var key in nested) {
            var namespaceEntry = nested[key];
            var id = namespaceId ? namespaceId + "." + key : key;
            if (MessagesNamespace_1.isMessage(namespaceEntry)) {
                messagesMap.set(id, { id: id, fields: namespaceEntry.fields });
            }
            else if (MessagesNamespace_1.isEnum(namespaceEntry)) {
                enumsMap.set(id, { id: id, values: namespaceEntry.values });
            }
            this.collectMessagesMetadata(namespaceEntry, id, messagesMap, enumsMap);
        }
    };
    JsonInteropRegistryProvider.prototype.convertApplication = function (services, appDto) {
        var _this = this;
        var providedServices = [];
        var consumedServices = [];
        var application = {
            id: appDto.id,
            providedServices: providedServices,
            consumedServices: consumedServices,
            options: []
        };
        appDto.consumes = appDto.consumes || [];
        appDto.consumes.forEach(function (consumedDto) {
            consumedServices.push(_this.convertConsumedService(consumedDto, application, services.get(consumedDto.service)));
        });
        appDto.provides = appDto.provides || [];
        appDto.provides.forEach(function (providedDto) {
            providedServices.push(_this.convertProvidedService(providedDto, application, services.get(providedDto.service)));
        });
        if (appDto.options) {
            application.options = appDto.options.map(function (optDto) {
                return { id: optDto.id, value: optDto.value };
            });
        }
        return application;
    };
    JsonInteropRegistryProvider.prototype.convertConsumedService = function (serviceDto, application, service) {
        var methods = common_1.ExtendedMap.create();
        var consumedService = {
            service: service,
            application: application,
            alias: serviceDto.alias,
            from: MatchPatternFactory_1.MatchPatternFactory.createMatcher(serviceDto.from),
            methods: methods
        };
        serviceDto.methods = serviceDto.methods || [];
        serviceDto.methods
            .map(function (m) {
            return {
                method: service.methods.get(m.name),
                consumedService: consumedService
            };
        })
            .forEach(function (cm) { return methods.set(cm.method.name, cm); });
        return consumedService;
    };
    JsonInteropRegistryProvider.prototype.convertProvidedService = function (serviceDto, application, service) {
        var _this = this;
        var methods = common_1.ExtendedMap.create();
        var providedService = {
            service: service,
            application: application,
            alias: serviceDto.alias,
            to: MatchPatternFactory_1.MatchPatternFactory.createMatcher(serviceDto.to),
            methods: methods
        };
        serviceDto.methods.map(function (pm) {
            return {
                method: service.methods.get(pm.name),
                providedService: providedService,
                title: _this.getOptionValueOrDefault(pm.options, 'interop.ProvidedMethodOptions.title', null),
                options: pm.options
            };
        })
            .forEach(function (pm) { return methods.set(pm.method.name, pm); });
        return providedService;
    };
    JsonInteropRegistryProvider.prototype.getOptionValueOrDefault = function (options, id, defaultValue) {
        if (options) {
            for (var _i = 0, options_1 = options; _i < options_1.length; _i++) {
                var o = options_1[_i];
                if (o.id === id) {
                    return o.value;
                }
            }
        }
        return defaultValue;
    };
    JsonInteropRegistryProvider.prototype.convertService = function (messagesMap, serviceDto) {
        var _this = this;
        var service = {
            id: serviceDto.id,
            methods: common_1.ExtendedMap.create()
        };
        service.methods = common_1.toMap(serviceDto.methods.map(function (methodDto) {
            return {
                name: methodDto.name,
                type: _this.convertMethodType(methodDto.type),
                requestMessage: messagesMap.get(methodDto.request),
                responseMessage: messagesMap.get(methodDto.response),
                service: service
            };
        }), function (m) { return m.name; }, function (m) { return m; });
        return service;
    };
    JsonInteropRegistryProvider.prototype.convertMethodType = function (methodTypeDto) {
        switch (methodTypeDto) {
            case MethodTypeDto_1.MethodTypeDto.ClientStreaming:
                return MethodType_1.MethodType.ClientStreaming;
            case MethodTypeDto_1.MethodTypeDto.ServerStreaming:
                return MethodType_1.MethodType.ServerStreaming;
            case MethodTypeDto_1.MethodTypeDto.Unary:
                return MethodType_1.MethodType.Unary;
            case MethodTypeDto_1.MethodTypeDto.DuplexStreaming:
                return MethodType_1.MethodType.DuplexStreaming;
            default:
                throw new Error('Unsupported method type: ' + methodTypeDto);
        }
    };
    return JsonInteropRegistryProvider;
}());
exports.JsonInteropRegistryProvider = JsonInteropRegistryProvider;
},{"../model/MatchPatternFactory":293,"../model/MethodType":294,"./MessagesNamespace":290,"./MethodTypeDto":291,"@plexus-interop/common":243,"rxjs/Observable":121,"rxjs/add/observable/of":130,"rxjs/add/operator/map":132}],290:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isMessage(o) {
    return !!o.fields;
}
exports.isMessage = isMessage;
function isEnum(o) {
    return !!o.values;
}
exports.isEnum = isEnum;
},{}],291:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var MethodTypeDto;
(function (MethodTypeDto) {
    MethodTypeDto["Unary"] = "Unary";
    MethodTypeDto["ServerStreaming"] = "ServerStreaming";
    MethodTypeDto["ClientStreaming"] = "ClientStreaming";
    MethodTypeDto["DuplexStreaming"] = "DuplexStreaming";
})(MethodTypeDto = exports.MethodTypeDto || (exports.MethodTypeDto = {}));
},{}],292:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Observable_1 = require("rxjs/Observable");
var common_1 = require("@plexus-interop/common");
var remote_1 = require("@plexus-interop/remote");
var JsonInteropRegistryProvider_1 = require("./JsonInteropRegistryProvider");
var remote_2 = require("@plexus-interop/remote");
require("rxjs/add/operator/throttleTime");
var UrlInteropRegistryProvider = /** @class */ (function () {
    function UrlInteropRegistryProvider(url, interval, webSocketDataProvider) {
        if (interval === void 0) { interval = -1; }
        if (webSocketDataProvider === void 0) { webSocketDataProvider = new remote_2.WebSocketDataProvider(); }
        this.url = url;
        this.interval = interval;
        this.webSocketDataProvider = webSocketDataProvider;
        this.log = common_1.LoggerFactory.getLogger('UrlInteropRegistryProvider');
        this.urlDataLoader = new remote_1.HttpDataLoader();
        this.started = false;
    }
    UrlInteropRegistryProvider.prototype.getRegistry = function () {
        return this.started ? this.jsonInteropRegistryProvider.getRegistry() : Observable_1.Observable.throw(new Error('Not started'));
    };
    UrlInteropRegistryProvider.prototype.getCurrent = function () {
        if (!this.started) {
            throw new Error('Not started');
        }
        return this.jsonInteropRegistryProvider.getCurrent();
    };
    UrlInteropRegistryProvider.prototype.start = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var isWebSocket;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.started) {
                            return [2 /*return*/, Promise.reject('Already started')];
                        }
                        this.log.debug("Starting to load metadata from [" + this.url + "] with " + this.interval + " interval");
                        isWebSocket = this.url.startsWith('ws');
                        if (!isWebSocket) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.startWithWebSocket()];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, this.startWithHttp()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    UrlInteropRegistryProvider.prototype.startWithHttp = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.urlDataLoader.fetchData(this.url)];
                    case 1:
                        response = _a.sent();
                        if (this.interval > 0) {
                            this.jsonInteropRegistryProvider = new JsonInteropRegistryProvider_1.JsonInteropRegistryProvider(response, this.urlDataLoader.fetchWithInterval(this.url, this.interval));
                        }
                        else {
                            this.jsonInteropRegistryProvider = new JsonInteropRegistryProvider_1.JsonInteropRegistryProvider(response);
                        }
                        this.started = true;
                        return [2 /*return*/];
                }
            });
        });
    };
    UrlInteropRegistryProvider.prototype.startWithWebSocket = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.webSocketDataProvider.getSingleMessage(this.url)];
                    case 1:
                        response = _a.sent();
                        if (this.interval > 0) {
                            this.jsonInteropRegistryProvider = new JsonInteropRegistryProvider_1.JsonInteropRegistryProvider(response, this.webSocketDataProvider.getData(this.url).throttleTime(this.interval));
                        }
                        else {
                            this.jsonInteropRegistryProvider = new JsonInteropRegistryProvider_1.JsonInteropRegistryProvider(response);
                        }
                        this.started = true;
                        return [2 /*return*/];
                }
            });
        });
    };
    return UrlInteropRegistryProvider;
}());
exports.UrlInteropRegistryProvider = UrlInteropRegistryProvider;
},{"./JsonInteropRegistryProvider":289,"@plexus-interop/common":243,"@plexus-interop/remote":309,"rxjs/Observable":121,"rxjs/add/operator/throttleTime":133,"tslib":180}],293:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MatchPatternFactory = /** @class */ (function () {
    function MatchPatternFactory() {
    }
    MatchPatternFactory.createMatcher = function (patterns) {
        return patterns && patterns.length > 0 ?
            new MultipleMatchersHolder(patterns.map(function (p) { return MatchPatternFactory.createSingleMatcher(p); }))
            : MatchPatternFactory.all;
    };
    MatchPatternFactory.createSingleMatcher = function (pattern) {
        if (pattern === '*') {
            return MatchPatternFactory.all;
        }
        if (pattern.endsWith('*')) {
            return new StartsWithMatcher(pattern.substr(0, pattern.length - 1));
        }
        return new ExactMatcher(pattern);
    };
    MatchPatternFactory.all = {
        isMatch: function () { return true; }
    };
    return MatchPatternFactory;
}());
exports.MatchPatternFactory = MatchPatternFactory;
var MultipleMatchersHolder = /** @class */ (function () {
    function MultipleMatchersHolder(matchers) {
        this.matchers = matchers;
    }
    MultipleMatchersHolder.prototype.isMatch = function (s) {
        return !!this.matchers.find(function (m) { return m.isMatch(s); });
    };
    return MultipleMatchersHolder;
}());
var StartsWithMatcher = /** @class */ (function () {
    function StartsWithMatcher(base) {
        this.base = base;
    }
    StartsWithMatcher.prototype.isMatch = function (s) {
        return s.startsWith(this.base);
    };
    return StartsWithMatcher;
}());
var ExactMatcher = /** @class */ (function () {
    function ExactMatcher(base) {
        this.base = base;
    }
    ExactMatcher.prototype.isMatch = function (s) {
        return s === this.base;
    };
    return ExactMatcher;
}());
},{}],294:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var MethodType;
(function (MethodType) {
    MethodType[MethodType["Unary"] = 0] = "Unary";
    MethodType[MethodType["ServerStreaming"] = 1] = "ServerStreaming";
    MethodType[MethodType["ClientStreaming"] = 2] = "ClientStreaming";
    MethodType[MethodType["DuplexStreaming"] = 3] = "DuplexStreaming";
})(MethodType = exports.MethodType || (exports.MethodType = {}));
},{}],295:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./MethodType"), exports);
},{"./MethodType":294,"tslib":180}],296:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var internal_client_protocol_1 = require("../gen/internal-client-protocol");
var CancelledCompletion = /** @class */ (function () {
    function CancelledCompletion() {
        this.status = internal_client_protocol_1.plexus.Completion.Status.Canceled;
    }
    return CancelledCompletion;
}());
exports.CancelledCompletion = CancelledCompletion;

},{"../gen/internal-client-protocol":303}],297:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ClientError = /** @class */ (function () {
    function ClientError(message, details) {
        if (message === void 0) { message = 'Unknown message'; }
        if (details === void 0) { details = 'Unknown details'; }
        this.message = message;
        this.details = details;
    }
    return ClientError;
}());
exports.ClientError = ClientError;

},{}],298:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var internal_client_protocol_1 = require("../gen/internal-client-protocol");
var ClientProtocolUtils = /** @class */ (function () {
    function ClientProtocolUtils() {
    }
    ClientProtocolUtils.createSummarizedCompletion = function () {
        var completions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            completions[_i] = arguments[_i];
        }
        var errors = [];
        completions = completions.filter(function (c) { return !!c; });
        completions.forEach(function (completion) {
            var status = completion.status;
            if (status === internal_client_protocol_1.plexus.Completion.Status.Canceled || status === internal_client_protocol_1.plexus.Completion.Status.Failed) {
                errors.push(completion.error || {
                    message: "Unknown error, completion status " + status
                });
            }
        });
        if (errors.length > 0) {
            var messages_1 = new Array();
            errors.forEach(function (error) {
                messages_1.push(error.message);
            });
            return {
                status: internal_client_protocol_1.plexus.Completion.Status.Failed,
                error: {
                    message: messages_1.join('\n')
                }
            };
        }
        else {
            return {
                status: internal_client_protocol_1.plexus.Completion.Status.Completed
            };
        }
    };
    ClientProtocolUtils.isSuccessCompletion = function (completion) {
        return completion && (completion.status === undefined || completion.status === internal_client_protocol_1.plexus.Completion.Status.Completed);
    };
    return ClientProtocolUtils;
}());
exports.ClientProtocolUtils = ClientProtocolUtils;

},{"../gen/internal-client-protocol":303}],299:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var internal_client_protocol_1 = require("../gen/internal-client-protocol");
var ClientError_1 = require("./ClientError");
var ErrorCompletion = /** @class */ (function () {
    function ErrorCompletion(error) {
        if (error === void 0) { error = new ClientError_1.ClientError(); }
        this.error = error;
        this.status = internal_client_protocol_1.plexus.Completion.Status.Failed;
        this.status = internal_client_protocol_1.plexus.Completion.Status.Failed;
    }
    return ErrorCompletion;
}());
exports.ErrorCompletion = ErrorCompletion;

},{"../gen/internal-client-protocol":303,"./ClientError":297}],300:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var internal_client_protocol_1 = require("../gen/internal-client-protocol");
var SuccessCompletion = /** @class */ (function () {
    function SuccessCompletion() {
        this.status = internal_client_protocol_1.plexus.Completion.Status.Completed;
    }
    return SuccessCompletion;
}());
exports.SuccessCompletion = SuccessCompletion;

},{"../gen/internal-client-protocol":303}],301:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var common_1 = require("@plexus-interop/common");
var Long = require("long");
var UniqueId = /** @class */ (function () {
    function UniqueId() {
    }
    UniqueId.prototype.toString = function () {
        return "" + longToString(this.hi) + longToString(this.lo);
    };
    UniqueId.generateNew = function () {
        return UniqueId.fromGuid(new common_1.GUID());
    };
    UniqueId.fromString = function (str) {
        return UniqueId.fromGuid(new common_1.GUID(str));
    };
    UniqueId.fromGuid = function (guid) {
        var guidString = guid.toString().replace(/-/g, '');
        var hiSth = guidString.substr(0, 16);
        var loStr = guidString.substr(16, 32);
        return UniqueId.fromProperties({
            lo: Long.fromString(loStr, true, 16),
            hi: Long.fromString(hiSth, true, 16)
        });
    };
    UniqueId.prototype.equals = function (other) {
        return other && other.toString() === this.toString();
    };
    UniqueId.fromProperties = function (props) {
        return Object.assign(new UniqueId(), props);
    };
    return UniqueId;
}());
exports.UniqueId = UniqueId;
function longToString(x) {
    return x ? x.toString(16).toUpperCase() : 'undefined';
}

},{"@plexus-interop/common":243,"long":82}],302:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
tslib_1.__exportStar(require("./CancelledCompletion"), exports);
tslib_1.__exportStar(require("./ClientError"), exports);
tslib_1.__exportStar(require("./ErrorCompletion"), exports);
tslib_1.__exportStar(require("./SuccessCompletion"), exports);
tslib_1.__exportStar(require("./ClientProtocolUtils"), exports);
tslib_1.__exportStar(require("./UniqueId"), exports);

},{"./CancelledCompletion":296,"./ClientError":297,"./ClientProtocolUtils":298,"./ErrorCompletion":299,"./SuccessCompletion":300,"./UniqueId":301,"tslib":180}],303:[function(require,module,exports){
/*eslint-disable block-scoped-var, no-redeclare, no-control-regex, no-prototype-builtins*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots.plexusClient || ($protobuf.roots.plexusClient = {});

$root.plexus = (function() {

    /**
     * Namespace plexus.
     * @exports plexus
     * @namespace
     */
    var plexus = {};

    plexus.interop = (function() {

        /**
         * Namespace interop.
         * @memberof plexus
         * @namespace
         */
        var interop = {};

        interop.protocol = (function() {

            /**
             * Namespace protocol.
             * @memberof plexus.interop
             * @namespace
             */
            var protocol = {};

            protocol.ConsumedServiceReference = (function() {

                /**
                 * Properties of a ConsumedServiceReference.
                 * @memberof plexus.interop.protocol
                 * @interface IConsumedServiceReference
                 * @property {string} [serviceId] ConsumedServiceReference serviceId
                 * @property {string} [serviceAlias] ConsumedServiceReference serviceAlias
                 */

                /**
                 * Constructs a new ConsumedServiceReference.
                 * @memberof plexus.interop.protocol
                 * @classdesc Represents a ConsumedServiceReference.
                 * @constructor
                 * @param {plexus.interop.protocol.IConsumedServiceReference=} [p] Properties to set
                 */
                function ConsumedServiceReference(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * ConsumedServiceReference serviceId.
                 * @member {string}serviceId
                 * @memberof plexus.interop.protocol.ConsumedServiceReference
                 * @instance
                 */
                ConsumedServiceReference.prototype.serviceId = "";

                /**
                 * ConsumedServiceReference serviceAlias.
                 * @member {string}serviceAlias
                 * @memberof plexus.interop.protocol.ConsumedServiceReference
                 * @instance
                 */
                ConsumedServiceReference.prototype.serviceAlias = "";

                /**
                 * Encodes the specified ConsumedServiceReference message. Does not implicitly {@link plexus.interop.protocol.ConsumedServiceReference.verify|verify} messages.
                 * @function encode
                 * @memberof plexus.interop.protocol.ConsumedServiceReference
                 * @static
                 * @param {plexus.interop.protocol.IConsumedServiceReference} m ConsumedServiceReference message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConsumedServiceReference.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.serviceId != null && m.hasOwnProperty("serviceId"))
                        w.uint32(10).string(m.serviceId);
                    if (m.serviceAlias != null && m.hasOwnProperty("serviceAlias"))
                        w.uint32(18).string(m.serviceAlias);
                    return w;
                };

                /**
                 * Decodes a ConsumedServiceReference message from the specified reader or buffer.
                 * @function decode
                 * @memberof plexus.interop.protocol.ConsumedServiceReference
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {plexus.interop.protocol.ConsumedServiceReference} ConsumedServiceReference
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConsumedServiceReference.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.interop.protocol.ConsumedServiceReference();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.serviceId = r.string();
                            break;
                        case 2:
                            m.serviceAlias = r.string();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                /**
                 * Creates a ConsumedServiceReference message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof plexus.interop.protocol.ConsumedServiceReference
                 * @static
                 * @param {Object.<string,*>} d Plain object
                 * @returns {plexus.interop.protocol.ConsumedServiceReference} ConsumedServiceReference
                 */
                ConsumedServiceReference.fromObject = function fromObject(d) {
                    if (d instanceof $root.plexus.interop.protocol.ConsumedServiceReference)
                        return d;
                    var m = new $root.plexus.interop.protocol.ConsumedServiceReference();
                    if (d.serviceId != null) {
                        m.serviceId = String(d.serviceId);
                    }
                    if (d.serviceAlias != null) {
                        m.serviceAlias = String(d.serviceAlias);
                    }
                    return m;
                };

                /**
                 * Creates a plain object from a ConsumedServiceReference message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof plexus.interop.protocol.ConsumedServiceReference
                 * @static
                 * @param {plexus.interop.protocol.ConsumedServiceReference} m ConsumedServiceReference
                 * @param {$protobuf.IConversionOptions} [o] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ConsumedServiceReference.toObject = function toObject(m, o) {
                    if (!o)
                        o = {};
                    var d = {};
                    if (o.defaults) {
                        d.serviceId = "";
                        d.serviceAlias = "";
                    }
                    if (m.serviceId != null && m.hasOwnProperty("serviceId")) {
                        d.serviceId = m.serviceId;
                    }
                    if (m.serviceAlias != null && m.hasOwnProperty("serviceAlias")) {
                        d.serviceAlias = m.serviceAlias;
                    }
                    return d;
                };

                /**
                 * Converts this ConsumedServiceReference to JSON.
                 * @function toJSON
                 * @memberof plexus.interop.protocol.ConsumedServiceReference
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ConsumedServiceReference.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ConsumedServiceReference;
            })();

            protocol.ConsumedMethodReference = (function() {

                /**
                 * Properties of a ConsumedMethodReference.
                 * @memberof plexus.interop.protocol
                 * @interface IConsumedMethodReference
                 * @property {plexus.interop.protocol.IConsumedServiceReference} [consumedService] ConsumedMethodReference consumedService
                 * @property {string} [methodId] ConsumedMethodReference methodId
                 */

                /**
                 * Constructs a new ConsumedMethodReference.
                 * @memberof plexus.interop.protocol
                 * @classdesc Represents a ConsumedMethodReference.
                 * @constructor
                 * @param {plexus.interop.protocol.IConsumedMethodReference=} [p] Properties to set
                 */
                function ConsumedMethodReference(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * ConsumedMethodReference consumedService.
                 * @member {(plexus.interop.protocol.IConsumedServiceReference|null|undefined)}consumedService
                 * @memberof plexus.interop.protocol.ConsumedMethodReference
                 * @instance
                 */
                ConsumedMethodReference.prototype.consumedService = null;

                /**
                 * ConsumedMethodReference methodId.
                 * @member {string}methodId
                 * @memberof plexus.interop.protocol.ConsumedMethodReference
                 * @instance
                 */
                ConsumedMethodReference.prototype.methodId = "";

                /**
                 * Encodes the specified ConsumedMethodReference message. Does not implicitly {@link plexus.interop.protocol.ConsumedMethodReference.verify|verify} messages.
                 * @function encode
                 * @memberof plexus.interop.protocol.ConsumedMethodReference
                 * @static
                 * @param {plexus.interop.protocol.IConsumedMethodReference} m ConsumedMethodReference message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConsumedMethodReference.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.consumedService != null && m.hasOwnProperty("consumedService"))
                        $root.plexus.interop.protocol.ConsumedServiceReference.encode(m.consumedService, w.uint32(10).fork()).ldelim();
                    if (m.methodId != null && m.hasOwnProperty("methodId"))
                        w.uint32(18).string(m.methodId);
                    return w;
                };

                /**
                 * Decodes a ConsumedMethodReference message from the specified reader or buffer.
                 * @function decode
                 * @memberof plexus.interop.protocol.ConsumedMethodReference
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {plexus.interop.protocol.ConsumedMethodReference} ConsumedMethodReference
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConsumedMethodReference.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.interop.protocol.ConsumedMethodReference();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.consumedService = $root.plexus.interop.protocol.ConsumedServiceReference.decode(r, r.uint32());
                            break;
                        case 2:
                            m.methodId = r.string();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                /**
                 * Creates a ConsumedMethodReference message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof plexus.interop.protocol.ConsumedMethodReference
                 * @static
                 * @param {Object.<string,*>} d Plain object
                 * @returns {plexus.interop.protocol.ConsumedMethodReference} ConsumedMethodReference
                 */
                ConsumedMethodReference.fromObject = function fromObject(d) {
                    if (d instanceof $root.plexus.interop.protocol.ConsumedMethodReference)
                        return d;
                    var m = new $root.plexus.interop.protocol.ConsumedMethodReference();
                    if (d.consumedService != null) {
                        if (typeof d.consumedService !== "object")
                            throw TypeError(".plexus.interop.protocol.ConsumedMethodReference.consumedService: object expected");
                        m.consumedService = $root.plexus.interop.protocol.ConsumedServiceReference.fromObject(d.consumedService);
                    }
                    if (d.methodId != null) {
                        m.methodId = String(d.methodId);
                    }
                    return m;
                };

                /**
                 * Creates a plain object from a ConsumedMethodReference message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof plexus.interop.protocol.ConsumedMethodReference
                 * @static
                 * @param {plexus.interop.protocol.ConsumedMethodReference} m ConsumedMethodReference
                 * @param {$protobuf.IConversionOptions} [o] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ConsumedMethodReference.toObject = function toObject(m, o) {
                    if (!o)
                        o = {};
                    var d = {};
                    if (o.defaults) {
                        d.consumedService = null;
                        d.methodId = "";
                    }
                    if (m.consumedService != null && m.hasOwnProperty("consumedService")) {
                        d.consumedService = $root.plexus.interop.protocol.ConsumedServiceReference.toObject(m.consumedService, o);
                    }
                    if (m.methodId != null && m.hasOwnProperty("methodId")) {
                        d.methodId = m.methodId;
                    }
                    return d;
                };

                /**
                 * Converts this ConsumedMethodReference to JSON.
                 * @function toJSON
                 * @memberof plexus.interop.protocol.ConsumedMethodReference
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ConsumedMethodReference.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ConsumedMethodReference;
            })();

            protocol.ProvidedServiceReference = (function() {

                /**
                 * Properties of a ProvidedServiceReference.
                 * @memberof plexus.interop.protocol
                 * @interface IProvidedServiceReference
                 * @property {string} [serviceId] ProvidedServiceReference serviceId
                 * @property {string} [serviceAlias] ProvidedServiceReference serviceAlias
                 * @property {string} [applicationId] ProvidedServiceReference applicationId
                 * @property {plexus.IUniqueId} [connectionId] ProvidedServiceReference connectionId
                 */

                /**
                 * Constructs a new ProvidedServiceReference.
                 * @memberof plexus.interop.protocol
                 * @classdesc Represents a ProvidedServiceReference.
                 * @constructor
                 * @param {plexus.interop.protocol.IProvidedServiceReference=} [p] Properties to set
                 */
                function ProvidedServiceReference(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * ProvidedServiceReference serviceId.
                 * @member {string}serviceId
                 * @memberof plexus.interop.protocol.ProvidedServiceReference
                 * @instance
                 */
                ProvidedServiceReference.prototype.serviceId = "";

                /**
                 * ProvidedServiceReference serviceAlias.
                 * @member {string}serviceAlias
                 * @memberof plexus.interop.protocol.ProvidedServiceReference
                 * @instance
                 */
                ProvidedServiceReference.prototype.serviceAlias = "";

                /**
                 * ProvidedServiceReference applicationId.
                 * @member {string}applicationId
                 * @memberof plexus.interop.protocol.ProvidedServiceReference
                 * @instance
                 */
                ProvidedServiceReference.prototype.applicationId = "";

                /**
                 * ProvidedServiceReference connectionId.
                 * @member {(plexus.IUniqueId|null|undefined)}connectionId
                 * @memberof plexus.interop.protocol.ProvidedServiceReference
                 * @instance
                 */
                ProvidedServiceReference.prototype.connectionId = null;

                /**
                 * Encodes the specified ProvidedServiceReference message. Does not implicitly {@link plexus.interop.protocol.ProvidedServiceReference.verify|verify} messages.
                 * @function encode
                 * @memberof plexus.interop.protocol.ProvidedServiceReference
                 * @static
                 * @param {plexus.interop.protocol.IProvidedServiceReference} m ProvidedServiceReference message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProvidedServiceReference.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.serviceId != null && m.hasOwnProperty("serviceId"))
                        w.uint32(10).string(m.serviceId);
                    if (m.serviceAlias != null && m.hasOwnProperty("serviceAlias"))
                        w.uint32(18).string(m.serviceAlias);
                    if (m.applicationId != null && m.hasOwnProperty("applicationId"))
                        w.uint32(26).string(m.applicationId);
                    if (m.connectionId != null && m.hasOwnProperty("connectionId"))
                        $root.plexus.UniqueId.encode(m.connectionId, w.uint32(34).fork()).ldelim();
                    return w;
                };

                /**
                 * Decodes a ProvidedServiceReference message from the specified reader or buffer.
                 * @function decode
                 * @memberof plexus.interop.protocol.ProvidedServiceReference
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {plexus.interop.protocol.ProvidedServiceReference} ProvidedServiceReference
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProvidedServiceReference.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.interop.protocol.ProvidedServiceReference();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.serviceId = r.string();
                            break;
                        case 2:
                            m.serviceAlias = r.string();
                            break;
                        case 3:
                            m.applicationId = r.string();
                            break;
                        case 4:
                            m.connectionId = $root.plexus.UniqueId.decode(r, r.uint32());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                /**
                 * Creates a ProvidedServiceReference message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof plexus.interop.protocol.ProvidedServiceReference
                 * @static
                 * @param {Object.<string,*>} d Plain object
                 * @returns {plexus.interop.protocol.ProvidedServiceReference} ProvidedServiceReference
                 */
                ProvidedServiceReference.fromObject = function fromObject(d) {
                    if (d instanceof $root.plexus.interop.protocol.ProvidedServiceReference)
                        return d;
                    var m = new $root.plexus.interop.protocol.ProvidedServiceReference();
                    if (d.serviceId != null) {
                        m.serviceId = String(d.serviceId);
                    }
                    if (d.serviceAlias != null) {
                        m.serviceAlias = String(d.serviceAlias);
                    }
                    if (d.applicationId != null) {
                        m.applicationId = String(d.applicationId);
                    }
                    if (d.connectionId != null) {
                        if (typeof d.connectionId !== "object")
                            throw TypeError(".plexus.interop.protocol.ProvidedServiceReference.connectionId: object expected");
                        m.connectionId = $root.plexus.UniqueId.fromObject(d.connectionId);
                    }
                    return m;
                };

                /**
                 * Creates a plain object from a ProvidedServiceReference message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof plexus.interop.protocol.ProvidedServiceReference
                 * @static
                 * @param {plexus.interop.protocol.ProvidedServiceReference} m ProvidedServiceReference
                 * @param {$protobuf.IConversionOptions} [o] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ProvidedServiceReference.toObject = function toObject(m, o) {
                    if (!o)
                        o = {};
                    var d = {};
                    if (o.defaults) {
                        d.serviceId = "";
                        d.serviceAlias = "";
                        d.applicationId = "";
                        d.connectionId = null;
                    }
                    if (m.serviceId != null && m.hasOwnProperty("serviceId")) {
                        d.serviceId = m.serviceId;
                    }
                    if (m.serviceAlias != null && m.hasOwnProperty("serviceAlias")) {
                        d.serviceAlias = m.serviceAlias;
                    }
                    if (m.applicationId != null && m.hasOwnProperty("applicationId")) {
                        d.applicationId = m.applicationId;
                    }
                    if (m.connectionId != null && m.hasOwnProperty("connectionId")) {
                        d.connectionId = $root.plexus.UniqueId.toObject(m.connectionId, o);
                    }
                    return d;
                };

                /**
                 * Converts this ProvidedServiceReference to JSON.
                 * @function toJSON
                 * @memberof plexus.interop.protocol.ProvidedServiceReference
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ProvidedServiceReference.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ProvidedServiceReference;
            })();

            protocol.ProvidedMethodReference = (function() {

                /**
                 * Properties of a ProvidedMethodReference.
                 * @memberof plexus.interop.protocol
                 * @interface IProvidedMethodReference
                 * @property {plexus.interop.protocol.IProvidedServiceReference} [providedService] ProvidedMethodReference providedService
                 * @property {string} [methodId] ProvidedMethodReference methodId
                 */

                /**
                 * Constructs a new ProvidedMethodReference.
                 * @memberof plexus.interop.protocol
                 * @classdesc Represents a ProvidedMethodReference.
                 * @constructor
                 * @param {plexus.interop.protocol.IProvidedMethodReference=} [p] Properties to set
                 */
                function ProvidedMethodReference(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * ProvidedMethodReference providedService.
                 * @member {(plexus.interop.protocol.IProvidedServiceReference|null|undefined)}providedService
                 * @memberof plexus.interop.protocol.ProvidedMethodReference
                 * @instance
                 */
                ProvidedMethodReference.prototype.providedService = null;

                /**
                 * ProvidedMethodReference methodId.
                 * @member {string}methodId
                 * @memberof plexus.interop.protocol.ProvidedMethodReference
                 * @instance
                 */
                ProvidedMethodReference.prototype.methodId = "";

                /**
                 * Encodes the specified ProvidedMethodReference message. Does not implicitly {@link plexus.interop.protocol.ProvidedMethodReference.verify|verify} messages.
                 * @function encode
                 * @memberof plexus.interop.protocol.ProvidedMethodReference
                 * @static
                 * @param {plexus.interop.protocol.IProvidedMethodReference} m ProvidedMethodReference message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProvidedMethodReference.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.providedService != null && m.hasOwnProperty("providedService"))
                        $root.plexus.interop.protocol.ProvidedServiceReference.encode(m.providedService, w.uint32(10).fork()).ldelim();
                    if (m.methodId != null && m.hasOwnProperty("methodId"))
                        w.uint32(18).string(m.methodId);
                    return w;
                };

                /**
                 * Decodes a ProvidedMethodReference message from the specified reader or buffer.
                 * @function decode
                 * @memberof plexus.interop.protocol.ProvidedMethodReference
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {plexus.interop.protocol.ProvidedMethodReference} ProvidedMethodReference
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProvidedMethodReference.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.interop.protocol.ProvidedMethodReference();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.providedService = $root.plexus.interop.protocol.ProvidedServiceReference.decode(r, r.uint32());
                            break;
                        case 2:
                            m.methodId = r.string();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                /**
                 * Creates a ProvidedMethodReference message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof plexus.interop.protocol.ProvidedMethodReference
                 * @static
                 * @param {Object.<string,*>} d Plain object
                 * @returns {plexus.interop.protocol.ProvidedMethodReference} ProvidedMethodReference
                 */
                ProvidedMethodReference.fromObject = function fromObject(d) {
                    if (d instanceof $root.plexus.interop.protocol.ProvidedMethodReference)
                        return d;
                    var m = new $root.plexus.interop.protocol.ProvidedMethodReference();
                    if (d.providedService != null) {
                        if (typeof d.providedService !== "object")
                            throw TypeError(".plexus.interop.protocol.ProvidedMethodReference.providedService: object expected");
                        m.providedService = $root.plexus.interop.protocol.ProvidedServiceReference.fromObject(d.providedService);
                    }
                    if (d.methodId != null) {
                        m.methodId = String(d.methodId);
                    }
                    return m;
                };

                /**
                 * Creates a plain object from a ProvidedMethodReference message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof plexus.interop.protocol.ProvidedMethodReference
                 * @static
                 * @param {plexus.interop.protocol.ProvidedMethodReference} m ProvidedMethodReference
                 * @param {$protobuf.IConversionOptions} [o] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ProvidedMethodReference.toObject = function toObject(m, o) {
                    if (!o)
                        o = {};
                    var d = {};
                    if (o.defaults) {
                        d.providedService = null;
                        d.methodId = "";
                    }
                    if (m.providedService != null && m.hasOwnProperty("providedService")) {
                        d.providedService = $root.plexus.interop.protocol.ProvidedServiceReference.toObject(m.providedService, o);
                    }
                    if (m.methodId != null && m.hasOwnProperty("methodId")) {
                        d.methodId = m.methodId;
                    }
                    return d;
                };

                /**
                 * Converts this ProvidedMethodReference to JSON.
                 * @function toJSON
                 * @memberof plexus.interop.protocol.ProvidedMethodReference
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ProvidedMethodReference.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ProvidedMethodReference;
            })();

            protocol.ConnectRequest = (function() {

                /**
                 * Properties of a ConnectRequest.
                 * @memberof plexus.interop.protocol
                 * @interface IConnectRequest
                 * @property {string} [applicationId] ConnectRequest applicationId
                 * @property {plexus.IUniqueId} [applicationInstanceId] ConnectRequest applicationInstanceId
                 */

                /**
                 * Constructs a new ConnectRequest.
                 * @memberof plexus.interop.protocol
                 * @classdesc Represents a ConnectRequest.
                 * @constructor
                 * @param {plexus.interop.protocol.IConnectRequest=} [p] Properties to set
                 */
                function ConnectRequest(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * ConnectRequest applicationId.
                 * @member {string}applicationId
                 * @memberof plexus.interop.protocol.ConnectRequest
                 * @instance
                 */
                ConnectRequest.prototype.applicationId = "";

                /**
                 * ConnectRequest applicationInstanceId.
                 * @member {(plexus.IUniqueId|null|undefined)}applicationInstanceId
                 * @memberof plexus.interop.protocol.ConnectRequest
                 * @instance
                 */
                ConnectRequest.prototype.applicationInstanceId = null;

                /**
                 * Encodes the specified ConnectRequest message. Does not implicitly {@link plexus.interop.protocol.ConnectRequest.verify|verify} messages.
                 * @function encode
                 * @memberof plexus.interop.protocol.ConnectRequest
                 * @static
                 * @param {plexus.interop.protocol.IConnectRequest} m ConnectRequest message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConnectRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.applicationId != null && m.hasOwnProperty("applicationId"))
                        w.uint32(10).string(m.applicationId);
                    if (m.applicationInstanceId != null && m.hasOwnProperty("applicationInstanceId"))
                        $root.plexus.UniqueId.encode(m.applicationInstanceId, w.uint32(18).fork()).ldelim();
                    return w;
                };

                /**
                 * Decodes a ConnectRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof plexus.interop.protocol.ConnectRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {plexus.interop.protocol.ConnectRequest} ConnectRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConnectRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.interop.protocol.ConnectRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.applicationId = r.string();
                            break;
                        case 2:
                            m.applicationInstanceId = $root.plexus.UniqueId.decode(r, r.uint32());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                /**
                 * Creates a ConnectRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof plexus.interop.protocol.ConnectRequest
                 * @static
                 * @param {Object.<string,*>} d Plain object
                 * @returns {plexus.interop.protocol.ConnectRequest} ConnectRequest
                 */
                ConnectRequest.fromObject = function fromObject(d) {
                    if (d instanceof $root.plexus.interop.protocol.ConnectRequest)
                        return d;
                    var m = new $root.plexus.interop.protocol.ConnectRequest();
                    if (d.applicationId != null) {
                        m.applicationId = String(d.applicationId);
                    }
                    if (d.applicationInstanceId != null) {
                        if (typeof d.applicationInstanceId !== "object")
                            throw TypeError(".plexus.interop.protocol.ConnectRequest.applicationInstanceId: object expected");
                        m.applicationInstanceId = $root.plexus.UniqueId.fromObject(d.applicationInstanceId);
                    }
                    return m;
                };

                /**
                 * Creates a plain object from a ConnectRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof plexus.interop.protocol.ConnectRequest
                 * @static
                 * @param {plexus.interop.protocol.ConnectRequest} m ConnectRequest
                 * @param {$protobuf.IConversionOptions} [o] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ConnectRequest.toObject = function toObject(m, o) {
                    if (!o)
                        o = {};
                    var d = {};
                    if (o.defaults) {
                        d.applicationId = "";
                        d.applicationInstanceId = null;
                    }
                    if (m.applicationId != null && m.hasOwnProperty("applicationId")) {
                        d.applicationId = m.applicationId;
                    }
                    if (m.applicationInstanceId != null && m.hasOwnProperty("applicationInstanceId")) {
                        d.applicationInstanceId = $root.plexus.UniqueId.toObject(m.applicationInstanceId, o);
                    }
                    return d;
                };

                /**
                 * Converts this ConnectRequest to JSON.
                 * @function toJSON
                 * @memberof plexus.interop.protocol.ConnectRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ConnectRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ConnectRequest;
            })();

            protocol.ConnectResponse = (function() {

                /**
                 * Properties of a ConnectResponse.
                 * @memberof plexus.interop.protocol
                 * @interface IConnectResponse
                 * @property {plexus.IUniqueId} [connectionId] ConnectResponse connectionId
                 */

                /**
                 * Constructs a new ConnectResponse.
                 * @memberof plexus.interop.protocol
                 * @classdesc Represents a ConnectResponse.
                 * @constructor
                 * @param {plexus.interop.protocol.IConnectResponse=} [p] Properties to set
                 */
                function ConnectResponse(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * ConnectResponse connectionId.
                 * @member {(plexus.IUniqueId|null|undefined)}connectionId
                 * @memberof plexus.interop.protocol.ConnectResponse
                 * @instance
                 */
                ConnectResponse.prototype.connectionId = null;

                /**
                 * Encodes the specified ConnectResponse message. Does not implicitly {@link plexus.interop.protocol.ConnectResponse.verify|verify} messages.
                 * @function encode
                 * @memberof plexus.interop.protocol.ConnectResponse
                 * @static
                 * @param {plexus.interop.protocol.IConnectResponse} m ConnectResponse message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConnectResponse.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.connectionId != null && m.hasOwnProperty("connectionId"))
                        $root.plexus.UniqueId.encode(m.connectionId, w.uint32(10).fork()).ldelim();
                    return w;
                };

                /**
                 * Decodes a ConnectResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof plexus.interop.protocol.ConnectResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {plexus.interop.protocol.ConnectResponse} ConnectResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConnectResponse.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.interop.protocol.ConnectResponse();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.connectionId = $root.plexus.UniqueId.decode(r, r.uint32());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                /**
                 * Creates a ConnectResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof plexus.interop.protocol.ConnectResponse
                 * @static
                 * @param {Object.<string,*>} d Plain object
                 * @returns {plexus.interop.protocol.ConnectResponse} ConnectResponse
                 */
                ConnectResponse.fromObject = function fromObject(d) {
                    if (d instanceof $root.plexus.interop.protocol.ConnectResponse)
                        return d;
                    var m = new $root.plexus.interop.protocol.ConnectResponse();
                    if (d.connectionId != null) {
                        if (typeof d.connectionId !== "object")
                            throw TypeError(".plexus.interop.protocol.ConnectResponse.connectionId: object expected");
                        m.connectionId = $root.plexus.UniqueId.fromObject(d.connectionId);
                    }
                    return m;
                };

                /**
                 * Creates a plain object from a ConnectResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof plexus.interop.protocol.ConnectResponse
                 * @static
                 * @param {plexus.interop.protocol.ConnectResponse} m ConnectResponse
                 * @param {$protobuf.IConversionOptions} [o] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ConnectResponse.toObject = function toObject(m, o) {
                    if (!o)
                        o = {};
                    var d = {};
                    if (o.defaults) {
                        d.connectionId = null;
                    }
                    if (m.connectionId != null && m.hasOwnProperty("connectionId")) {
                        d.connectionId = $root.plexus.UniqueId.toObject(m.connectionId, o);
                    }
                    return d;
                };

                /**
                 * Converts this ConnectResponse to JSON.
                 * @function toJSON
                 * @memberof plexus.interop.protocol.ConnectResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ConnectResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ConnectResponse;
            })();

            protocol.ClientToBrokerRequestEnvelope = (function() {

                /**
                 * Properties of a ClientToBrokerRequestEnvelope.
                 * @memberof plexus.interop.protocol
                 * @interface IClientToBrokerRequestEnvelope
                 * @property {plexus.interop.protocol.IInvocationStartRequest} [invocationStartRequest] ClientToBrokerRequestEnvelope invocationStartRequest
                 * @property {plexus.interop.protocol.IServiceDiscoveryRequest} [serviceDiscoveryRequest] ClientToBrokerRequestEnvelope serviceDiscoveryRequest
                 * @property {plexus.interop.protocol.IMethodDiscoveryRequest} [methodDiscoveryRequest] ClientToBrokerRequestEnvelope methodDiscoveryRequest
                 */

                /**
                 * Constructs a new ClientToBrokerRequestEnvelope.
                 * @memberof plexus.interop.protocol
                 * @classdesc Represents a ClientToBrokerRequestEnvelope.
                 * @constructor
                 * @param {plexus.interop.protocol.IClientToBrokerRequestEnvelope=} [p] Properties to set
                 */
                function ClientToBrokerRequestEnvelope(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * ClientToBrokerRequestEnvelope invocationStartRequest.
                 * @member {(plexus.interop.protocol.IInvocationStartRequest|null|undefined)}invocationStartRequest
                 * @memberof plexus.interop.protocol.ClientToBrokerRequestEnvelope
                 * @instance
                 */
                ClientToBrokerRequestEnvelope.prototype.invocationStartRequest = null;

                /**
                 * ClientToBrokerRequestEnvelope serviceDiscoveryRequest.
                 * @member {(plexus.interop.protocol.IServiceDiscoveryRequest|null|undefined)}serviceDiscoveryRequest
                 * @memberof plexus.interop.protocol.ClientToBrokerRequestEnvelope
                 * @instance
                 */
                ClientToBrokerRequestEnvelope.prototype.serviceDiscoveryRequest = null;

                /**
                 * ClientToBrokerRequestEnvelope methodDiscoveryRequest.
                 * @member {(plexus.interop.protocol.IMethodDiscoveryRequest|null|undefined)}methodDiscoveryRequest
                 * @memberof plexus.interop.protocol.ClientToBrokerRequestEnvelope
                 * @instance
                 */
                ClientToBrokerRequestEnvelope.prototype.methodDiscoveryRequest = null;

                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;

                /**
                 * ClientToBrokerRequestEnvelope payload.
                 * @member {string|undefined} payload
                 * @memberof plexus.interop.protocol.ClientToBrokerRequestEnvelope
                 * @instance
                 */
                Object.defineProperty(ClientToBrokerRequestEnvelope.prototype, "payload", {
                    get: $util.oneOfGetter($oneOfFields = ["invocationStartRequest", "serviceDiscoveryRequest", "methodDiscoveryRequest"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Encodes the specified ClientToBrokerRequestEnvelope message. Does not implicitly {@link plexus.interop.protocol.ClientToBrokerRequestEnvelope.verify|verify} messages.
                 * @function encode
                 * @memberof plexus.interop.protocol.ClientToBrokerRequestEnvelope
                 * @static
                 * @param {plexus.interop.protocol.IClientToBrokerRequestEnvelope} m ClientToBrokerRequestEnvelope message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ClientToBrokerRequestEnvelope.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.invocationStartRequest != null && m.hasOwnProperty("invocationStartRequest"))
                        $root.plexus.interop.protocol.InvocationStartRequest.encode(m.invocationStartRequest, w.uint32(10).fork()).ldelim();
                    if (m.serviceDiscoveryRequest != null && m.hasOwnProperty("serviceDiscoveryRequest"))
                        $root.plexus.interop.protocol.ServiceDiscoveryRequest.encode(m.serviceDiscoveryRequest, w.uint32(18).fork()).ldelim();
                    if (m.methodDiscoveryRequest != null && m.hasOwnProperty("methodDiscoveryRequest"))
                        $root.plexus.interop.protocol.MethodDiscoveryRequest.encode(m.methodDiscoveryRequest, w.uint32(26).fork()).ldelim();
                    return w;
                };

                /**
                 * Decodes a ClientToBrokerRequestEnvelope message from the specified reader or buffer.
                 * @function decode
                 * @memberof plexus.interop.protocol.ClientToBrokerRequestEnvelope
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {plexus.interop.protocol.ClientToBrokerRequestEnvelope} ClientToBrokerRequestEnvelope
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ClientToBrokerRequestEnvelope.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.interop.protocol.ClientToBrokerRequestEnvelope();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.invocationStartRequest = $root.plexus.interop.protocol.InvocationStartRequest.decode(r, r.uint32());
                            break;
                        case 2:
                            m.serviceDiscoveryRequest = $root.plexus.interop.protocol.ServiceDiscoveryRequest.decode(r, r.uint32());
                            break;
                        case 3:
                            m.methodDiscoveryRequest = $root.plexus.interop.protocol.MethodDiscoveryRequest.decode(r, r.uint32());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                /**
                 * Creates a ClientToBrokerRequestEnvelope message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof plexus.interop.protocol.ClientToBrokerRequestEnvelope
                 * @static
                 * @param {Object.<string,*>} d Plain object
                 * @returns {plexus.interop.protocol.ClientToBrokerRequestEnvelope} ClientToBrokerRequestEnvelope
                 */
                ClientToBrokerRequestEnvelope.fromObject = function fromObject(d) {
                    if (d instanceof $root.plexus.interop.protocol.ClientToBrokerRequestEnvelope)
                        return d;
                    var m = new $root.plexus.interop.protocol.ClientToBrokerRequestEnvelope();
                    if (d.invocationStartRequest != null) {
                        if (typeof d.invocationStartRequest !== "object")
                            throw TypeError(".plexus.interop.protocol.ClientToBrokerRequestEnvelope.invocationStartRequest: object expected");
                        m.invocationStartRequest = $root.plexus.interop.protocol.InvocationStartRequest.fromObject(d.invocationStartRequest);
                    }
                    if (d.serviceDiscoveryRequest != null) {
                        if (typeof d.serviceDiscoveryRequest !== "object")
                            throw TypeError(".plexus.interop.protocol.ClientToBrokerRequestEnvelope.serviceDiscoveryRequest: object expected");
                        m.serviceDiscoveryRequest = $root.plexus.interop.protocol.ServiceDiscoveryRequest.fromObject(d.serviceDiscoveryRequest);
                    }
                    if (d.methodDiscoveryRequest != null) {
                        if (typeof d.methodDiscoveryRequest !== "object")
                            throw TypeError(".plexus.interop.protocol.ClientToBrokerRequestEnvelope.methodDiscoveryRequest: object expected");
                        m.methodDiscoveryRequest = $root.plexus.interop.protocol.MethodDiscoveryRequest.fromObject(d.methodDiscoveryRequest);
                    }
                    return m;
                };

                /**
                 * Creates a plain object from a ClientToBrokerRequestEnvelope message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof plexus.interop.protocol.ClientToBrokerRequestEnvelope
                 * @static
                 * @param {plexus.interop.protocol.ClientToBrokerRequestEnvelope} m ClientToBrokerRequestEnvelope
                 * @param {$protobuf.IConversionOptions} [o] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ClientToBrokerRequestEnvelope.toObject = function toObject(m, o) {
                    if (!o)
                        o = {};
                    var d = {};
                    if (m.invocationStartRequest != null && m.hasOwnProperty("invocationStartRequest")) {
                        d.invocationStartRequest = $root.plexus.interop.protocol.InvocationStartRequest.toObject(m.invocationStartRequest, o);
                        if (o.oneofs)
                            d.payload = "invocationStartRequest";
                    }
                    if (m.serviceDiscoveryRequest != null && m.hasOwnProperty("serviceDiscoveryRequest")) {
                        d.serviceDiscoveryRequest = $root.plexus.interop.protocol.ServiceDiscoveryRequest.toObject(m.serviceDiscoveryRequest, o);
                        if (o.oneofs)
                            d.payload = "serviceDiscoveryRequest";
                    }
                    if (m.methodDiscoveryRequest != null && m.hasOwnProperty("methodDiscoveryRequest")) {
                        d.methodDiscoveryRequest = $root.plexus.interop.protocol.MethodDiscoveryRequest.toObject(m.methodDiscoveryRequest, o);
                        if (o.oneofs)
                            d.payload = "methodDiscoveryRequest";
                    }
                    return d;
                };

                /**
                 * Converts this ClientToBrokerRequestEnvelope to JSON.
                 * @function toJSON
                 * @memberof plexus.interop.protocol.ClientToBrokerRequestEnvelope
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ClientToBrokerRequestEnvelope.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ClientToBrokerRequestEnvelope;
            })();

            protocol.BrokerToClientRequestEnvelope = (function() {

                /**
                 * Properties of a BrokerToClientRequestEnvelope.
                 * @memberof plexus.interop.protocol
                 * @interface IBrokerToClientRequestEnvelope
                 * @property {plexus.interop.protocol.IInvocationStartRequested} [invocationStartRequested] BrokerToClientRequestEnvelope invocationStartRequested
                 */

                /**
                 * Constructs a new BrokerToClientRequestEnvelope.
                 * @memberof plexus.interop.protocol
                 * @classdesc Represents a BrokerToClientRequestEnvelope.
                 * @constructor
                 * @param {plexus.interop.protocol.IBrokerToClientRequestEnvelope=} [p] Properties to set
                 */
                function BrokerToClientRequestEnvelope(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * BrokerToClientRequestEnvelope invocationStartRequested.
                 * @member {(plexus.interop.protocol.IInvocationStartRequested|null|undefined)}invocationStartRequested
                 * @memberof plexus.interop.protocol.BrokerToClientRequestEnvelope
                 * @instance
                 */
                BrokerToClientRequestEnvelope.prototype.invocationStartRequested = null;

                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;

                /**
                 * BrokerToClientRequestEnvelope payload.
                 * @member {string|undefined} payload
                 * @memberof plexus.interop.protocol.BrokerToClientRequestEnvelope
                 * @instance
                 */
                Object.defineProperty(BrokerToClientRequestEnvelope.prototype, "payload", {
                    get: $util.oneOfGetter($oneOfFields = ["invocationStartRequested"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Encodes the specified BrokerToClientRequestEnvelope message. Does not implicitly {@link plexus.interop.protocol.BrokerToClientRequestEnvelope.verify|verify} messages.
                 * @function encode
                 * @memberof plexus.interop.protocol.BrokerToClientRequestEnvelope
                 * @static
                 * @param {plexus.interop.protocol.IBrokerToClientRequestEnvelope} m BrokerToClientRequestEnvelope message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BrokerToClientRequestEnvelope.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.invocationStartRequested != null && m.hasOwnProperty("invocationStartRequested"))
                        $root.plexus.interop.protocol.InvocationStartRequested.encode(m.invocationStartRequested, w.uint32(10).fork()).ldelim();
                    return w;
                };

                /**
                 * Decodes a BrokerToClientRequestEnvelope message from the specified reader or buffer.
                 * @function decode
                 * @memberof plexus.interop.protocol.BrokerToClientRequestEnvelope
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {plexus.interop.protocol.BrokerToClientRequestEnvelope} BrokerToClientRequestEnvelope
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BrokerToClientRequestEnvelope.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.interop.protocol.BrokerToClientRequestEnvelope();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.invocationStartRequested = $root.plexus.interop.protocol.InvocationStartRequested.decode(r, r.uint32());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                /**
                 * Creates a BrokerToClientRequestEnvelope message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof plexus.interop.protocol.BrokerToClientRequestEnvelope
                 * @static
                 * @param {Object.<string,*>} d Plain object
                 * @returns {plexus.interop.protocol.BrokerToClientRequestEnvelope} BrokerToClientRequestEnvelope
                 */
                BrokerToClientRequestEnvelope.fromObject = function fromObject(d) {
                    if (d instanceof $root.plexus.interop.protocol.BrokerToClientRequestEnvelope)
                        return d;
                    var m = new $root.plexus.interop.protocol.BrokerToClientRequestEnvelope();
                    if (d.invocationStartRequested != null) {
                        if (typeof d.invocationStartRequested !== "object")
                            throw TypeError(".plexus.interop.protocol.BrokerToClientRequestEnvelope.invocationStartRequested: object expected");
                        m.invocationStartRequested = $root.plexus.interop.protocol.InvocationStartRequested.fromObject(d.invocationStartRequested);
                    }
                    return m;
                };

                /**
                 * Creates a plain object from a BrokerToClientRequestEnvelope message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof plexus.interop.protocol.BrokerToClientRequestEnvelope
                 * @static
                 * @param {plexus.interop.protocol.BrokerToClientRequestEnvelope} m BrokerToClientRequestEnvelope
                 * @param {$protobuf.IConversionOptions} [o] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BrokerToClientRequestEnvelope.toObject = function toObject(m, o) {
                    if (!o)
                        o = {};
                    var d = {};
                    if (m.invocationStartRequested != null && m.hasOwnProperty("invocationStartRequested")) {
                        d.invocationStartRequested = $root.plexus.interop.protocol.InvocationStartRequested.toObject(m.invocationStartRequested, o);
                        if (o.oneofs)
                            d.payload = "invocationStartRequested";
                    }
                    return d;
                };

                /**
                 * Converts this BrokerToClientRequestEnvelope to JSON.
                 * @function toJSON
                 * @memberof plexus.interop.protocol.BrokerToClientRequestEnvelope
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BrokerToClientRequestEnvelope.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return BrokerToClientRequestEnvelope;
            })();

            protocol.InvocationStartRequest = (function() {

                /**
                 * Properties of an InvocationStartRequest.
                 * @memberof plexus.interop.protocol
                 * @interface IInvocationStartRequest
                 * @property {plexus.interop.protocol.IConsumedMethodReference} [consumedMethod] InvocationStartRequest consumedMethod
                 * @property {plexus.interop.protocol.IProvidedMethodReference} [providedMethod] InvocationStartRequest providedMethod
                 */

                /**
                 * Constructs a new InvocationStartRequest.
                 * @memberof plexus.interop.protocol
                 * @classdesc Represents an InvocationStartRequest.
                 * @constructor
                 * @param {plexus.interop.protocol.IInvocationStartRequest=} [p] Properties to set
                 */
                function InvocationStartRequest(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * InvocationStartRequest consumedMethod.
                 * @member {(plexus.interop.protocol.IConsumedMethodReference|null|undefined)}consumedMethod
                 * @memberof plexus.interop.protocol.InvocationStartRequest
                 * @instance
                 */
                InvocationStartRequest.prototype.consumedMethod = null;

                /**
                 * InvocationStartRequest providedMethod.
                 * @member {(plexus.interop.protocol.IProvidedMethodReference|null|undefined)}providedMethod
                 * @memberof plexus.interop.protocol.InvocationStartRequest
                 * @instance
                 */
                InvocationStartRequest.prototype.providedMethod = null;

                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;

                /**
                 * InvocationStartRequest target.
                 * @member {string|undefined} target
                 * @memberof plexus.interop.protocol.InvocationStartRequest
                 * @instance
                 */
                Object.defineProperty(InvocationStartRequest.prototype, "target", {
                    get: $util.oneOfGetter($oneOfFields = ["consumedMethod", "providedMethod"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Encodes the specified InvocationStartRequest message. Does not implicitly {@link plexus.interop.protocol.InvocationStartRequest.verify|verify} messages.
                 * @function encode
                 * @memberof plexus.interop.protocol.InvocationStartRequest
                 * @static
                 * @param {plexus.interop.protocol.IInvocationStartRequest} m InvocationStartRequest message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InvocationStartRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.consumedMethod != null && m.hasOwnProperty("consumedMethod"))
                        $root.plexus.interop.protocol.ConsumedMethodReference.encode(m.consumedMethod, w.uint32(10).fork()).ldelim();
                    if (m.providedMethod != null && m.hasOwnProperty("providedMethod"))
                        $root.plexus.interop.protocol.ProvidedMethodReference.encode(m.providedMethod, w.uint32(18).fork()).ldelim();
                    return w;
                };

                /**
                 * Decodes an InvocationStartRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof plexus.interop.protocol.InvocationStartRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {plexus.interop.protocol.InvocationStartRequest} InvocationStartRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InvocationStartRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.interop.protocol.InvocationStartRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.consumedMethod = $root.plexus.interop.protocol.ConsumedMethodReference.decode(r, r.uint32());
                            break;
                        case 2:
                            m.providedMethod = $root.plexus.interop.protocol.ProvidedMethodReference.decode(r, r.uint32());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                /**
                 * Creates an InvocationStartRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof plexus.interop.protocol.InvocationStartRequest
                 * @static
                 * @param {Object.<string,*>} d Plain object
                 * @returns {plexus.interop.protocol.InvocationStartRequest} InvocationStartRequest
                 */
                InvocationStartRequest.fromObject = function fromObject(d) {
                    if (d instanceof $root.plexus.interop.protocol.InvocationStartRequest)
                        return d;
                    var m = new $root.plexus.interop.protocol.InvocationStartRequest();
                    if (d.consumedMethod != null) {
                        if (typeof d.consumedMethod !== "object")
                            throw TypeError(".plexus.interop.protocol.InvocationStartRequest.consumedMethod: object expected");
                        m.consumedMethod = $root.plexus.interop.protocol.ConsumedMethodReference.fromObject(d.consumedMethod);
                    }
                    if (d.providedMethod != null) {
                        if (typeof d.providedMethod !== "object")
                            throw TypeError(".plexus.interop.protocol.InvocationStartRequest.providedMethod: object expected");
                        m.providedMethod = $root.plexus.interop.protocol.ProvidedMethodReference.fromObject(d.providedMethod);
                    }
                    return m;
                };

                /**
                 * Creates a plain object from an InvocationStartRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof plexus.interop.protocol.InvocationStartRequest
                 * @static
                 * @param {plexus.interop.protocol.InvocationStartRequest} m InvocationStartRequest
                 * @param {$protobuf.IConversionOptions} [o] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InvocationStartRequest.toObject = function toObject(m, o) {
                    if (!o)
                        o = {};
                    var d = {};
                    if (m.consumedMethod != null && m.hasOwnProperty("consumedMethod")) {
                        d.consumedMethod = $root.plexus.interop.protocol.ConsumedMethodReference.toObject(m.consumedMethod, o);
                        if (o.oneofs)
                            d.target = "consumedMethod";
                    }
                    if (m.providedMethod != null && m.hasOwnProperty("providedMethod")) {
                        d.providedMethod = $root.plexus.interop.protocol.ProvidedMethodReference.toObject(m.providedMethod, o);
                        if (o.oneofs)
                            d.target = "providedMethod";
                    }
                    return d;
                };

                /**
                 * Converts this InvocationStartRequest to JSON.
                 * @function toJSON
                 * @memberof plexus.interop.protocol.InvocationStartRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InvocationStartRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return InvocationStartRequest;
            })();

            protocol.InvocationStarting = (function() {

                /**
                 * Properties of an InvocationStarting.
                 * @memberof plexus.interop.protocol
                 * @interface IInvocationStarting
                 */

                /**
                 * Constructs a new InvocationStarting.
                 * @memberof plexus.interop.protocol
                 * @classdesc Represents an InvocationStarting.
                 * @constructor
                 * @param {plexus.interop.protocol.IInvocationStarting=} [p] Properties to set
                 */
                function InvocationStarting(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * Encodes the specified InvocationStarting message. Does not implicitly {@link plexus.interop.protocol.InvocationStarting.verify|verify} messages.
                 * @function encode
                 * @memberof plexus.interop.protocol.InvocationStarting
                 * @static
                 * @param {plexus.interop.protocol.IInvocationStarting} m InvocationStarting message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InvocationStarting.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    return w;
                };

                /**
                 * Decodes an InvocationStarting message from the specified reader or buffer.
                 * @function decode
                 * @memberof plexus.interop.protocol.InvocationStarting
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {plexus.interop.protocol.InvocationStarting} InvocationStarting
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InvocationStarting.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.interop.protocol.InvocationStarting();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                /**
                 * Creates an InvocationStarting message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof plexus.interop.protocol.InvocationStarting
                 * @static
                 * @param {Object.<string,*>} d Plain object
                 * @returns {plexus.interop.protocol.InvocationStarting} InvocationStarting
                 */
                InvocationStarting.fromObject = function fromObject(d) {
                    if (d instanceof $root.plexus.interop.protocol.InvocationStarting)
                        return d;
                    return new $root.plexus.interop.protocol.InvocationStarting();
                };

                /**
                 * Creates a plain object from an InvocationStarting message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof plexus.interop.protocol.InvocationStarting
                 * @static
                 * @param {plexus.interop.protocol.InvocationStarting} m InvocationStarting
                 * @param {$protobuf.IConversionOptions} [o] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InvocationStarting.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this InvocationStarting to JSON.
                 * @function toJSON
                 * @memberof plexus.interop.protocol.InvocationStarting
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InvocationStarting.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return InvocationStarting;
            })();

            protocol.InvocationStartRequested = (function() {

                /**
                 * Properties of an InvocationStartRequested.
                 * @memberof plexus.interop.protocol
                 * @interface IInvocationStartRequested
                 * @property {string} [serviceId] InvocationStartRequested serviceId
                 * @property {string} [serviceAlias] InvocationStartRequested serviceAlias
                 * @property {string} [methodId] InvocationStartRequested methodId
                 * @property {string} [consumerApplicationId] InvocationStartRequested consumerApplicationId
                 * @property {plexus.IUniqueId} [consumerConnectionId] InvocationStartRequested consumerConnectionId
                 * @property {plexus.IUniqueId} [consumerApplicationInstanceId] InvocationStartRequested consumerApplicationInstanceId
                 */

                /**
                 * Constructs a new InvocationStartRequested.
                 * @memberof plexus.interop.protocol
                 * @classdesc Represents an InvocationStartRequested.
                 * @constructor
                 * @param {plexus.interop.protocol.IInvocationStartRequested=} [p] Properties to set
                 */
                function InvocationStartRequested(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * InvocationStartRequested serviceId.
                 * @member {string}serviceId
                 * @memberof plexus.interop.protocol.InvocationStartRequested
                 * @instance
                 */
                InvocationStartRequested.prototype.serviceId = "";

                /**
                 * InvocationStartRequested serviceAlias.
                 * @member {string}serviceAlias
                 * @memberof plexus.interop.protocol.InvocationStartRequested
                 * @instance
                 */
                InvocationStartRequested.prototype.serviceAlias = "";

                /**
                 * InvocationStartRequested methodId.
                 * @member {string}methodId
                 * @memberof plexus.interop.protocol.InvocationStartRequested
                 * @instance
                 */
                InvocationStartRequested.prototype.methodId = "";

                /**
                 * InvocationStartRequested consumerApplicationId.
                 * @member {string}consumerApplicationId
                 * @memberof plexus.interop.protocol.InvocationStartRequested
                 * @instance
                 */
                InvocationStartRequested.prototype.consumerApplicationId = "";

                /**
                 * InvocationStartRequested consumerConnectionId.
                 * @member {(plexus.IUniqueId|null|undefined)}consumerConnectionId
                 * @memberof plexus.interop.protocol.InvocationStartRequested
                 * @instance
                 */
                InvocationStartRequested.prototype.consumerConnectionId = null;

                /**
                 * InvocationStartRequested consumerApplicationInstanceId.
                 * @member {(plexus.IUniqueId|null|undefined)}consumerApplicationInstanceId
                 * @memberof plexus.interop.protocol.InvocationStartRequested
                 * @instance
                 */
                InvocationStartRequested.prototype.consumerApplicationInstanceId = null;

                /**
                 * Encodes the specified InvocationStartRequested message. Does not implicitly {@link plexus.interop.protocol.InvocationStartRequested.verify|verify} messages.
                 * @function encode
                 * @memberof plexus.interop.protocol.InvocationStartRequested
                 * @static
                 * @param {plexus.interop.protocol.IInvocationStartRequested} m InvocationStartRequested message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InvocationStartRequested.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.serviceId != null && m.hasOwnProperty("serviceId"))
                        w.uint32(10).string(m.serviceId);
                    if (m.serviceAlias != null && m.hasOwnProperty("serviceAlias"))
                        w.uint32(18).string(m.serviceAlias);
                    if (m.methodId != null && m.hasOwnProperty("methodId"))
                        w.uint32(26).string(m.methodId);
                    if (m.consumerApplicationId != null && m.hasOwnProperty("consumerApplicationId"))
                        w.uint32(34).string(m.consumerApplicationId);
                    if (m.consumerConnectionId != null && m.hasOwnProperty("consumerConnectionId"))
                        $root.plexus.UniqueId.encode(m.consumerConnectionId, w.uint32(42).fork()).ldelim();
                    if (m.consumerApplicationInstanceId != null && m.hasOwnProperty("consumerApplicationInstanceId"))
                        $root.plexus.UniqueId.encode(m.consumerApplicationInstanceId, w.uint32(50).fork()).ldelim();
                    return w;
                };

                /**
                 * Decodes an InvocationStartRequested message from the specified reader or buffer.
                 * @function decode
                 * @memberof plexus.interop.protocol.InvocationStartRequested
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {plexus.interop.protocol.InvocationStartRequested} InvocationStartRequested
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InvocationStartRequested.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.interop.protocol.InvocationStartRequested();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.serviceId = r.string();
                            break;
                        case 2:
                            m.serviceAlias = r.string();
                            break;
                        case 3:
                            m.methodId = r.string();
                            break;
                        case 4:
                            m.consumerApplicationId = r.string();
                            break;
                        case 5:
                            m.consumerConnectionId = $root.plexus.UniqueId.decode(r, r.uint32());
                            break;
                        case 6:
                            m.consumerApplicationInstanceId = $root.plexus.UniqueId.decode(r, r.uint32());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                /**
                 * Creates an InvocationStartRequested message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof plexus.interop.protocol.InvocationStartRequested
                 * @static
                 * @param {Object.<string,*>} d Plain object
                 * @returns {plexus.interop.protocol.InvocationStartRequested} InvocationStartRequested
                 */
                InvocationStartRequested.fromObject = function fromObject(d) {
                    if (d instanceof $root.plexus.interop.protocol.InvocationStartRequested)
                        return d;
                    var m = new $root.plexus.interop.protocol.InvocationStartRequested();
                    if (d.serviceId != null) {
                        m.serviceId = String(d.serviceId);
                    }
                    if (d.serviceAlias != null) {
                        m.serviceAlias = String(d.serviceAlias);
                    }
                    if (d.methodId != null) {
                        m.methodId = String(d.methodId);
                    }
                    if (d.consumerApplicationId != null) {
                        m.consumerApplicationId = String(d.consumerApplicationId);
                    }
                    if (d.consumerConnectionId != null) {
                        if (typeof d.consumerConnectionId !== "object")
                            throw TypeError(".plexus.interop.protocol.InvocationStartRequested.consumerConnectionId: object expected");
                        m.consumerConnectionId = $root.plexus.UniqueId.fromObject(d.consumerConnectionId);
                    }
                    if (d.consumerApplicationInstanceId != null) {
                        if (typeof d.consumerApplicationInstanceId !== "object")
                            throw TypeError(".plexus.interop.protocol.InvocationStartRequested.consumerApplicationInstanceId: object expected");
                        m.consumerApplicationInstanceId = $root.plexus.UniqueId.fromObject(d.consumerApplicationInstanceId);
                    }
                    return m;
                };

                /**
                 * Creates a plain object from an InvocationStartRequested message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof plexus.interop.protocol.InvocationStartRequested
                 * @static
                 * @param {plexus.interop.protocol.InvocationStartRequested} m InvocationStartRequested
                 * @param {$protobuf.IConversionOptions} [o] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InvocationStartRequested.toObject = function toObject(m, o) {
                    if (!o)
                        o = {};
                    var d = {};
                    if (o.defaults) {
                        d.serviceId = "";
                        d.serviceAlias = "";
                        d.methodId = "";
                        d.consumerApplicationId = "";
                        d.consumerConnectionId = null;
                        d.consumerApplicationInstanceId = null;
                    }
                    if (m.serviceId != null && m.hasOwnProperty("serviceId")) {
                        d.serviceId = m.serviceId;
                    }
                    if (m.serviceAlias != null && m.hasOwnProperty("serviceAlias")) {
                        d.serviceAlias = m.serviceAlias;
                    }
                    if (m.methodId != null && m.hasOwnProperty("methodId")) {
                        d.methodId = m.methodId;
                    }
                    if (m.consumerApplicationId != null && m.hasOwnProperty("consumerApplicationId")) {
                        d.consumerApplicationId = m.consumerApplicationId;
                    }
                    if (m.consumerConnectionId != null && m.hasOwnProperty("consumerConnectionId")) {
                        d.consumerConnectionId = $root.plexus.UniqueId.toObject(m.consumerConnectionId, o);
                    }
                    if (m.consumerApplicationInstanceId != null && m.hasOwnProperty("consumerApplicationInstanceId")) {
                        d.consumerApplicationInstanceId = $root.plexus.UniqueId.toObject(m.consumerApplicationInstanceId, o);
                    }
                    return d;
                };

                /**
                 * Converts this InvocationStartRequested to JSON.
                 * @function toJSON
                 * @memberof plexus.interop.protocol.InvocationStartRequested
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InvocationStartRequested.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return InvocationStartRequested;
            })();

            protocol.InvocationStarted = (function() {

                /**
                 * Properties of an InvocationStarted.
                 * @memberof plexus.interop.protocol
                 * @interface IInvocationStarted
                 */

                /**
                 * Constructs a new InvocationStarted.
                 * @memberof plexus.interop.protocol
                 * @classdesc Represents an InvocationStarted.
                 * @constructor
                 * @param {plexus.interop.protocol.IInvocationStarted=} [p] Properties to set
                 */
                function InvocationStarted(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * Encodes the specified InvocationStarted message. Does not implicitly {@link plexus.interop.protocol.InvocationStarted.verify|verify} messages.
                 * @function encode
                 * @memberof plexus.interop.protocol.InvocationStarted
                 * @static
                 * @param {plexus.interop.protocol.IInvocationStarted} m InvocationStarted message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InvocationStarted.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    return w;
                };

                /**
                 * Decodes an InvocationStarted message from the specified reader or buffer.
                 * @function decode
                 * @memberof plexus.interop.protocol.InvocationStarted
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {plexus.interop.protocol.InvocationStarted} InvocationStarted
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InvocationStarted.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.interop.protocol.InvocationStarted();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                /**
                 * Creates an InvocationStarted message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof plexus.interop.protocol.InvocationStarted
                 * @static
                 * @param {Object.<string,*>} d Plain object
                 * @returns {plexus.interop.protocol.InvocationStarted} InvocationStarted
                 */
                InvocationStarted.fromObject = function fromObject(d) {
                    if (d instanceof $root.plexus.interop.protocol.InvocationStarted)
                        return d;
                    return new $root.plexus.interop.protocol.InvocationStarted();
                };

                /**
                 * Creates a plain object from an InvocationStarted message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof plexus.interop.protocol.InvocationStarted
                 * @static
                 * @param {plexus.interop.protocol.InvocationStarted} m InvocationStarted
                 * @param {$protobuf.IConversionOptions} [o] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InvocationStarted.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this InvocationStarted to JSON.
                 * @function toJSON
                 * @memberof plexus.interop.protocol.InvocationStarted
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InvocationStarted.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return InvocationStarted;
            })();

            protocol.InvocationMessageHeader = (function() {

                /**
                 * Properties of an InvocationMessageHeader.
                 * @memberof plexus.interop.protocol
                 * @interface IInvocationMessageHeader
                 */

                /**
                 * Constructs a new InvocationMessageHeader.
                 * @memberof plexus.interop.protocol
                 * @classdesc Represents an InvocationMessageHeader.
                 * @constructor
                 * @param {plexus.interop.protocol.IInvocationMessageHeader=} [p] Properties to set
                 */
                function InvocationMessageHeader(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * Encodes the specified InvocationMessageHeader message. Does not implicitly {@link plexus.interop.protocol.InvocationMessageHeader.verify|verify} messages.
                 * @function encode
                 * @memberof plexus.interop.protocol.InvocationMessageHeader
                 * @static
                 * @param {plexus.interop.protocol.IInvocationMessageHeader} m InvocationMessageHeader message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InvocationMessageHeader.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    return w;
                };

                /**
                 * Decodes an InvocationMessageHeader message from the specified reader or buffer.
                 * @function decode
                 * @memberof plexus.interop.protocol.InvocationMessageHeader
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {plexus.interop.protocol.InvocationMessageHeader} InvocationMessageHeader
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InvocationMessageHeader.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.interop.protocol.InvocationMessageHeader();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                /**
                 * Creates an InvocationMessageHeader message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof plexus.interop.protocol.InvocationMessageHeader
                 * @static
                 * @param {Object.<string,*>} d Plain object
                 * @returns {plexus.interop.protocol.InvocationMessageHeader} InvocationMessageHeader
                 */
                InvocationMessageHeader.fromObject = function fromObject(d) {
                    if (d instanceof $root.plexus.interop.protocol.InvocationMessageHeader)
                        return d;
                    return new $root.plexus.interop.protocol.InvocationMessageHeader();
                };

                /**
                 * Creates a plain object from an InvocationMessageHeader message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof plexus.interop.protocol.InvocationMessageHeader
                 * @static
                 * @param {plexus.interop.protocol.InvocationMessageHeader} m InvocationMessageHeader
                 * @param {$protobuf.IConversionOptions} [o] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InvocationMessageHeader.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this InvocationMessageHeader to JSON.
                 * @function toJSON
                 * @memberof plexus.interop.protocol.InvocationMessageHeader
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InvocationMessageHeader.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return InvocationMessageHeader;
            })();

            protocol.InvocationMessageReceived = (function() {

                /**
                 * Properties of an InvocationMessageReceived.
                 * @memberof plexus.interop.protocol
                 * @interface IInvocationMessageReceived
                 */

                /**
                 * Constructs a new InvocationMessageReceived.
                 * @memberof plexus.interop.protocol
                 * @classdesc Represents an InvocationMessageReceived.
                 * @constructor
                 * @param {plexus.interop.protocol.IInvocationMessageReceived=} [p] Properties to set
                 */
                function InvocationMessageReceived(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * Encodes the specified InvocationMessageReceived message. Does not implicitly {@link plexus.interop.protocol.InvocationMessageReceived.verify|verify} messages.
                 * @function encode
                 * @memberof plexus.interop.protocol.InvocationMessageReceived
                 * @static
                 * @param {plexus.interop.protocol.IInvocationMessageReceived} m InvocationMessageReceived message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InvocationMessageReceived.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    return w;
                };

                /**
                 * Decodes an InvocationMessageReceived message from the specified reader or buffer.
                 * @function decode
                 * @memberof plexus.interop.protocol.InvocationMessageReceived
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {plexus.interop.protocol.InvocationMessageReceived} InvocationMessageReceived
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InvocationMessageReceived.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.interop.protocol.InvocationMessageReceived();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                /**
                 * Creates an InvocationMessageReceived message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof plexus.interop.protocol.InvocationMessageReceived
                 * @static
                 * @param {Object.<string,*>} d Plain object
                 * @returns {plexus.interop.protocol.InvocationMessageReceived} InvocationMessageReceived
                 */
                InvocationMessageReceived.fromObject = function fromObject(d) {
                    if (d instanceof $root.plexus.interop.protocol.InvocationMessageReceived)
                        return d;
                    return new $root.plexus.interop.protocol.InvocationMessageReceived();
                };

                /**
                 * Creates a plain object from an InvocationMessageReceived message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof plexus.interop.protocol.InvocationMessageReceived
                 * @static
                 * @param {plexus.interop.protocol.InvocationMessageReceived} m InvocationMessageReceived
                 * @param {$protobuf.IConversionOptions} [o] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InvocationMessageReceived.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this InvocationMessageReceived to JSON.
                 * @function toJSON
                 * @memberof plexus.interop.protocol.InvocationMessageReceived
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InvocationMessageReceived.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return InvocationMessageReceived;
            })();

            protocol.InvocationSendCompletion = (function() {

                /**
                 * Properties of an InvocationSendCompletion.
                 * @memberof plexus.interop.protocol
                 * @interface IInvocationSendCompletion
                 */

                /**
                 * Constructs a new InvocationSendCompletion.
                 * @memberof plexus.interop.protocol
                 * @classdesc Represents an InvocationSendCompletion.
                 * @constructor
                 * @param {plexus.interop.protocol.IInvocationSendCompletion=} [p] Properties to set
                 */
                function InvocationSendCompletion(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * Encodes the specified InvocationSendCompletion message. Does not implicitly {@link plexus.interop.protocol.InvocationSendCompletion.verify|verify} messages.
                 * @function encode
                 * @memberof plexus.interop.protocol.InvocationSendCompletion
                 * @static
                 * @param {plexus.interop.protocol.IInvocationSendCompletion} m InvocationSendCompletion message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InvocationSendCompletion.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    return w;
                };

                /**
                 * Decodes an InvocationSendCompletion message from the specified reader or buffer.
                 * @function decode
                 * @memberof plexus.interop.protocol.InvocationSendCompletion
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {plexus.interop.protocol.InvocationSendCompletion} InvocationSendCompletion
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InvocationSendCompletion.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.interop.protocol.InvocationSendCompletion();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                /**
                 * Creates an InvocationSendCompletion message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof plexus.interop.protocol.InvocationSendCompletion
                 * @static
                 * @param {Object.<string,*>} d Plain object
                 * @returns {plexus.interop.protocol.InvocationSendCompletion} InvocationSendCompletion
                 */
                InvocationSendCompletion.fromObject = function fromObject(d) {
                    if (d instanceof $root.plexus.interop.protocol.InvocationSendCompletion)
                        return d;
                    return new $root.plexus.interop.protocol.InvocationSendCompletion();
                };

                /**
                 * Creates a plain object from an InvocationSendCompletion message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof plexus.interop.protocol.InvocationSendCompletion
                 * @static
                 * @param {plexus.interop.protocol.InvocationSendCompletion} m InvocationSendCompletion
                 * @param {$protobuf.IConversionOptions} [o] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InvocationSendCompletion.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this InvocationSendCompletion to JSON.
                 * @function toJSON
                 * @memberof plexus.interop.protocol.InvocationSendCompletion
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InvocationSendCompletion.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return InvocationSendCompletion;
            })();

            protocol.InvocationMessageEnvelope = (function() {

                /**
                 * Properties of an InvocationMessageEnvelope.
                 * @memberof plexus.interop.protocol
                 * @interface IInvocationMessageEnvelope
                 * @property {plexus.interop.protocol.IInvocationMessageHeader} [message] InvocationMessageEnvelope message
                 * @property {plexus.interop.protocol.IInvocationMessageReceived} [confirmation] InvocationMessageEnvelope confirmation
                 * @property {plexus.interop.protocol.IInvocationSendCompletion} [sendCompletion] InvocationMessageEnvelope sendCompletion
                 */

                /**
                 * Constructs a new InvocationMessageEnvelope.
                 * @memberof plexus.interop.protocol
                 * @classdesc Represents an InvocationMessageEnvelope.
                 * @constructor
                 * @param {plexus.interop.protocol.IInvocationMessageEnvelope=} [p] Properties to set
                 */
                function InvocationMessageEnvelope(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * InvocationMessageEnvelope message.
                 * @member {(plexus.interop.protocol.IInvocationMessageHeader|null|undefined)}message
                 * @memberof plexus.interop.protocol.InvocationMessageEnvelope
                 * @instance
                 */
                InvocationMessageEnvelope.prototype.message = null;

                /**
                 * InvocationMessageEnvelope confirmation.
                 * @member {(plexus.interop.protocol.IInvocationMessageReceived|null|undefined)}confirmation
                 * @memberof plexus.interop.protocol.InvocationMessageEnvelope
                 * @instance
                 */
                InvocationMessageEnvelope.prototype.confirmation = null;

                /**
                 * InvocationMessageEnvelope sendCompletion.
                 * @member {(plexus.interop.protocol.IInvocationSendCompletion|null|undefined)}sendCompletion
                 * @memberof plexus.interop.protocol.InvocationMessageEnvelope
                 * @instance
                 */
                InvocationMessageEnvelope.prototype.sendCompletion = null;

                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;

                /**
                 * InvocationMessageEnvelope payload.
                 * @member {string|undefined} payload
                 * @memberof plexus.interop.protocol.InvocationMessageEnvelope
                 * @instance
                 */
                Object.defineProperty(InvocationMessageEnvelope.prototype, "payload", {
                    get: $util.oneOfGetter($oneOfFields = ["message", "confirmation", "sendCompletion"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Encodes the specified InvocationMessageEnvelope message. Does not implicitly {@link plexus.interop.protocol.InvocationMessageEnvelope.verify|verify} messages.
                 * @function encode
                 * @memberof plexus.interop.protocol.InvocationMessageEnvelope
                 * @static
                 * @param {plexus.interop.protocol.IInvocationMessageEnvelope} m InvocationMessageEnvelope message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InvocationMessageEnvelope.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.message != null && m.hasOwnProperty("message"))
                        $root.plexus.interop.protocol.InvocationMessageHeader.encode(m.message, w.uint32(10).fork()).ldelim();
                    if (m.confirmation != null && m.hasOwnProperty("confirmation"))
                        $root.plexus.interop.protocol.InvocationMessageReceived.encode(m.confirmation, w.uint32(18).fork()).ldelim();
                    if (m.sendCompletion != null && m.hasOwnProperty("sendCompletion"))
                        $root.plexus.interop.protocol.InvocationSendCompletion.encode(m.sendCompletion, w.uint32(26).fork()).ldelim();
                    return w;
                };

                /**
                 * Decodes an InvocationMessageEnvelope message from the specified reader or buffer.
                 * @function decode
                 * @memberof plexus.interop.protocol.InvocationMessageEnvelope
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {plexus.interop.protocol.InvocationMessageEnvelope} InvocationMessageEnvelope
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InvocationMessageEnvelope.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.interop.protocol.InvocationMessageEnvelope();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.message = $root.plexus.interop.protocol.InvocationMessageHeader.decode(r, r.uint32());
                            break;
                        case 2:
                            m.confirmation = $root.plexus.interop.protocol.InvocationMessageReceived.decode(r, r.uint32());
                            break;
                        case 3:
                            m.sendCompletion = $root.plexus.interop.protocol.InvocationSendCompletion.decode(r, r.uint32());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                /**
                 * Creates an InvocationMessageEnvelope message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof plexus.interop.protocol.InvocationMessageEnvelope
                 * @static
                 * @param {Object.<string,*>} d Plain object
                 * @returns {plexus.interop.protocol.InvocationMessageEnvelope} InvocationMessageEnvelope
                 */
                InvocationMessageEnvelope.fromObject = function fromObject(d) {
                    if (d instanceof $root.plexus.interop.protocol.InvocationMessageEnvelope)
                        return d;
                    var m = new $root.plexus.interop.protocol.InvocationMessageEnvelope();
                    if (d.message != null) {
                        if (typeof d.message !== "object")
                            throw TypeError(".plexus.interop.protocol.InvocationMessageEnvelope.message: object expected");
                        m.message = $root.plexus.interop.protocol.InvocationMessageHeader.fromObject(d.message);
                    }
                    if (d.confirmation != null) {
                        if (typeof d.confirmation !== "object")
                            throw TypeError(".plexus.interop.protocol.InvocationMessageEnvelope.confirmation: object expected");
                        m.confirmation = $root.plexus.interop.protocol.InvocationMessageReceived.fromObject(d.confirmation);
                    }
                    if (d.sendCompletion != null) {
                        if (typeof d.sendCompletion !== "object")
                            throw TypeError(".plexus.interop.protocol.InvocationMessageEnvelope.sendCompletion: object expected");
                        m.sendCompletion = $root.plexus.interop.protocol.InvocationSendCompletion.fromObject(d.sendCompletion);
                    }
                    return m;
                };

                /**
                 * Creates a plain object from an InvocationMessageEnvelope message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof plexus.interop.protocol.InvocationMessageEnvelope
                 * @static
                 * @param {plexus.interop.protocol.InvocationMessageEnvelope} m InvocationMessageEnvelope
                 * @param {$protobuf.IConversionOptions} [o] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InvocationMessageEnvelope.toObject = function toObject(m, o) {
                    if (!o)
                        o = {};
                    var d = {};
                    if (m.message != null && m.hasOwnProperty("message")) {
                        d.message = $root.plexus.interop.protocol.InvocationMessageHeader.toObject(m.message, o);
                        if (o.oneofs)
                            d.payload = "message";
                    }
                    if (m.confirmation != null && m.hasOwnProperty("confirmation")) {
                        d.confirmation = $root.plexus.interop.protocol.InvocationMessageReceived.toObject(m.confirmation, o);
                        if (o.oneofs)
                            d.payload = "confirmation";
                    }
                    if (m.sendCompletion != null && m.hasOwnProperty("sendCompletion")) {
                        d.sendCompletion = $root.plexus.interop.protocol.InvocationSendCompletion.toObject(m.sendCompletion, o);
                        if (o.oneofs)
                            d.payload = "sendCompletion";
                    }
                    return d;
                };

                /**
                 * Converts this InvocationMessageEnvelope to JSON.
                 * @function toJSON
                 * @memberof plexus.interop.protocol.InvocationMessageEnvelope
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InvocationMessageEnvelope.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return InvocationMessageEnvelope;
            })();

            /**
             * DiscoveryMode enum.
             * @enum {string}
             * @property {number} Offline=0 Offline value
             * @property {number} Online=1 Online value
             */
            protocol.DiscoveryMode = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "Offline"] = 0;
                values[valuesById[1] = "Online"] = 1;
                return values;
            })();

            /**
             * MethodType enum.
             * @enum {string}
             * @property {number} Unary=0 Unary value
             * @property {number} ServerStreaming=1 ServerStreaming value
             * @property {number} ClientStreaming=2 ClientStreaming value
             * @property {number} DuplexStreaming=3 DuplexStreaming value
             */
            protocol.MethodType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "Unary"] = 0;
                values[valuesById[1] = "ServerStreaming"] = 1;
                values[valuesById[2] = "ClientStreaming"] = 2;
                values[valuesById[3] = "DuplexStreaming"] = 3;
                return values;
            })();

            protocol.ServiceDiscoveryRequest = (function() {

                /**
                 * Properties of a ServiceDiscoveryRequest.
                 * @memberof plexus.interop.protocol
                 * @interface IServiceDiscoveryRequest
                 * @property {plexus.interop.protocol.IConsumedServiceReference} [consumedService] ServiceDiscoveryRequest consumedService
                 * @property {plexus.interop.protocol.DiscoveryMode} [discoveryMode] ServiceDiscoveryRequest discoveryMode
                 */

                /**
                 * Constructs a new ServiceDiscoveryRequest.
                 * @memberof plexus.interop.protocol
                 * @classdesc Represents a ServiceDiscoveryRequest.
                 * @constructor
                 * @param {plexus.interop.protocol.IServiceDiscoveryRequest=} [p] Properties to set
                 */
                function ServiceDiscoveryRequest(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * ServiceDiscoveryRequest consumedService.
                 * @member {(plexus.interop.protocol.IConsumedServiceReference|null|undefined)}consumedService
                 * @memberof plexus.interop.protocol.ServiceDiscoveryRequest
                 * @instance
                 */
                ServiceDiscoveryRequest.prototype.consumedService = null;

                /**
                 * ServiceDiscoveryRequest discoveryMode.
                 * @member {plexus.interop.protocol.DiscoveryMode}discoveryMode
                 * @memberof plexus.interop.protocol.ServiceDiscoveryRequest
                 * @instance
                 */
                ServiceDiscoveryRequest.prototype.discoveryMode = 0;

                /**
                 * Encodes the specified ServiceDiscoveryRequest message. Does not implicitly {@link plexus.interop.protocol.ServiceDiscoveryRequest.verify|verify} messages.
                 * @function encode
                 * @memberof plexus.interop.protocol.ServiceDiscoveryRequest
                 * @static
                 * @param {plexus.interop.protocol.IServiceDiscoveryRequest} m ServiceDiscoveryRequest message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceDiscoveryRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.consumedService != null && m.hasOwnProperty("consumedService"))
                        $root.plexus.interop.protocol.ConsumedServiceReference.encode(m.consumedService, w.uint32(10).fork()).ldelim();
                    if (m.discoveryMode != null && m.hasOwnProperty("discoveryMode"))
                        w.uint32(16).int32(m.discoveryMode);
                    return w;
                };

                /**
                 * Decodes a ServiceDiscoveryRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof plexus.interop.protocol.ServiceDiscoveryRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {plexus.interop.protocol.ServiceDiscoveryRequest} ServiceDiscoveryRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceDiscoveryRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.interop.protocol.ServiceDiscoveryRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.consumedService = $root.plexus.interop.protocol.ConsumedServiceReference.decode(r, r.uint32());
                            break;
                        case 2:
                            m.discoveryMode = r.int32();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                /**
                 * Creates a ServiceDiscoveryRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof plexus.interop.protocol.ServiceDiscoveryRequest
                 * @static
                 * @param {Object.<string,*>} d Plain object
                 * @returns {plexus.interop.protocol.ServiceDiscoveryRequest} ServiceDiscoveryRequest
                 */
                ServiceDiscoveryRequest.fromObject = function fromObject(d) {
                    if (d instanceof $root.plexus.interop.protocol.ServiceDiscoveryRequest)
                        return d;
                    var m = new $root.plexus.interop.protocol.ServiceDiscoveryRequest();
                    if (d.consumedService != null) {
                        if (typeof d.consumedService !== "object")
                            throw TypeError(".plexus.interop.protocol.ServiceDiscoveryRequest.consumedService: object expected");
                        m.consumedService = $root.plexus.interop.protocol.ConsumedServiceReference.fromObject(d.consumedService);
                    }
                    switch (d.discoveryMode) {
                    case "Offline":
                    case 0:
                        m.discoveryMode = 0;
                        break;
                    case "Online":
                    case 1:
                        m.discoveryMode = 1;
                        break;
                    }
                    return m;
                };

                /**
                 * Creates a plain object from a ServiceDiscoveryRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof plexus.interop.protocol.ServiceDiscoveryRequest
                 * @static
                 * @param {plexus.interop.protocol.ServiceDiscoveryRequest} m ServiceDiscoveryRequest
                 * @param {$protobuf.IConversionOptions} [o] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ServiceDiscoveryRequest.toObject = function toObject(m, o) {
                    if (!o)
                        o = {};
                    var d = {};
                    if (o.defaults) {
                        d.consumedService = null;
                        d.discoveryMode = o.enums === String ? "Offline" : 0;
                    }
                    if (m.consumedService != null && m.hasOwnProperty("consumedService")) {
                        d.consumedService = $root.plexus.interop.protocol.ConsumedServiceReference.toObject(m.consumedService, o);
                    }
                    if (m.discoveryMode != null && m.hasOwnProperty("discoveryMode")) {
                        d.discoveryMode = o.enums === String ? $root.plexus.interop.protocol.DiscoveryMode[m.discoveryMode] : m.discoveryMode;
                    }
                    return d;
                };

                /**
                 * Converts this ServiceDiscoveryRequest to JSON.
                 * @function toJSON
                 * @memberof plexus.interop.protocol.ServiceDiscoveryRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ServiceDiscoveryRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ServiceDiscoveryRequest;
            })();

            protocol.ServiceDiscoveryResponse = (function() {

                /**
                 * Properties of a ServiceDiscoveryResponse.
                 * @memberof plexus.interop.protocol
                 * @interface IServiceDiscoveryResponse
                 * @property {Array.<plexus.interop.protocol.IDiscoveredService>} [services] ServiceDiscoveryResponse services
                 */

                /**
                 * Constructs a new ServiceDiscoveryResponse.
                 * @memberof plexus.interop.protocol
                 * @classdesc Represents a ServiceDiscoveryResponse.
                 * @constructor
                 * @param {plexus.interop.protocol.IServiceDiscoveryResponse=} [p] Properties to set
                 */
                function ServiceDiscoveryResponse(p) {
                    this.services = [];
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * ServiceDiscoveryResponse services.
                 * @member {Array.<plexus.interop.protocol.IDiscoveredService>}services
                 * @memberof plexus.interop.protocol.ServiceDiscoveryResponse
                 * @instance
                 */
                ServiceDiscoveryResponse.prototype.services = $util.emptyArray;

                /**
                 * Encodes the specified ServiceDiscoveryResponse message. Does not implicitly {@link plexus.interop.protocol.ServiceDiscoveryResponse.verify|verify} messages.
                 * @function encode
                 * @memberof plexus.interop.protocol.ServiceDiscoveryResponse
                 * @static
                 * @param {plexus.interop.protocol.IServiceDiscoveryResponse} m ServiceDiscoveryResponse message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceDiscoveryResponse.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.services != null && m.services.length) {
                        for (var i = 0; i < m.services.length; ++i)
                            $root.plexus.interop.protocol.DiscoveredService.encode(m.services[i], w.uint32(10).fork()).ldelim();
                    }
                    return w;
                };

                /**
                 * Decodes a ServiceDiscoveryResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof plexus.interop.protocol.ServiceDiscoveryResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {plexus.interop.protocol.ServiceDiscoveryResponse} ServiceDiscoveryResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceDiscoveryResponse.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.interop.protocol.ServiceDiscoveryResponse();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            if (!(m.services && m.services.length))
                                m.services = [];
                            m.services.push($root.plexus.interop.protocol.DiscoveredService.decode(r, r.uint32()));
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                /**
                 * Creates a ServiceDiscoveryResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof plexus.interop.protocol.ServiceDiscoveryResponse
                 * @static
                 * @param {Object.<string,*>} d Plain object
                 * @returns {plexus.interop.protocol.ServiceDiscoveryResponse} ServiceDiscoveryResponse
                 */
                ServiceDiscoveryResponse.fromObject = function fromObject(d) {
                    if (d instanceof $root.plexus.interop.protocol.ServiceDiscoveryResponse)
                        return d;
                    var m = new $root.plexus.interop.protocol.ServiceDiscoveryResponse();
                    if (d.services) {
                        if (!Array.isArray(d.services))
                            throw TypeError(".plexus.interop.protocol.ServiceDiscoveryResponse.services: array expected");
                        m.services = [];
                        for (var i = 0; i < d.services.length; ++i) {
                            if (typeof d.services[i] !== "object")
                                throw TypeError(".plexus.interop.protocol.ServiceDiscoveryResponse.services: object expected");
                            m.services[i] = $root.plexus.interop.protocol.DiscoveredService.fromObject(d.services[i]);
                        }
                    }
                    return m;
                };

                /**
                 * Creates a plain object from a ServiceDiscoveryResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof plexus.interop.protocol.ServiceDiscoveryResponse
                 * @static
                 * @param {plexus.interop.protocol.ServiceDiscoveryResponse} m ServiceDiscoveryResponse
                 * @param {$protobuf.IConversionOptions} [o] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ServiceDiscoveryResponse.toObject = function toObject(m, o) {
                    if (!o)
                        o = {};
                    var d = {};
                    if (o.arrays || o.defaults) {
                        d.services = [];
                    }
                    if (m.services && m.services.length) {
                        d.services = [];
                        for (var j = 0; j < m.services.length; ++j) {
                            d.services[j] = $root.plexus.interop.protocol.DiscoveredService.toObject(m.services[j], o);
                        }
                    }
                    return d;
                };

                /**
                 * Converts this ServiceDiscoveryResponse to JSON.
                 * @function toJSON
                 * @memberof plexus.interop.protocol.ServiceDiscoveryResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ServiceDiscoveryResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ServiceDiscoveryResponse;
            })();

            protocol.DiscoveredService = (function() {

                /**
                 * Properties of a DiscoveredService.
                 * @memberof plexus.interop.protocol
                 * @interface IDiscoveredService
                 * @property {plexus.interop.protocol.IConsumedServiceReference} [consumedService] DiscoveredService consumedService
                 * @property {plexus.interop.protocol.IProvidedServiceReference} [providedService] DiscoveredService providedService
                 * @property {string} [serviceTitle] DiscoveredService serviceTitle
                 * @property {Array.<plexus.interop.protocol.IDiscoveredServiceMethod>} [methods] DiscoveredService methods
                 */

                /**
                 * Constructs a new DiscoveredService.
                 * @memberof plexus.interop.protocol
                 * @classdesc Represents a DiscoveredService.
                 * @constructor
                 * @param {plexus.interop.protocol.IDiscoveredService=} [p] Properties to set
                 */
                function DiscoveredService(p) {
                    this.methods = [];
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * DiscoveredService consumedService.
                 * @member {(plexus.interop.protocol.IConsumedServiceReference|null|undefined)}consumedService
                 * @memberof plexus.interop.protocol.DiscoveredService
                 * @instance
                 */
                DiscoveredService.prototype.consumedService = null;

                /**
                 * DiscoveredService providedService.
                 * @member {(plexus.interop.protocol.IProvidedServiceReference|null|undefined)}providedService
                 * @memberof plexus.interop.protocol.DiscoveredService
                 * @instance
                 */
                DiscoveredService.prototype.providedService = null;

                /**
                 * DiscoveredService serviceTitle.
                 * @member {string}serviceTitle
                 * @memberof plexus.interop.protocol.DiscoveredService
                 * @instance
                 */
                DiscoveredService.prototype.serviceTitle = "";

                /**
                 * DiscoveredService methods.
                 * @member {Array.<plexus.interop.protocol.IDiscoveredServiceMethod>}methods
                 * @memberof plexus.interop.protocol.DiscoveredService
                 * @instance
                 */
                DiscoveredService.prototype.methods = $util.emptyArray;

                /**
                 * Encodes the specified DiscoveredService message. Does not implicitly {@link plexus.interop.protocol.DiscoveredService.verify|verify} messages.
                 * @function encode
                 * @memberof plexus.interop.protocol.DiscoveredService
                 * @static
                 * @param {plexus.interop.protocol.IDiscoveredService} m DiscoveredService message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DiscoveredService.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.consumedService != null && m.hasOwnProperty("consumedService"))
                        $root.plexus.interop.protocol.ConsumedServiceReference.encode(m.consumedService, w.uint32(10).fork()).ldelim();
                    if (m.providedService != null && m.hasOwnProperty("providedService"))
                        $root.plexus.interop.protocol.ProvidedServiceReference.encode(m.providedService, w.uint32(18).fork()).ldelim();
                    if (m.serviceTitle != null && m.hasOwnProperty("serviceTitle"))
                        w.uint32(26).string(m.serviceTitle);
                    if (m.methods != null && m.methods.length) {
                        for (var i = 0; i < m.methods.length; ++i)
                            $root.plexus.interop.protocol.DiscoveredServiceMethod.encode(m.methods[i], w.uint32(34).fork()).ldelim();
                    }
                    return w;
                };

                /**
                 * Decodes a DiscoveredService message from the specified reader or buffer.
                 * @function decode
                 * @memberof plexus.interop.protocol.DiscoveredService
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {plexus.interop.protocol.DiscoveredService} DiscoveredService
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DiscoveredService.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.interop.protocol.DiscoveredService();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.consumedService = $root.plexus.interop.protocol.ConsumedServiceReference.decode(r, r.uint32());
                            break;
                        case 2:
                            m.providedService = $root.plexus.interop.protocol.ProvidedServiceReference.decode(r, r.uint32());
                            break;
                        case 3:
                            m.serviceTitle = r.string();
                            break;
                        case 4:
                            if (!(m.methods && m.methods.length))
                                m.methods = [];
                            m.methods.push($root.plexus.interop.protocol.DiscoveredServiceMethod.decode(r, r.uint32()));
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                /**
                 * Creates a DiscoveredService message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof plexus.interop.protocol.DiscoveredService
                 * @static
                 * @param {Object.<string,*>} d Plain object
                 * @returns {plexus.interop.protocol.DiscoveredService} DiscoveredService
                 */
                DiscoveredService.fromObject = function fromObject(d) {
                    if (d instanceof $root.plexus.interop.protocol.DiscoveredService)
                        return d;
                    var m = new $root.plexus.interop.protocol.DiscoveredService();
                    if (d.consumedService != null) {
                        if (typeof d.consumedService !== "object")
                            throw TypeError(".plexus.interop.protocol.DiscoveredService.consumedService: object expected");
                        m.consumedService = $root.plexus.interop.protocol.ConsumedServiceReference.fromObject(d.consumedService);
                    }
                    if (d.providedService != null) {
                        if (typeof d.providedService !== "object")
                            throw TypeError(".plexus.interop.protocol.DiscoveredService.providedService: object expected");
                        m.providedService = $root.plexus.interop.protocol.ProvidedServiceReference.fromObject(d.providedService);
                    }
                    if (d.serviceTitle != null) {
                        m.serviceTitle = String(d.serviceTitle);
                    }
                    if (d.methods) {
                        if (!Array.isArray(d.methods))
                            throw TypeError(".plexus.interop.protocol.DiscoveredService.methods: array expected");
                        m.methods = [];
                        for (var i = 0; i < d.methods.length; ++i) {
                            if (typeof d.methods[i] !== "object")
                                throw TypeError(".plexus.interop.protocol.DiscoveredService.methods: object expected");
                            m.methods[i] = $root.plexus.interop.protocol.DiscoveredServiceMethod.fromObject(d.methods[i]);
                        }
                    }
                    return m;
                };

                /**
                 * Creates a plain object from a DiscoveredService message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof plexus.interop.protocol.DiscoveredService
                 * @static
                 * @param {plexus.interop.protocol.DiscoveredService} m DiscoveredService
                 * @param {$protobuf.IConversionOptions} [o] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DiscoveredService.toObject = function toObject(m, o) {
                    if (!o)
                        o = {};
                    var d = {};
                    if (o.arrays || o.defaults) {
                        d.methods = [];
                    }
                    if (o.defaults) {
                        d.consumedService = null;
                        d.providedService = null;
                        d.serviceTitle = "";
                    }
                    if (m.consumedService != null && m.hasOwnProperty("consumedService")) {
                        d.consumedService = $root.plexus.interop.protocol.ConsumedServiceReference.toObject(m.consumedService, o);
                    }
                    if (m.providedService != null && m.hasOwnProperty("providedService")) {
                        d.providedService = $root.plexus.interop.protocol.ProvidedServiceReference.toObject(m.providedService, o);
                    }
                    if (m.serviceTitle != null && m.hasOwnProperty("serviceTitle")) {
                        d.serviceTitle = m.serviceTitle;
                    }
                    if (m.methods && m.methods.length) {
                        d.methods = [];
                        for (var j = 0; j < m.methods.length; ++j) {
                            d.methods[j] = $root.plexus.interop.protocol.DiscoveredServiceMethod.toObject(m.methods[j], o);
                        }
                    }
                    return d;
                };

                /**
                 * Converts this DiscoveredService to JSON.
                 * @function toJSON
                 * @memberof plexus.interop.protocol.DiscoveredService
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DiscoveredService.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DiscoveredService;
            })();

            protocol.DiscoveredServiceMethod = (function() {

                /**
                 * Properties of a DiscoveredServiceMethod.
                 * @memberof plexus.interop.protocol
                 * @interface IDiscoveredServiceMethod
                 * @property {string} [methodId] DiscoveredServiceMethod methodId
                 * @property {string} [methodTitle] DiscoveredServiceMethod methodTitle
                 * @property {string} [inputMessageId] DiscoveredServiceMethod inputMessageId
                 * @property {string} [outputMessageId] DiscoveredServiceMethod outputMessageId
                 * @property {plexus.interop.protocol.MethodType} [methodType] DiscoveredServiceMethod methodType
                 * @property {Array.<plexus.interop.protocol.IOption>} [options] DiscoveredServiceMethod options
                 */

                /**
                 * Constructs a new DiscoveredServiceMethod.
                 * @memberof plexus.interop.protocol
                 * @classdesc Represents a DiscoveredServiceMethod.
                 * @constructor
                 * @param {plexus.interop.protocol.IDiscoveredServiceMethod=} [p] Properties to set
                 */
                function DiscoveredServiceMethod(p) {
                    this.options = [];
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * DiscoveredServiceMethod methodId.
                 * @member {string}methodId
                 * @memberof plexus.interop.protocol.DiscoveredServiceMethod
                 * @instance
                 */
                DiscoveredServiceMethod.prototype.methodId = "";

                /**
                 * DiscoveredServiceMethod methodTitle.
                 * @member {string}methodTitle
                 * @memberof plexus.interop.protocol.DiscoveredServiceMethod
                 * @instance
                 */
                DiscoveredServiceMethod.prototype.methodTitle = "";

                /**
                 * DiscoveredServiceMethod inputMessageId.
                 * @member {string}inputMessageId
                 * @memberof plexus.interop.protocol.DiscoveredServiceMethod
                 * @instance
                 */
                DiscoveredServiceMethod.prototype.inputMessageId = "";

                /**
                 * DiscoveredServiceMethod outputMessageId.
                 * @member {string}outputMessageId
                 * @memberof plexus.interop.protocol.DiscoveredServiceMethod
                 * @instance
                 */
                DiscoveredServiceMethod.prototype.outputMessageId = "";

                /**
                 * DiscoveredServiceMethod methodType.
                 * @member {plexus.interop.protocol.MethodType}methodType
                 * @memberof plexus.interop.protocol.DiscoveredServiceMethod
                 * @instance
                 */
                DiscoveredServiceMethod.prototype.methodType = 0;

                /**
                 * DiscoveredServiceMethod options.
                 * @member {Array.<plexus.interop.protocol.IOption>}options
                 * @memberof plexus.interop.protocol.DiscoveredServiceMethod
                 * @instance
                 */
                DiscoveredServiceMethod.prototype.options = $util.emptyArray;

                /**
                 * Encodes the specified DiscoveredServiceMethod message. Does not implicitly {@link plexus.interop.protocol.DiscoveredServiceMethod.verify|verify} messages.
                 * @function encode
                 * @memberof plexus.interop.protocol.DiscoveredServiceMethod
                 * @static
                 * @param {plexus.interop.protocol.IDiscoveredServiceMethod} m DiscoveredServiceMethod message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DiscoveredServiceMethod.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.methodId != null && m.hasOwnProperty("methodId"))
                        w.uint32(10).string(m.methodId);
                    if (m.methodTitle != null && m.hasOwnProperty("methodTitle"))
                        w.uint32(18).string(m.methodTitle);
                    if (m.inputMessageId != null && m.hasOwnProperty("inputMessageId"))
                        w.uint32(26).string(m.inputMessageId);
                    if (m.outputMessageId != null && m.hasOwnProperty("outputMessageId"))
                        w.uint32(34).string(m.outputMessageId);
                    if (m.methodType != null && m.hasOwnProperty("methodType"))
                        w.uint32(40).int32(m.methodType);
                    if (m.options != null && m.options.length) {
                        for (var i = 0; i < m.options.length; ++i)
                            $root.plexus.interop.protocol.Option.encode(m.options[i], w.uint32(50).fork()).ldelim();
                    }
                    return w;
                };

                /**
                 * Decodes a DiscoveredServiceMethod message from the specified reader or buffer.
                 * @function decode
                 * @memberof plexus.interop.protocol.DiscoveredServiceMethod
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {plexus.interop.protocol.DiscoveredServiceMethod} DiscoveredServiceMethod
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DiscoveredServiceMethod.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.interop.protocol.DiscoveredServiceMethod();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.methodId = r.string();
                            break;
                        case 2:
                            m.methodTitle = r.string();
                            break;
                        case 3:
                            m.inputMessageId = r.string();
                            break;
                        case 4:
                            m.outputMessageId = r.string();
                            break;
                        case 5:
                            m.methodType = r.int32();
                            break;
                        case 6:
                            if (!(m.options && m.options.length))
                                m.options = [];
                            m.options.push($root.plexus.interop.protocol.Option.decode(r, r.uint32()));
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                /**
                 * Creates a DiscoveredServiceMethod message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof plexus.interop.protocol.DiscoveredServiceMethod
                 * @static
                 * @param {Object.<string,*>} d Plain object
                 * @returns {plexus.interop.protocol.DiscoveredServiceMethod} DiscoveredServiceMethod
                 */
                DiscoveredServiceMethod.fromObject = function fromObject(d) {
                    if (d instanceof $root.plexus.interop.protocol.DiscoveredServiceMethod)
                        return d;
                    var m = new $root.plexus.interop.protocol.DiscoveredServiceMethod();
                    if (d.methodId != null) {
                        m.methodId = String(d.methodId);
                    }
                    if (d.methodTitle != null) {
                        m.methodTitle = String(d.methodTitle);
                    }
                    if (d.inputMessageId != null) {
                        m.inputMessageId = String(d.inputMessageId);
                    }
                    if (d.outputMessageId != null) {
                        m.outputMessageId = String(d.outputMessageId);
                    }
                    switch (d.methodType) {
                    case "Unary":
                    case 0:
                        m.methodType = 0;
                        break;
                    case "ServerStreaming":
                    case 1:
                        m.methodType = 1;
                        break;
                    case "ClientStreaming":
                    case 2:
                        m.methodType = 2;
                        break;
                    case "DuplexStreaming":
                    case 3:
                        m.methodType = 3;
                        break;
                    }
                    if (d.options) {
                        if (!Array.isArray(d.options))
                            throw TypeError(".plexus.interop.protocol.DiscoveredServiceMethod.options: array expected");
                        m.options = [];
                        for (var i = 0; i < d.options.length; ++i) {
                            if (typeof d.options[i] !== "object")
                                throw TypeError(".plexus.interop.protocol.DiscoveredServiceMethod.options: object expected");
                            m.options[i] = $root.plexus.interop.protocol.Option.fromObject(d.options[i]);
                        }
                    }
                    return m;
                };

                /**
                 * Creates a plain object from a DiscoveredServiceMethod message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof plexus.interop.protocol.DiscoveredServiceMethod
                 * @static
                 * @param {plexus.interop.protocol.DiscoveredServiceMethod} m DiscoveredServiceMethod
                 * @param {$protobuf.IConversionOptions} [o] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DiscoveredServiceMethod.toObject = function toObject(m, o) {
                    if (!o)
                        o = {};
                    var d = {};
                    if (o.arrays || o.defaults) {
                        d.options = [];
                    }
                    if (o.defaults) {
                        d.methodId = "";
                        d.methodTitle = "";
                        d.inputMessageId = "";
                        d.outputMessageId = "";
                        d.methodType = o.enums === String ? "Unary" : 0;
                    }
                    if (m.methodId != null && m.hasOwnProperty("methodId")) {
                        d.methodId = m.methodId;
                    }
                    if (m.methodTitle != null && m.hasOwnProperty("methodTitle")) {
                        d.methodTitle = m.methodTitle;
                    }
                    if (m.inputMessageId != null && m.hasOwnProperty("inputMessageId")) {
                        d.inputMessageId = m.inputMessageId;
                    }
                    if (m.outputMessageId != null && m.hasOwnProperty("outputMessageId")) {
                        d.outputMessageId = m.outputMessageId;
                    }
                    if (m.methodType != null && m.hasOwnProperty("methodType")) {
                        d.methodType = o.enums === String ? $root.plexus.interop.protocol.MethodType[m.methodType] : m.methodType;
                    }
                    if (m.options && m.options.length) {
                        d.options = [];
                        for (var j = 0; j < m.options.length; ++j) {
                            d.options[j] = $root.plexus.interop.protocol.Option.toObject(m.options[j], o);
                        }
                    }
                    return d;
                };

                /**
                 * Converts this DiscoveredServiceMethod to JSON.
                 * @function toJSON
                 * @memberof plexus.interop.protocol.DiscoveredServiceMethod
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DiscoveredServiceMethod.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DiscoveredServiceMethod;
            })();

            protocol.MethodDiscoveryRequest = (function() {

                /**
                 * Properties of a MethodDiscoveryRequest.
                 * @memberof plexus.interop.protocol
                 * @interface IMethodDiscoveryRequest
                 * @property {string} [inputMessageId] MethodDiscoveryRequest inputMessageId
                 * @property {string} [outputMessageId] MethodDiscoveryRequest outputMessageId
                 * @property {plexus.interop.protocol.IConsumedMethodReference} [consumedMethod] MethodDiscoveryRequest consumedMethod
                 * @property {plexus.interop.protocol.DiscoveryMode} [discoveryMode] MethodDiscoveryRequest discoveryMode
                 */

                /**
                 * Constructs a new MethodDiscoveryRequest.
                 * @memberof plexus.interop.protocol
                 * @classdesc Represents a MethodDiscoveryRequest.
                 * @constructor
                 * @param {plexus.interop.protocol.IMethodDiscoveryRequest=} [p] Properties to set
                 */
                function MethodDiscoveryRequest(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * MethodDiscoveryRequest inputMessageId.
                 * @member {string}inputMessageId
                 * @memberof plexus.interop.protocol.MethodDiscoveryRequest
                 * @instance
                 */
                MethodDiscoveryRequest.prototype.inputMessageId = "";

                /**
                 * MethodDiscoveryRequest outputMessageId.
                 * @member {string}outputMessageId
                 * @memberof plexus.interop.protocol.MethodDiscoveryRequest
                 * @instance
                 */
                MethodDiscoveryRequest.prototype.outputMessageId = "";

                /**
                 * MethodDiscoveryRequest consumedMethod.
                 * @member {(plexus.interop.protocol.IConsumedMethodReference|null|undefined)}consumedMethod
                 * @memberof plexus.interop.protocol.MethodDiscoveryRequest
                 * @instance
                 */
                MethodDiscoveryRequest.prototype.consumedMethod = null;

                /**
                 * MethodDiscoveryRequest discoveryMode.
                 * @member {plexus.interop.protocol.DiscoveryMode}discoveryMode
                 * @memberof plexus.interop.protocol.MethodDiscoveryRequest
                 * @instance
                 */
                MethodDiscoveryRequest.prototype.discoveryMode = 0;

                /**
                 * Encodes the specified MethodDiscoveryRequest message. Does not implicitly {@link plexus.interop.protocol.MethodDiscoveryRequest.verify|verify} messages.
                 * @function encode
                 * @memberof plexus.interop.protocol.MethodDiscoveryRequest
                 * @static
                 * @param {plexus.interop.protocol.IMethodDiscoveryRequest} m MethodDiscoveryRequest message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodDiscoveryRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.inputMessageId != null && m.hasOwnProperty("inputMessageId"))
                        w.uint32(10).string(m.inputMessageId);
                    if (m.outputMessageId != null && m.hasOwnProperty("outputMessageId"))
                        w.uint32(18).string(m.outputMessageId);
                    if (m.consumedMethod != null && m.hasOwnProperty("consumedMethod"))
                        $root.plexus.interop.protocol.ConsumedMethodReference.encode(m.consumedMethod, w.uint32(26).fork()).ldelim();
                    if (m.discoveryMode != null && m.hasOwnProperty("discoveryMode"))
                        w.uint32(32).int32(m.discoveryMode);
                    return w;
                };

                /**
                 * Decodes a MethodDiscoveryRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof plexus.interop.protocol.MethodDiscoveryRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {plexus.interop.protocol.MethodDiscoveryRequest} MethodDiscoveryRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodDiscoveryRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.interop.protocol.MethodDiscoveryRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.inputMessageId = r.string();
                            break;
                        case 2:
                            m.outputMessageId = r.string();
                            break;
                        case 3:
                            m.consumedMethod = $root.plexus.interop.protocol.ConsumedMethodReference.decode(r, r.uint32());
                            break;
                        case 4:
                            m.discoveryMode = r.int32();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                /**
                 * Creates a MethodDiscoveryRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof plexus.interop.protocol.MethodDiscoveryRequest
                 * @static
                 * @param {Object.<string,*>} d Plain object
                 * @returns {plexus.interop.protocol.MethodDiscoveryRequest} MethodDiscoveryRequest
                 */
                MethodDiscoveryRequest.fromObject = function fromObject(d) {
                    if (d instanceof $root.plexus.interop.protocol.MethodDiscoveryRequest)
                        return d;
                    var m = new $root.plexus.interop.protocol.MethodDiscoveryRequest();
                    if (d.inputMessageId != null) {
                        m.inputMessageId = String(d.inputMessageId);
                    }
                    if (d.outputMessageId != null) {
                        m.outputMessageId = String(d.outputMessageId);
                    }
                    if (d.consumedMethod != null) {
                        if (typeof d.consumedMethod !== "object")
                            throw TypeError(".plexus.interop.protocol.MethodDiscoveryRequest.consumedMethod: object expected");
                        m.consumedMethod = $root.plexus.interop.protocol.ConsumedMethodReference.fromObject(d.consumedMethod);
                    }
                    switch (d.discoveryMode) {
                    case "Offline":
                    case 0:
                        m.discoveryMode = 0;
                        break;
                    case "Online":
                    case 1:
                        m.discoveryMode = 1;
                        break;
                    }
                    return m;
                };

                /**
                 * Creates a plain object from a MethodDiscoveryRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof plexus.interop.protocol.MethodDiscoveryRequest
                 * @static
                 * @param {plexus.interop.protocol.MethodDiscoveryRequest} m MethodDiscoveryRequest
                 * @param {$protobuf.IConversionOptions} [o] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MethodDiscoveryRequest.toObject = function toObject(m, o) {
                    if (!o)
                        o = {};
                    var d = {};
                    if (o.defaults) {
                        d.inputMessageId = "";
                        d.outputMessageId = "";
                        d.consumedMethod = null;
                        d.discoveryMode = o.enums === String ? "Offline" : 0;
                    }
                    if (m.inputMessageId != null && m.hasOwnProperty("inputMessageId")) {
                        d.inputMessageId = m.inputMessageId;
                    }
                    if (m.outputMessageId != null && m.hasOwnProperty("outputMessageId")) {
                        d.outputMessageId = m.outputMessageId;
                    }
                    if (m.consumedMethod != null && m.hasOwnProperty("consumedMethod")) {
                        d.consumedMethod = $root.plexus.interop.protocol.ConsumedMethodReference.toObject(m.consumedMethod, o);
                    }
                    if (m.discoveryMode != null && m.hasOwnProperty("discoveryMode")) {
                        d.discoveryMode = o.enums === String ? $root.plexus.interop.protocol.DiscoveryMode[m.discoveryMode] : m.discoveryMode;
                    }
                    return d;
                };

                /**
                 * Converts this MethodDiscoveryRequest to JSON.
                 * @function toJSON
                 * @memberof plexus.interop.protocol.MethodDiscoveryRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MethodDiscoveryRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MethodDiscoveryRequest;
            })();

            protocol.MethodDiscoveryResponse = (function() {

                /**
                 * Properties of a MethodDiscoveryResponse.
                 * @memberof plexus.interop.protocol
                 * @interface IMethodDiscoveryResponse
                 * @property {Array.<plexus.interop.protocol.IDiscoveredMethod>} [methods] MethodDiscoveryResponse methods
                 */

                /**
                 * Constructs a new MethodDiscoveryResponse.
                 * @memberof plexus.interop.protocol
                 * @classdesc Represents a MethodDiscoveryResponse.
                 * @constructor
                 * @param {plexus.interop.protocol.IMethodDiscoveryResponse=} [p] Properties to set
                 */
                function MethodDiscoveryResponse(p) {
                    this.methods = [];
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * MethodDiscoveryResponse methods.
                 * @member {Array.<plexus.interop.protocol.IDiscoveredMethod>}methods
                 * @memberof plexus.interop.protocol.MethodDiscoveryResponse
                 * @instance
                 */
                MethodDiscoveryResponse.prototype.methods = $util.emptyArray;

                /**
                 * Encodes the specified MethodDiscoveryResponse message. Does not implicitly {@link plexus.interop.protocol.MethodDiscoveryResponse.verify|verify} messages.
                 * @function encode
                 * @memberof plexus.interop.protocol.MethodDiscoveryResponse
                 * @static
                 * @param {plexus.interop.protocol.IMethodDiscoveryResponse} m MethodDiscoveryResponse message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodDiscoveryResponse.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.methods != null && m.methods.length) {
                        for (var i = 0; i < m.methods.length; ++i)
                            $root.plexus.interop.protocol.DiscoveredMethod.encode(m.methods[i], w.uint32(10).fork()).ldelim();
                    }
                    return w;
                };

                /**
                 * Decodes a MethodDiscoveryResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof plexus.interop.protocol.MethodDiscoveryResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {plexus.interop.protocol.MethodDiscoveryResponse} MethodDiscoveryResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodDiscoveryResponse.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.interop.protocol.MethodDiscoveryResponse();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            if (!(m.methods && m.methods.length))
                                m.methods = [];
                            m.methods.push($root.plexus.interop.protocol.DiscoveredMethod.decode(r, r.uint32()));
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                /**
                 * Creates a MethodDiscoveryResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof plexus.interop.protocol.MethodDiscoveryResponse
                 * @static
                 * @param {Object.<string,*>} d Plain object
                 * @returns {plexus.interop.protocol.MethodDiscoveryResponse} MethodDiscoveryResponse
                 */
                MethodDiscoveryResponse.fromObject = function fromObject(d) {
                    if (d instanceof $root.plexus.interop.protocol.MethodDiscoveryResponse)
                        return d;
                    var m = new $root.plexus.interop.protocol.MethodDiscoveryResponse();
                    if (d.methods) {
                        if (!Array.isArray(d.methods))
                            throw TypeError(".plexus.interop.protocol.MethodDiscoveryResponse.methods: array expected");
                        m.methods = [];
                        for (var i = 0; i < d.methods.length; ++i) {
                            if (typeof d.methods[i] !== "object")
                                throw TypeError(".plexus.interop.protocol.MethodDiscoveryResponse.methods: object expected");
                            m.methods[i] = $root.plexus.interop.protocol.DiscoveredMethod.fromObject(d.methods[i]);
                        }
                    }
                    return m;
                };

                /**
                 * Creates a plain object from a MethodDiscoveryResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof plexus.interop.protocol.MethodDiscoveryResponse
                 * @static
                 * @param {plexus.interop.protocol.MethodDiscoveryResponse} m MethodDiscoveryResponse
                 * @param {$protobuf.IConversionOptions} [o] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MethodDiscoveryResponse.toObject = function toObject(m, o) {
                    if (!o)
                        o = {};
                    var d = {};
                    if (o.arrays || o.defaults) {
                        d.methods = [];
                    }
                    if (m.methods && m.methods.length) {
                        d.methods = [];
                        for (var j = 0; j < m.methods.length; ++j) {
                            d.methods[j] = $root.plexus.interop.protocol.DiscoveredMethod.toObject(m.methods[j], o);
                        }
                    }
                    return d;
                };

                /**
                 * Converts this MethodDiscoveryResponse to JSON.
                 * @function toJSON
                 * @memberof plexus.interop.protocol.MethodDiscoveryResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MethodDiscoveryResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MethodDiscoveryResponse;
            })();

            protocol.DiscoveredMethod = (function() {

                /**
                 * Properties of a DiscoveredMethod.
                 * @memberof plexus.interop.protocol
                 * @interface IDiscoveredMethod
                 * @property {plexus.interop.protocol.IProvidedMethodReference} [providedMethod] DiscoveredMethod providedMethod
                 * @property {string} [methodTitle] DiscoveredMethod methodTitle
                 * @property {string} [inputMessageId] DiscoveredMethod inputMessageId
                 * @property {string} [outputMessageId] DiscoveredMethod outputMessageId
                 * @property {plexus.interop.protocol.MethodType} [methodType] DiscoveredMethod methodType
                 * @property {Array.<plexus.interop.protocol.IOption>} [options] DiscoveredMethod options
                 */

                /**
                 * Constructs a new DiscoveredMethod.
                 * @memberof plexus.interop.protocol
                 * @classdesc Represents a DiscoveredMethod.
                 * @constructor
                 * @param {plexus.interop.protocol.IDiscoveredMethod=} [p] Properties to set
                 */
                function DiscoveredMethod(p) {
                    this.options = [];
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * DiscoveredMethod providedMethod.
                 * @member {(plexus.interop.protocol.IProvidedMethodReference|null|undefined)}providedMethod
                 * @memberof plexus.interop.protocol.DiscoveredMethod
                 * @instance
                 */
                DiscoveredMethod.prototype.providedMethod = null;

                /**
                 * DiscoveredMethod methodTitle.
                 * @member {string}methodTitle
                 * @memberof plexus.interop.protocol.DiscoveredMethod
                 * @instance
                 */
                DiscoveredMethod.prototype.methodTitle = "";

                /**
                 * DiscoveredMethod inputMessageId.
                 * @member {string}inputMessageId
                 * @memberof plexus.interop.protocol.DiscoveredMethod
                 * @instance
                 */
                DiscoveredMethod.prototype.inputMessageId = "";

                /**
                 * DiscoveredMethod outputMessageId.
                 * @member {string}outputMessageId
                 * @memberof plexus.interop.protocol.DiscoveredMethod
                 * @instance
                 */
                DiscoveredMethod.prototype.outputMessageId = "";

                /**
                 * DiscoveredMethod methodType.
                 * @member {plexus.interop.protocol.MethodType}methodType
                 * @memberof plexus.interop.protocol.DiscoveredMethod
                 * @instance
                 */
                DiscoveredMethod.prototype.methodType = 0;

                /**
                 * DiscoveredMethod options.
                 * @member {Array.<plexus.interop.protocol.IOption>}options
                 * @memberof plexus.interop.protocol.DiscoveredMethod
                 * @instance
                 */
                DiscoveredMethod.prototype.options = $util.emptyArray;

                /**
                 * Encodes the specified DiscoveredMethod message. Does not implicitly {@link plexus.interop.protocol.DiscoveredMethod.verify|verify} messages.
                 * @function encode
                 * @memberof plexus.interop.protocol.DiscoveredMethod
                 * @static
                 * @param {plexus.interop.protocol.IDiscoveredMethod} m DiscoveredMethod message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DiscoveredMethod.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.providedMethod != null && m.hasOwnProperty("providedMethod"))
                        $root.plexus.interop.protocol.ProvidedMethodReference.encode(m.providedMethod, w.uint32(10).fork()).ldelim();
                    if (m.methodTitle != null && m.hasOwnProperty("methodTitle"))
                        w.uint32(18).string(m.methodTitle);
                    if (m.inputMessageId != null && m.hasOwnProperty("inputMessageId"))
                        w.uint32(26).string(m.inputMessageId);
                    if (m.outputMessageId != null && m.hasOwnProperty("outputMessageId"))
                        w.uint32(34).string(m.outputMessageId);
                    if (m.methodType != null && m.hasOwnProperty("methodType"))
                        w.uint32(40).int32(m.methodType);
                    if (m.options != null && m.options.length) {
                        for (var i = 0; i < m.options.length; ++i)
                            $root.plexus.interop.protocol.Option.encode(m.options[i], w.uint32(50).fork()).ldelim();
                    }
                    return w;
                };

                /**
                 * Decodes a DiscoveredMethod message from the specified reader or buffer.
                 * @function decode
                 * @memberof plexus.interop.protocol.DiscoveredMethod
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {plexus.interop.protocol.DiscoveredMethod} DiscoveredMethod
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DiscoveredMethod.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.interop.protocol.DiscoveredMethod();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.providedMethod = $root.plexus.interop.protocol.ProvidedMethodReference.decode(r, r.uint32());
                            break;
                        case 2:
                            m.methodTitle = r.string();
                            break;
                        case 3:
                            m.inputMessageId = r.string();
                            break;
                        case 4:
                            m.outputMessageId = r.string();
                            break;
                        case 5:
                            m.methodType = r.int32();
                            break;
                        case 6:
                            if (!(m.options && m.options.length))
                                m.options = [];
                            m.options.push($root.plexus.interop.protocol.Option.decode(r, r.uint32()));
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                /**
                 * Creates a DiscoveredMethod message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof plexus.interop.protocol.DiscoveredMethod
                 * @static
                 * @param {Object.<string,*>} d Plain object
                 * @returns {plexus.interop.protocol.DiscoveredMethod} DiscoveredMethod
                 */
                DiscoveredMethod.fromObject = function fromObject(d) {
                    if (d instanceof $root.plexus.interop.protocol.DiscoveredMethod)
                        return d;
                    var m = new $root.plexus.interop.protocol.DiscoveredMethod();
                    if (d.providedMethod != null) {
                        if (typeof d.providedMethod !== "object")
                            throw TypeError(".plexus.interop.protocol.DiscoveredMethod.providedMethod: object expected");
                        m.providedMethod = $root.plexus.interop.protocol.ProvidedMethodReference.fromObject(d.providedMethod);
                    }
                    if (d.methodTitle != null) {
                        m.methodTitle = String(d.methodTitle);
                    }
                    if (d.inputMessageId != null) {
                        m.inputMessageId = String(d.inputMessageId);
                    }
                    if (d.outputMessageId != null) {
                        m.outputMessageId = String(d.outputMessageId);
                    }
                    switch (d.methodType) {
                    case "Unary":
                    case 0:
                        m.methodType = 0;
                        break;
                    case "ServerStreaming":
                    case 1:
                        m.methodType = 1;
                        break;
                    case "ClientStreaming":
                    case 2:
                        m.methodType = 2;
                        break;
                    case "DuplexStreaming":
                    case 3:
                        m.methodType = 3;
                        break;
                    }
                    if (d.options) {
                        if (!Array.isArray(d.options))
                            throw TypeError(".plexus.interop.protocol.DiscoveredMethod.options: array expected");
                        m.options = [];
                        for (var i = 0; i < d.options.length; ++i) {
                            if (typeof d.options[i] !== "object")
                                throw TypeError(".plexus.interop.protocol.DiscoveredMethod.options: object expected");
                            m.options[i] = $root.plexus.interop.protocol.Option.fromObject(d.options[i]);
                        }
                    }
                    return m;
                };

                /**
                 * Creates a plain object from a DiscoveredMethod message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof plexus.interop.protocol.DiscoveredMethod
                 * @static
                 * @param {plexus.interop.protocol.DiscoveredMethod} m DiscoveredMethod
                 * @param {$protobuf.IConversionOptions} [o] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DiscoveredMethod.toObject = function toObject(m, o) {
                    if (!o)
                        o = {};
                    var d = {};
                    if (o.arrays || o.defaults) {
                        d.options = [];
                    }
                    if (o.defaults) {
                        d.providedMethod = null;
                        d.methodTitle = "";
                        d.inputMessageId = "";
                        d.outputMessageId = "";
                        d.methodType = o.enums === String ? "Unary" : 0;
                    }
                    if (m.providedMethod != null && m.hasOwnProperty("providedMethod")) {
                        d.providedMethod = $root.plexus.interop.protocol.ProvidedMethodReference.toObject(m.providedMethod, o);
                    }
                    if (m.methodTitle != null && m.hasOwnProperty("methodTitle")) {
                        d.methodTitle = m.methodTitle;
                    }
                    if (m.inputMessageId != null && m.hasOwnProperty("inputMessageId")) {
                        d.inputMessageId = m.inputMessageId;
                    }
                    if (m.outputMessageId != null && m.hasOwnProperty("outputMessageId")) {
                        d.outputMessageId = m.outputMessageId;
                    }
                    if (m.methodType != null && m.hasOwnProperty("methodType")) {
                        d.methodType = o.enums === String ? $root.plexus.interop.protocol.MethodType[m.methodType] : m.methodType;
                    }
                    if (m.options && m.options.length) {
                        d.options = [];
                        for (var j = 0; j < m.options.length; ++j) {
                            d.options[j] = $root.plexus.interop.protocol.Option.toObject(m.options[j], o);
                        }
                    }
                    return d;
                };

                /**
                 * Converts this DiscoveredMethod to JSON.
                 * @function toJSON
                 * @memberof plexus.interop.protocol.DiscoveredMethod
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DiscoveredMethod.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DiscoveredMethod;
            })();

            protocol.Option = (function() {

                /**
                 * Properties of an Option.
                 * @memberof plexus.interop.protocol
                 * @interface IOption
                 * @property {string} [id] Option id
                 * @property {string} [value] Option value
                 */

                /**
                 * Constructs a new Option.
                 * @memberof plexus.interop.protocol
                 * @classdesc Represents an Option.
                 * @constructor
                 * @param {plexus.interop.protocol.IOption=} [p] Properties to set
                 */
                function Option(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * Option id.
                 * @member {string}id
                 * @memberof plexus.interop.protocol.Option
                 * @instance
                 */
                Option.prototype.id = "";

                /**
                 * Option value.
                 * @member {string}value
                 * @memberof plexus.interop.protocol.Option
                 * @instance
                 */
                Option.prototype.value = "";

                /**
                 * Encodes the specified Option message. Does not implicitly {@link plexus.interop.protocol.Option.verify|verify} messages.
                 * @function encode
                 * @memberof plexus.interop.protocol.Option
                 * @static
                 * @param {plexus.interop.protocol.IOption} m Option message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Option.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.id != null && m.hasOwnProperty("id"))
                        w.uint32(10).string(m.id);
                    if (m.value != null && m.hasOwnProperty("value"))
                        w.uint32(18).string(m.value);
                    return w;
                };

                /**
                 * Decodes an Option message from the specified reader or buffer.
                 * @function decode
                 * @memberof plexus.interop.protocol.Option
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {plexus.interop.protocol.Option} Option
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Option.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.interop.protocol.Option();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.id = r.string();
                            break;
                        case 2:
                            m.value = r.string();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                /**
                 * Creates an Option message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof plexus.interop.protocol.Option
                 * @static
                 * @param {Object.<string,*>} d Plain object
                 * @returns {plexus.interop.protocol.Option} Option
                 */
                Option.fromObject = function fromObject(d) {
                    if (d instanceof $root.plexus.interop.protocol.Option)
                        return d;
                    var m = new $root.plexus.interop.protocol.Option();
                    if (d.id != null) {
                        m.id = String(d.id);
                    }
                    if (d.value != null) {
                        m.value = String(d.value);
                    }
                    return m;
                };

                /**
                 * Creates a plain object from an Option message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof plexus.interop.protocol.Option
                 * @static
                 * @param {plexus.interop.protocol.Option} m Option
                 * @param {$protobuf.IConversionOptions} [o] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Option.toObject = function toObject(m, o) {
                    if (!o)
                        o = {};
                    var d = {};
                    if (o.defaults) {
                        d.id = "";
                        d.value = "";
                    }
                    if (m.id != null && m.hasOwnProperty("id")) {
                        d.id = m.id;
                    }
                    if (m.value != null && m.hasOwnProperty("value")) {
                        d.value = m.value;
                    }
                    return d;
                };

                /**
                 * Converts this Option to JSON.
                 * @function toJSON
                 * @memberof plexus.interop.protocol.Option
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Option.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Option;
            })();

            return protocol;
        })();

        return interop;
    })();

    plexus.UniqueId = (function() {

        /**
         * Properties of an UniqueId.
         * @memberof plexus
         * @interface IUniqueId
         * @property {Long} [lo] UniqueId lo
         * @property {Long} [hi] UniqueId hi
         */

        /**
         * Constructs a new UniqueId.
         * @memberof plexus
         * @classdesc Represents an UniqueId.
         * @constructor
         * @param {plexus.IUniqueId=} [p] Properties to set
         */
        function UniqueId(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * UniqueId lo.
         * @member {Long}lo
         * @memberof plexus.UniqueId
         * @instance
         */
        UniqueId.prototype.lo = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UniqueId hi.
         * @member {Long}hi
         * @memberof plexus.UniqueId
         * @instance
         */
        UniqueId.prototype.hi = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Encodes the specified UniqueId message. Does not implicitly {@link plexus.UniqueId.verify|verify} messages.
         * @function encode
         * @memberof plexus.UniqueId
         * @static
         * @param {plexus.IUniqueId} m UniqueId message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UniqueId.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.lo != null && m.hasOwnProperty("lo"))
                w.uint32(9).fixed64(m.lo);
            if (m.hi != null && m.hasOwnProperty("hi"))
                w.uint32(17).fixed64(m.hi);
            return w;
        };

        /**
         * Decodes an UniqueId message from the specified reader or buffer.
         * @function decode
         * @memberof plexus.UniqueId
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {plexus.UniqueId} UniqueId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UniqueId.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.UniqueId();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.lo = r.fixed64();
                    break;
                case 2:
                    m.hi = r.fixed64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Creates an UniqueId message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof plexus.UniqueId
         * @static
         * @param {Object.<string,*>} d Plain object
         * @returns {plexus.UniqueId} UniqueId
         */
        UniqueId.fromObject = function fromObject(d) {
            if (d instanceof $root.plexus.UniqueId)
                return d;
            var m = new $root.plexus.UniqueId();
            if (d.lo != null) {
                if ($util.Long)
                    (m.lo = $util.Long.fromValue(d.lo)).unsigned = false;
                else if (typeof d.lo === "string")
                    m.lo = parseInt(d.lo, 10);
                else if (typeof d.lo === "number")
                    m.lo = d.lo;
                else if (typeof d.lo === "object")
                    m.lo = new $util.LongBits(d.lo.low >>> 0, d.lo.high >>> 0).toNumber();
            }
            if (d.hi != null) {
                if ($util.Long)
                    (m.hi = $util.Long.fromValue(d.hi)).unsigned = false;
                else if (typeof d.hi === "string")
                    m.hi = parseInt(d.hi, 10);
                else if (typeof d.hi === "number")
                    m.hi = d.hi;
                else if (typeof d.hi === "object")
                    m.hi = new $util.LongBits(d.hi.low >>> 0, d.hi.high >>> 0).toNumber();
            }
            return m;
        };

        /**
         * Creates a plain object from an UniqueId message. Also converts values to other types if specified.
         * @function toObject
         * @memberof plexus.UniqueId
         * @static
         * @param {plexus.UniqueId} m UniqueId
         * @param {$protobuf.IConversionOptions} [o] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UniqueId.toObject = function toObject(m, o) {
            if (!o)
                o = {};
            var d = {};
            if (o.defaults) {
                if ($util.Long) {
                    var n = new $util.Long(0, 0, false);
                    d.lo = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
                } else
                    d.lo = o.longs === String ? "0" : 0;
                if ($util.Long) {
                    var n = new $util.Long(0, 0, false);
                    d.hi = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
                } else
                    d.hi = o.longs === String ? "0" : 0;
            }
            if (m.lo != null && m.hasOwnProperty("lo")) {
                if (typeof m.lo === "number")
                    d.lo = o.longs === String ? String(m.lo) : m.lo;
                else
                    d.lo = o.longs === String ? $util.Long.prototype.toString.call(m.lo) : o.longs === Number ? new $util.LongBits(m.lo.low >>> 0, m.lo.high >>> 0).toNumber() : m.lo;
            }
            if (m.hi != null && m.hasOwnProperty("hi")) {
                if (typeof m.hi === "number")
                    d.hi = o.longs === String ? String(m.hi) : m.hi;
                else
                    d.hi = o.longs === String ? $util.Long.prototype.toString.call(m.hi) : o.longs === Number ? new $util.LongBits(m.hi.low >>> 0, m.hi.high >>> 0).toNumber() : m.hi;
            }
            return d;
        };

        /**
         * Converts this UniqueId to JSON.
         * @function toJSON
         * @memberof plexus.UniqueId
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UniqueId.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UniqueId;
    })();

    plexus.Error = (function() {

        /**
         * Properties of an Error.
         * @memberof plexus
         * @interface IError
         * @property {string} [message] Error message
         * @property {string} [details] Error details
         */

        /**
         * Constructs a new Error.
         * @memberof plexus
         * @classdesc Represents an Error.
         * @constructor
         * @param {plexus.IError=} [p] Properties to set
         */
        function Error(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Error message.
         * @member {string}message
         * @memberof plexus.Error
         * @instance
         */
        Error.prototype.message = "";

        /**
         * Error details.
         * @member {string}details
         * @memberof plexus.Error
         * @instance
         */
        Error.prototype.details = "";

        /**
         * Encodes the specified Error message. Does not implicitly {@link plexus.Error.verify|verify} messages.
         * @function encode
         * @memberof plexus.Error
         * @static
         * @param {plexus.IError} m Error message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Error.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.message != null && m.hasOwnProperty("message"))
                w.uint32(10).string(m.message);
            if (m.details != null && m.hasOwnProperty("details"))
                w.uint32(18).string(m.details);
            return w;
        };

        /**
         * Decodes an Error message from the specified reader or buffer.
         * @function decode
         * @memberof plexus.Error
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {plexus.Error} Error
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Error.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.Error();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.message = r.string();
                    break;
                case 2:
                    m.details = r.string();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Creates an Error message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof plexus.Error
         * @static
         * @param {Object.<string,*>} d Plain object
         * @returns {plexus.Error} Error
         */
        Error.fromObject = function fromObject(d) {
            if (d instanceof $root.plexus.Error)
                return d;
            var m = new $root.plexus.Error();
            if (d.message != null) {
                m.message = String(d.message);
            }
            if (d.details != null) {
                m.details = String(d.details);
            }
            return m;
        };

        /**
         * Creates a plain object from an Error message. Also converts values to other types if specified.
         * @function toObject
         * @memberof plexus.Error
         * @static
         * @param {plexus.Error} m Error
         * @param {$protobuf.IConversionOptions} [o] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Error.toObject = function toObject(m, o) {
            if (!o)
                o = {};
            var d = {};
            if (o.defaults) {
                d.message = "";
                d.details = "";
            }
            if (m.message != null && m.hasOwnProperty("message")) {
                d.message = m.message;
            }
            if (m.details != null && m.hasOwnProperty("details")) {
                d.details = m.details;
            }
            return d;
        };

        /**
         * Converts this Error to JSON.
         * @function toJSON
         * @memberof plexus.Error
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Error.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Error;
    })();

    plexus.Completion = (function() {

        /**
         * Properties of a Completion.
         * @memberof plexus
         * @interface ICompletion
         * @property {plexus.Completion.Status} [status] Completion status
         * @property {plexus.IError} [error] Completion error
         */

        /**
         * Constructs a new Completion.
         * @memberof plexus
         * @classdesc Represents a Completion.
         * @constructor
         * @param {plexus.ICompletion=} [p] Properties to set
         */
        function Completion(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Completion status.
         * @member {plexus.Completion.Status}status
         * @memberof plexus.Completion
         * @instance
         */
        Completion.prototype.status = 0;

        /**
         * Completion error.
         * @member {(plexus.IError|null|undefined)}error
         * @memberof plexus.Completion
         * @instance
         */
        Completion.prototype.error = null;

        /**
         * Encodes the specified Completion message. Does not implicitly {@link plexus.Completion.verify|verify} messages.
         * @function encode
         * @memberof plexus.Completion
         * @static
         * @param {plexus.ICompletion} m Completion message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Completion.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.status != null && m.hasOwnProperty("status"))
                w.uint32(8).int32(m.status);
            if (m.error != null && m.hasOwnProperty("error"))
                $root.plexus.Error.encode(m.error, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a Completion message from the specified reader or buffer.
         * @function decode
         * @memberof plexus.Completion
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {plexus.Completion} Completion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Completion.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.Completion();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.status = r.int32();
                    break;
                case 2:
                    m.error = $root.plexus.Error.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Creates a Completion message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof plexus.Completion
         * @static
         * @param {Object.<string,*>} d Plain object
         * @returns {plexus.Completion} Completion
         */
        Completion.fromObject = function fromObject(d) {
            if (d instanceof $root.plexus.Completion)
                return d;
            var m = new $root.plexus.Completion();
            switch (d.status) {
            case "Completed":
            case 0:
                m.status = 0;
                break;
            case "Canceled":
            case 1:
                m.status = 1;
                break;
            case "Failed":
            case 2:
                m.status = 2;
                break;
            }
            if (d.error != null) {
                if (typeof d.error !== "object")
                    throw TypeError(".plexus.Completion.error: object expected");
                m.error = $root.plexus.Error.fromObject(d.error);
            }
            return m;
        };

        /**
         * Creates a plain object from a Completion message. Also converts values to other types if specified.
         * @function toObject
         * @memberof plexus.Completion
         * @static
         * @param {plexus.Completion} m Completion
         * @param {$protobuf.IConversionOptions} [o] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Completion.toObject = function toObject(m, o) {
            if (!o)
                o = {};
            var d = {};
            if (o.defaults) {
                d.status = o.enums === String ? "Completed" : 0;
                d.error = null;
            }
            if (m.status != null && m.hasOwnProperty("status")) {
                d.status = o.enums === String ? $root.plexus.Completion.Status[m.status] : m.status;
            }
            if (m.error != null && m.hasOwnProperty("error")) {
                d.error = $root.plexus.Error.toObject(m.error, o);
            }
            return d;
        };

        /**
         * Converts this Completion to JSON.
         * @function toJSON
         * @memberof plexus.Completion
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Completion.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Status enum.
         * @enum {string}
         * @property {number} Completed=0 Completed value
         * @property {number} Canceled=1 Canceled value
         * @property {number} Failed=2 Failed value
         */
        Completion.Status = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Completed"] = 0;
            values[valuesById[1] = "Canceled"] = 1;
            values[valuesById[2] = "Failed"] = 2;
            return values;
        })();

        return Completion;
    })();

    return plexus;
})();

module.exports = $root;

},{"protobufjs/minimal":85}],304:[function(require,module,exports){
/*eslint-disable block-scoped-var, no-redeclare, no-control-regex, no-prototype-builtins*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots.plexusTransport || ($protobuf.roots.plexusTransport = {});

$root.plexus = (function() {

    /**
     * Namespace plexus.
     * @exports plexus
     * @namespace
     */
    var plexus = {};

    plexus.interop = (function() {

        /**
         * Namespace interop.
         * @memberof plexus
         * @namespace
         */
        var interop = {};

        interop.transport = (function() {

            /**
             * Namespace transport.
             * @memberof plexus.interop
             * @namespace
             */
            var transport = {};

            transport.protocol = (function() {

                /**
                 * Namespace protocol.
                 * @memberof plexus.interop.transport
                 * @namespace
                 */
                var protocol = {};

                protocol.MessageFrameHeader = (function() {

                    /**
                     * Properties of a MessageFrameHeader.
                     * @memberof plexus.interop.transport.protocol
                     * @interface IMessageFrameHeader
                     * @property {plexus.IUniqueId} [channelId] MessageFrameHeader channelId
                     * @property {number} [length] MessageFrameHeader length
                     * @property {boolean} [hasMore] MessageFrameHeader hasMore
                     */

                    /**
                     * Constructs a new MessageFrameHeader.
                     * @memberof plexus.interop.transport.protocol
                     * @classdesc Represents a MessageFrameHeader.
                     * @constructor
                     * @param {plexus.interop.transport.protocol.IMessageFrameHeader=} [p] Properties to set
                     */
                    function MessageFrameHeader(p) {
                        if (p)
                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                if (p[ks[i]] != null)
                                    this[ks[i]] = p[ks[i]];
                    }

                    /**
                     * MessageFrameHeader channelId.
                     * @member {(plexus.IUniqueId|null|undefined)}channelId
                     * @memberof plexus.interop.transport.protocol.MessageFrameHeader
                     * @instance
                     */
                    MessageFrameHeader.prototype.channelId = null;

                    /**
                     * MessageFrameHeader length.
                     * @member {number}length
                     * @memberof plexus.interop.transport.protocol.MessageFrameHeader
                     * @instance
                     */
                    MessageFrameHeader.prototype.length = 0;

                    /**
                     * MessageFrameHeader hasMore.
                     * @member {boolean}hasMore
                     * @memberof plexus.interop.transport.protocol.MessageFrameHeader
                     * @instance
                     */
                    MessageFrameHeader.prototype.hasMore = false;

                    /**
                     * Encodes the specified MessageFrameHeader message. Does not implicitly {@link plexus.interop.transport.protocol.MessageFrameHeader.verify|verify} messages.
                     * @function encode
                     * @memberof plexus.interop.transport.protocol.MessageFrameHeader
                     * @static
                     * @param {plexus.interop.transport.protocol.IMessageFrameHeader} m MessageFrameHeader message or plain object to encode
                     * @param {$protobuf.Writer} [w] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MessageFrameHeader.encode = function encode(m, w) {
                        if (!w)
                            w = $Writer.create();
                        if (m.channelId != null && m.hasOwnProperty("channelId"))
                            $root.plexus.UniqueId.encode(m.channelId, w.uint32(10).fork()).ldelim();
                        if (m.length != null && m.hasOwnProperty("length"))
                            w.uint32(16).uint32(m.length);
                        if (m.hasMore != null && m.hasOwnProperty("hasMore"))
                            w.uint32(24).bool(m.hasMore);
                        return w;
                    };

                    /**
                     * Decodes a MessageFrameHeader message from the specified reader or buffer.
                     * @function decode
                     * @memberof plexus.interop.transport.protocol.MessageFrameHeader
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                     * @param {number} [l] Message length if known beforehand
                     * @returns {plexus.interop.transport.protocol.MessageFrameHeader} MessageFrameHeader
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MessageFrameHeader.decode = function decode(r, l) {
                        if (!(r instanceof $Reader))
                            r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.interop.transport.protocol.MessageFrameHeader();
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                            case 1:
                                m.channelId = $root.plexus.UniqueId.decode(r, r.uint32());
                                break;
                            case 2:
                                m.length = r.uint32();
                                break;
                            case 3:
                                m.hasMore = r.bool();
                                break;
                            default:
                                r.skipType(t & 7);
                                break;
                            }
                        }
                        return m;
                    };

                    /**
                     * Creates a MessageFrameHeader message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof plexus.interop.transport.protocol.MessageFrameHeader
                     * @static
                     * @param {Object.<string,*>} d Plain object
                     * @returns {plexus.interop.transport.protocol.MessageFrameHeader} MessageFrameHeader
                     */
                    MessageFrameHeader.fromObject = function fromObject(d) {
                        if (d instanceof $root.plexus.interop.transport.protocol.MessageFrameHeader)
                            return d;
                        var m = new $root.plexus.interop.transport.protocol.MessageFrameHeader();
                        if (d.channelId != null) {
                            if (typeof d.channelId !== "object")
                                throw TypeError(".plexus.interop.transport.protocol.MessageFrameHeader.channelId: object expected");
                            m.channelId = $root.plexus.UniqueId.fromObject(d.channelId);
                        }
                        if (d.length != null) {
                            m.length = d.length >>> 0;
                        }
                        if (d.hasMore != null) {
                            m.hasMore = Boolean(d.hasMore);
                        }
                        return m;
                    };

                    /**
                     * Creates a plain object from a MessageFrameHeader message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof plexus.interop.transport.protocol.MessageFrameHeader
                     * @static
                     * @param {plexus.interop.transport.protocol.MessageFrameHeader} m MessageFrameHeader
                     * @param {$protobuf.IConversionOptions} [o] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    MessageFrameHeader.toObject = function toObject(m, o) {
                        if (!o)
                            o = {};
                        var d = {};
                        if (o.defaults) {
                            d.channelId = null;
                            d.length = 0;
                            d.hasMore = false;
                        }
                        if (m.channelId != null && m.hasOwnProperty("channelId")) {
                            d.channelId = $root.plexus.UniqueId.toObject(m.channelId, o);
                        }
                        if (m.length != null && m.hasOwnProperty("length")) {
                            d.length = m.length;
                        }
                        if (m.hasMore != null && m.hasOwnProperty("hasMore")) {
                            d.hasMore = m.hasMore;
                        }
                        return d;
                    };

                    /**
                     * Converts this MessageFrameHeader to JSON.
                     * @function toJSON
                     * @memberof plexus.interop.transport.protocol.MessageFrameHeader
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    MessageFrameHeader.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return MessageFrameHeader;
                })();

                protocol.ConnectionOpenHeader = (function() {

                    /**
                     * Properties of a ConnectionOpenHeader.
                     * @memberof plexus.interop.transport.protocol
                     * @interface IConnectionOpenHeader
                     * @property {plexus.IUniqueId} [connectionId] ConnectionOpenHeader connectionId
                     */

                    /**
                     * Constructs a new ConnectionOpenHeader.
                     * @memberof plexus.interop.transport.protocol
                     * @classdesc Represents a ConnectionOpenHeader.
                     * @constructor
                     * @param {plexus.interop.transport.protocol.IConnectionOpenHeader=} [p] Properties to set
                     */
                    function ConnectionOpenHeader(p) {
                        if (p)
                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                if (p[ks[i]] != null)
                                    this[ks[i]] = p[ks[i]];
                    }

                    /**
                     * ConnectionOpenHeader connectionId.
                     * @member {(plexus.IUniqueId|null|undefined)}connectionId
                     * @memberof plexus.interop.transport.protocol.ConnectionOpenHeader
                     * @instance
                     */
                    ConnectionOpenHeader.prototype.connectionId = null;

                    /**
                     * Encodes the specified ConnectionOpenHeader message. Does not implicitly {@link plexus.interop.transport.protocol.ConnectionOpenHeader.verify|verify} messages.
                     * @function encode
                     * @memberof plexus.interop.transport.protocol.ConnectionOpenHeader
                     * @static
                     * @param {plexus.interop.transport.protocol.IConnectionOpenHeader} m ConnectionOpenHeader message or plain object to encode
                     * @param {$protobuf.Writer} [w] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ConnectionOpenHeader.encode = function encode(m, w) {
                        if (!w)
                            w = $Writer.create();
                        if (m.connectionId != null && m.hasOwnProperty("connectionId"))
                            $root.plexus.UniqueId.encode(m.connectionId, w.uint32(10).fork()).ldelim();
                        return w;
                    };

                    /**
                     * Decodes a ConnectionOpenHeader message from the specified reader or buffer.
                     * @function decode
                     * @memberof plexus.interop.transport.protocol.ConnectionOpenHeader
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                     * @param {number} [l] Message length if known beforehand
                     * @returns {plexus.interop.transport.protocol.ConnectionOpenHeader} ConnectionOpenHeader
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ConnectionOpenHeader.decode = function decode(r, l) {
                        if (!(r instanceof $Reader))
                            r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.interop.transport.protocol.ConnectionOpenHeader();
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                            case 1:
                                m.connectionId = $root.plexus.UniqueId.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(t & 7);
                                break;
                            }
                        }
                        return m;
                    };

                    /**
                     * Creates a ConnectionOpenHeader message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof plexus.interop.transport.protocol.ConnectionOpenHeader
                     * @static
                     * @param {Object.<string,*>} d Plain object
                     * @returns {plexus.interop.transport.protocol.ConnectionOpenHeader} ConnectionOpenHeader
                     */
                    ConnectionOpenHeader.fromObject = function fromObject(d) {
                        if (d instanceof $root.plexus.interop.transport.protocol.ConnectionOpenHeader)
                            return d;
                        var m = new $root.plexus.interop.transport.protocol.ConnectionOpenHeader();
                        if (d.connectionId != null) {
                            if (typeof d.connectionId !== "object")
                                throw TypeError(".plexus.interop.transport.protocol.ConnectionOpenHeader.connectionId: object expected");
                            m.connectionId = $root.plexus.UniqueId.fromObject(d.connectionId);
                        }
                        return m;
                    };

                    /**
                     * Creates a plain object from a ConnectionOpenHeader message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof plexus.interop.transport.protocol.ConnectionOpenHeader
                     * @static
                     * @param {plexus.interop.transport.protocol.ConnectionOpenHeader} m ConnectionOpenHeader
                     * @param {$protobuf.IConversionOptions} [o] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ConnectionOpenHeader.toObject = function toObject(m, o) {
                        if (!o)
                            o = {};
                        var d = {};
                        if (o.defaults) {
                            d.connectionId = null;
                        }
                        if (m.connectionId != null && m.hasOwnProperty("connectionId")) {
                            d.connectionId = $root.plexus.UniqueId.toObject(m.connectionId, o);
                        }
                        return d;
                    };

                    /**
                     * Converts this ConnectionOpenHeader to JSON.
                     * @function toJSON
                     * @memberof plexus.interop.transport.protocol.ConnectionOpenHeader
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ConnectionOpenHeader.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ConnectionOpenHeader;
                })();

                protocol.ConnectionCloseHeader = (function() {

                    /**
                     * Properties of a ConnectionCloseHeader.
                     * @memberof plexus.interop.transport.protocol
                     * @interface IConnectionCloseHeader
                     * @property {plexus.ICompletion} [completion] ConnectionCloseHeader completion
                     */

                    /**
                     * Constructs a new ConnectionCloseHeader.
                     * @memberof plexus.interop.transport.protocol
                     * @classdesc Represents a ConnectionCloseHeader.
                     * @constructor
                     * @param {plexus.interop.transport.protocol.IConnectionCloseHeader=} [p] Properties to set
                     */
                    function ConnectionCloseHeader(p) {
                        if (p)
                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                if (p[ks[i]] != null)
                                    this[ks[i]] = p[ks[i]];
                    }

                    /**
                     * ConnectionCloseHeader completion.
                     * @member {(plexus.ICompletion|null|undefined)}completion
                     * @memberof plexus.interop.transport.protocol.ConnectionCloseHeader
                     * @instance
                     */
                    ConnectionCloseHeader.prototype.completion = null;

                    /**
                     * Encodes the specified ConnectionCloseHeader message. Does not implicitly {@link plexus.interop.transport.protocol.ConnectionCloseHeader.verify|verify} messages.
                     * @function encode
                     * @memberof plexus.interop.transport.protocol.ConnectionCloseHeader
                     * @static
                     * @param {plexus.interop.transport.protocol.IConnectionCloseHeader} m ConnectionCloseHeader message or plain object to encode
                     * @param {$protobuf.Writer} [w] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ConnectionCloseHeader.encode = function encode(m, w) {
                        if (!w)
                            w = $Writer.create();
                        if (m.completion != null && m.hasOwnProperty("completion"))
                            $root.plexus.Completion.encode(m.completion, w.uint32(10).fork()).ldelim();
                        return w;
                    };

                    /**
                     * Decodes a ConnectionCloseHeader message from the specified reader or buffer.
                     * @function decode
                     * @memberof plexus.interop.transport.protocol.ConnectionCloseHeader
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                     * @param {number} [l] Message length if known beforehand
                     * @returns {plexus.interop.transport.protocol.ConnectionCloseHeader} ConnectionCloseHeader
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ConnectionCloseHeader.decode = function decode(r, l) {
                        if (!(r instanceof $Reader))
                            r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.interop.transport.protocol.ConnectionCloseHeader();
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                            case 1:
                                m.completion = $root.plexus.Completion.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(t & 7);
                                break;
                            }
                        }
                        return m;
                    };

                    /**
                     * Creates a ConnectionCloseHeader message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof plexus.interop.transport.protocol.ConnectionCloseHeader
                     * @static
                     * @param {Object.<string,*>} d Plain object
                     * @returns {plexus.interop.transport.protocol.ConnectionCloseHeader} ConnectionCloseHeader
                     */
                    ConnectionCloseHeader.fromObject = function fromObject(d) {
                        if (d instanceof $root.plexus.interop.transport.protocol.ConnectionCloseHeader)
                            return d;
                        var m = new $root.plexus.interop.transport.protocol.ConnectionCloseHeader();
                        if (d.completion != null) {
                            if (typeof d.completion !== "object")
                                throw TypeError(".plexus.interop.transport.protocol.ConnectionCloseHeader.completion: object expected");
                            m.completion = $root.plexus.Completion.fromObject(d.completion);
                        }
                        return m;
                    };

                    /**
                     * Creates a plain object from a ConnectionCloseHeader message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof plexus.interop.transport.protocol.ConnectionCloseHeader
                     * @static
                     * @param {plexus.interop.transport.protocol.ConnectionCloseHeader} m ConnectionCloseHeader
                     * @param {$protobuf.IConversionOptions} [o] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ConnectionCloseHeader.toObject = function toObject(m, o) {
                        if (!o)
                            o = {};
                        var d = {};
                        if (o.defaults) {
                            d.completion = null;
                        }
                        if (m.completion != null && m.hasOwnProperty("completion")) {
                            d.completion = $root.plexus.Completion.toObject(m.completion, o);
                        }
                        return d;
                    };

                    /**
                     * Converts this ConnectionCloseHeader to JSON.
                     * @function toJSON
                     * @memberof plexus.interop.transport.protocol.ConnectionCloseHeader
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ConnectionCloseHeader.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ConnectionCloseHeader;
                })();

                protocol.ChannelOpenHeader = (function() {

                    /**
                     * Properties of a ChannelOpenHeader.
                     * @memberof plexus.interop.transport.protocol
                     * @interface IChannelOpenHeader
                     * @property {plexus.IUniqueId} [channelId] ChannelOpenHeader channelId
                     */

                    /**
                     * Constructs a new ChannelOpenHeader.
                     * @memberof plexus.interop.transport.protocol
                     * @classdesc Represents a ChannelOpenHeader.
                     * @constructor
                     * @param {plexus.interop.transport.protocol.IChannelOpenHeader=} [p] Properties to set
                     */
                    function ChannelOpenHeader(p) {
                        if (p)
                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                if (p[ks[i]] != null)
                                    this[ks[i]] = p[ks[i]];
                    }

                    /**
                     * ChannelOpenHeader channelId.
                     * @member {(plexus.IUniqueId|null|undefined)}channelId
                     * @memberof plexus.interop.transport.protocol.ChannelOpenHeader
                     * @instance
                     */
                    ChannelOpenHeader.prototype.channelId = null;

                    /**
                     * Encodes the specified ChannelOpenHeader message. Does not implicitly {@link plexus.interop.transport.protocol.ChannelOpenHeader.verify|verify} messages.
                     * @function encode
                     * @memberof plexus.interop.transport.protocol.ChannelOpenHeader
                     * @static
                     * @param {plexus.interop.transport.protocol.IChannelOpenHeader} m ChannelOpenHeader message or plain object to encode
                     * @param {$protobuf.Writer} [w] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ChannelOpenHeader.encode = function encode(m, w) {
                        if (!w)
                            w = $Writer.create();
                        if (m.channelId != null && m.hasOwnProperty("channelId"))
                            $root.plexus.UniqueId.encode(m.channelId, w.uint32(10).fork()).ldelim();
                        return w;
                    };

                    /**
                     * Decodes a ChannelOpenHeader message from the specified reader or buffer.
                     * @function decode
                     * @memberof plexus.interop.transport.protocol.ChannelOpenHeader
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                     * @param {number} [l] Message length if known beforehand
                     * @returns {plexus.interop.transport.protocol.ChannelOpenHeader} ChannelOpenHeader
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ChannelOpenHeader.decode = function decode(r, l) {
                        if (!(r instanceof $Reader))
                            r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.interop.transport.protocol.ChannelOpenHeader();
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                            case 1:
                                m.channelId = $root.plexus.UniqueId.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(t & 7);
                                break;
                            }
                        }
                        return m;
                    };

                    /**
                     * Creates a ChannelOpenHeader message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof plexus.interop.transport.protocol.ChannelOpenHeader
                     * @static
                     * @param {Object.<string,*>} d Plain object
                     * @returns {plexus.interop.transport.protocol.ChannelOpenHeader} ChannelOpenHeader
                     */
                    ChannelOpenHeader.fromObject = function fromObject(d) {
                        if (d instanceof $root.plexus.interop.transport.protocol.ChannelOpenHeader)
                            return d;
                        var m = new $root.plexus.interop.transport.protocol.ChannelOpenHeader();
                        if (d.channelId != null) {
                            if (typeof d.channelId !== "object")
                                throw TypeError(".plexus.interop.transport.protocol.ChannelOpenHeader.channelId: object expected");
                            m.channelId = $root.plexus.UniqueId.fromObject(d.channelId);
                        }
                        return m;
                    };

                    /**
                     * Creates a plain object from a ChannelOpenHeader message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof plexus.interop.transport.protocol.ChannelOpenHeader
                     * @static
                     * @param {plexus.interop.transport.protocol.ChannelOpenHeader} m ChannelOpenHeader
                     * @param {$protobuf.IConversionOptions} [o] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ChannelOpenHeader.toObject = function toObject(m, o) {
                        if (!o)
                            o = {};
                        var d = {};
                        if (o.defaults) {
                            d.channelId = null;
                        }
                        if (m.channelId != null && m.hasOwnProperty("channelId")) {
                            d.channelId = $root.plexus.UniqueId.toObject(m.channelId, o);
                        }
                        return d;
                    };

                    /**
                     * Converts this ChannelOpenHeader to JSON.
                     * @function toJSON
                     * @memberof plexus.interop.transport.protocol.ChannelOpenHeader
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ChannelOpenHeader.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ChannelOpenHeader;
                })();

                protocol.ChannelCloseHeader = (function() {

                    /**
                     * Properties of a ChannelCloseHeader.
                     * @memberof plexus.interop.transport.protocol
                     * @interface IChannelCloseHeader
                     * @property {plexus.IUniqueId} [channelId] ChannelCloseHeader channelId
                     * @property {plexus.ICompletion} [completion] ChannelCloseHeader completion
                     */

                    /**
                     * Constructs a new ChannelCloseHeader.
                     * @memberof plexus.interop.transport.protocol
                     * @classdesc Represents a ChannelCloseHeader.
                     * @constructor
                     * @param {plexus.interop.transport.protocol.IChannelCloseHeader=} [p] Properties to set
                     */
                    function ChannelCloseHeader(p) {
                        if (p)
                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                if (p[ks[i]] != null)
                                    this[ks[i]] = p[ks[i]];
                    }

                    /**
                     * ChannelCloseHeader channelId.
                     * @member {(plexus.IUniqueId|null|undefined)}channelId
                     * @memberof plexus.interop.transport.protocol.ChannelCloseHeader
                     * @instance
                     */
                    ChannelCloseHeader.prototype.channelId = null;

                    /**
                     * ChannelCloseHeader completion.
                     * @member {(plexus.ICompletion|null|undefined)}completion
                     * @memberof plexus.interop.transport.protocol.ChannelCloseHeader
                     * @instance
                     */
                    ChannelCloseHeader.prototype.completion = null;

                    /**
                     * Encodes the specified ChannelCloseHeader message. Does not implicitly {@link plexus.interop.transport.protocol.ChannelCloseHeader.verify|verify} messages.
                     * @function encode
                     * @memberof plexus.interop.transport.protocol.ChannelCloseHeader
                     * @static
                     * @param {plexus.interop.transport.protocol.IChannelCloseHeader} m ChannelCloseHeader message or plain object to encode
                     * @param {$protobuf.Writer} [w] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ChannelCloseHeader.encode = function encode(m, w) {
                        if (!w)
                            w = $Writer.create();
                        if (m.channelId != null && m.hasOwnProperty("channelId"))
                            $root.plexus.UniqueId.encode(m.channelId, w.uint32(10).fork()).ldelim();
                        if (m.completion != null && m.hasOwnProperty("completion"))
                            $root.plexus.Completion.encode(m.completion, w.uint32(18).fork()).ldelim();
                        return w;
                    };

                    /**
                     * Decodes a ChannelCloseHeader message from the specified reader or buffer.
                     * @function decode
                     * @memberof plexus.interop.transport.protocol.ChannelCloseHeader
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                     * @param {number} [l] Message length if known beforehand
                     * @returns {plexus.interop.transport.protocol.ChannelCloseHeader} ChannelCloseHeader
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ChannelCloseHeader.decode = function decode(r, l) {
                        if (!(r instanceof $Reader))
                            r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.interop.transport.protocol.ChannelCloseHeader();
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                            case 1:
                                m.channelId = $root.plexus.UniqueId.decode(r, r.uint32());
                                break;
                            case 2:
                                m.completion = $root.plexus.Completion.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(t & 7);
                                break;
                            }
                        }
                        return m;
                    };

                    /**
                     * Creates a ChannelCloseHeader message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof plexus.interop.transport.protocol.ChannelCloseHeader
                     * @static
                     * @param {Object.<string,*>} d Plain object
                     * @returns {plexus.interop.transport.protocol.ChannelCloseHeader} ChannelCloseHeader
                     */
                    ChannelCloseHeader.fromObject = function fromObject(d) {
                        if (d instanceof $root.plexus.interop.transport.protocol.ChannelCloseHeader)
                            return d;
                        var m = new $root.plexus.interop.transport.protocol.ChannelCloseHeader();
                        if (d.channelId != null) {
                            if (typeof d.channelId !== "object")
                                throw TypeError(".plexus.interop.transport.protocol.ChannelCloseHeader.channelId: object expected");
                            m.channelId = $root.plexus.UniqueId.fromObject(d.channelId);
                        }
                        if (d.completion != null) {
                            if (typeof d.completion !== "object")
                                throw TypeError(".plexus.interop.transport.protocol.ChannelCloseHeader.completion: object expected");
                            m.completion = $root.plexus.Completion.fromObject(d.completion);
                        }
                        return m;
                    };

                    /**
                     * Creates a plain object from a ChannelCloseHeader message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof plexus.interop.transport.protocol.ChannelCloseHeader
                     * @static
                     * @param {plexus.interop.transport.protocol.ChannelCloseHeader} m ChannelCloseHeader
                     * @param {$protobuf.IConversionOptions} [o] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ChannelCloseHeader.toObject = function toObject(m, o) {
                        if (!o)
                            o = {};
                        var d = {};
                        if (o.defaults) {
                            d.channelId = null;
                            d.completion = null;
                        }
                        if (m.channelId != null && m.hasOwnProperty("channelId")) {
                            d.channelId = $root.plexus.UniqueId.toObject(m.channelId, o);
                        }
                        if (m.completion != null && m.hasOwnProperty("completion")) {
                            d.completion = $root.plexus.Completion.toObject(m.completion, o);
                        }
                        return d;
                    };

                    /**
                     * Converts this ChannelCloseHeader to JSON.
                     * @function toJSON
                     * @memberof plexus.interop.transport.protocol.ChannelCloseHeader
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ChannelCloseHeader.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ChannelCloseHeader;
                })();

                protocol.Header = (function() {

                    /**
                     * Properties of a Header.
                     * @memberof plexus.interop.transport.protocol
                     * @interface IHeader
                     * @property {plexus.interop.transport.protocol.IMessageFrameHeader} [messageFrame] Header messageFrame
                     * @property {plexus.interop.transport.protocol.IChannelOpenHeader} [channelOpen] Header channelOpen
                     * @property {plexus.interop.transport.protocol.IChannelCloseHeader} [channelClose] Header channelClose
                     * @property {plexus.interop.transport.protocol.IConnectionOpenHeader} [open] Header open
                     * @property {plexus.interop.transport.protocol.IConnectionCloseHeader} [close] Header close
                     */

                    /**
                     * Constructs a new Header.
                     * @memberof plexus.interop.transport.protocol
                     * @classdesc Represents a Header.
                     * @constructor
                     * @param {plexus.interop.transport.protocol.IHeader=} [p] Properties to set
                     */
                    function Header(p) {
                        if (p)
                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                if (p[ks[i]] != null)
                                    this[ks[i]] = p[ks[i]];
                    }

                    /**
                     * Header messageFrame.
                     * @member {(plexus.interop.transport.protocol.IMessageFrameHeader|null|undefined)}messageFrame
                     * @memberof plexus.interop.transport.protocol.Header
                     * @instance
                     */
                    Header.prototype.messageFrame = null;

                    /**
                     * Header channelOpen.
                     * @member {(plexus.interop.transport.protocol.IChannelOpenHeader|null|undefined)}channelOpen
                     * @memberof plexus.interop.transport.protocol.Header
                     * @instance
                     */
                    Header.prototype.channelOpen = null;

                    /**
                     * Header channelClose.
                     * @member {(plexus.interop.transport.protocol.IChannelCloseHeader|null|undefined)}channelClose
                     * @memberof plexus.interop.transport.protocol.Header
                     * @instance
                     */
                    Header.prototype.channelClose = null;

                    /**
                     * Header open.
                     * @member {(plexus.interop.transport.protocol.IConnectionOpenHeader|null|undefined)}open
                     * @memberof plexus.interop.transport.protocol.Header
                     * @instance
                     */
                    Header.prototype.open = null;

                    /**
                     * Header close.
                     * @member {(plexus.interop.transport.protocol.IConnectionCloseHeader|null|undefined)}close
                     * @memberof plexus.interop.transport.protocol.Header
                     * @instance
                     */
                    Header.prototype.close = null;

                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;

                    /**
                     * Header content.
                     * @member {string|undefined} content
                     * @memberof plexus.interop.transport.protocol.Header
                     * @instance
                     */
                    Object.defineProperty(Header.prototype, "content", {
                        get: $util.oneOfGetter($oneOfFields = ["messageFrame", "channelOpen", "channelClose", "open", "close"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Encodes the specified Header message. Does not implicitly {@link plexus.interop.transport.protocol.Header.verify|verify} messages.
                     * @function encode
                     * @memberof plexus.interop.transport.protocol.Header
                     * @static
                     * @param {plexus.interop.transport.protocol.IHeader} m Header message or plain object to encode
                     * @param {$protobuf.Writer} [w] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Header.encode = function encode(m, w) {
                        if (!w)
                            w = $Writer.create();
                        if (m.messageFrame != null && m.hasOwnProperty("messageFrame"))
                            $root.plexus.interop.transport.protocol.MessageFrameHeader.encode(m.messageFrame, w.uint32(10).fork()).ldelim();
                        if (m.channelOpen != null && m.hasOwnProperty("channelOpen"))
                            $root.plexus.interop.transport.protocol.ChannelOpenHeader.encode(m.channelOpen, w.uint32(18).fork()).ldelim();
                        if (m.channelClose != null && m.hasOwnProperty("channelClose"))
                            $root.plexus.interop.transport.protocol.ChannelCloseHeader.encode(m.channelClose, w.uint32(26).fork()).ldelim();
                        if (m.open != null && m.hasOwnProperty("open"))
                            $root.plexus.interop.transport.protocol.ConnectionOpenHeader.encode(m.open, w.uint32(34).fork()).ldelim();
                        if (m.close != null && m.hasOwnProperty("close"))
                            $root.plexus.interop.transport.protocol.ConnectionCloseHeader.encode(m.close, w.uint32(42).fork()).ldelim();
                        return w;
                    };

                    /**
                     * Decodes a Header message from the specified reader or buffer.
                     * @function decode
                     * @memberof plexus.interop.transport.protocol.Header
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                     * @param {number} [l] Message length if known beforehand
                     * @returns {plexus.interop.transport.protocol.Header} Header
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Header.decode = function decode(r, l) {
                        if (!(r instanceof $Reader))
                            r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.interop.transport.protocol.Header();
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                            case 1:
                                m.messageFrame = $root.plexus.interop.transport.protocol.MessageFrameHeader.decode(r, r.uint32());
                                break;
                            case 2:
                                m.channelOpen = $root.plexus.interop.transport.protocol.ChannelOpenHeader.decode(r, r.uint32());
                                break;
                            case 3:
                                m.channelClose = $root.plexus.interop.transport.protocol.ChannelCloseHeader.decode(r, r.uint32());
                                break;
                            case 4:
                                m.open = $root.plexus.interop.transport.protocol.ConnectionOpenHeader.decode(r, r.uint32());
                                break;
                            case 5:
                                m.close = $root.plexus.interop.transport.protocol.ConnectionCloseHeader.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(t & 7);
                                break;
                            }
                        }
                        return m;
                    };

                    /**
                     * Creates a Header message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof plexus.interop.transport.protocol.Header
                     * @static
                     * @param {Object.<string,*>} d Plain object
                     * @returns {plexus.interop.transport.protocol.Header} Header
                     */
                    Header.fromObject = function fromObject(d) {
                        if (d instanceof $root.plexus.interop.transport.protocol.Header)
                            return d;
                        var m = new $root.plexus.interop.transport.protocol.Header();
                        if (d.messageFrame != null) {
                            if (typeof d.messageFrame !== "object")
                                throw TypeError(".plexus.interop.transport.protocol.Header.messageFrame: object expected");
                            m.messageFrame = $root.plexus.interop.transport.protocol.MessageFrameHeader.fromObject(d.messageFrame);
                        }
                        if (d.channelOpen != null) {
                            if (typeof d.channelOpen !== "object")
                                throw TypeError(".plexus.interop.transport.protocol.Header.channelOpen: object expected");
                            m.channelOpen = $root.plexus.interop.transport.protocol.ChannelOpenHeader.fromObject(d.channelOpen);
                        }
                        if (d.channelClose != null) {
                            if (typeof d.channelClose !== "object")
                                throw TypeError(".plexus.interop.transport.protocol.Header.channelClose: object expected");
                            m.channelClose = $root.plexus.interop.transport.protocol.ChannelCloseHeader.fromObject(d.channelClose);
                        }
                        if (d.open != null) {
                            if (typeof d.open !== "object")
                                throw TypeError(".plexus.interop.transport.protocol.Header.open: object expected");
                            m.open = $root.plexus.interop.transport.protocol.ConnectionOpenHeader.fromObject(d.open);
                        }
                        if (d.close != null) {
                            if (typeof d.close !== "object")
                                throw TypeError(".plexus.interop.transport.protocol.Header.close: object expected");
                            m.close = $root.plexus.interop.transport.protocol.ConnectionCloseHeader.fromObject(d.close);
                        }
                        return m;
                    };

                    /**
                     * Creates a plain object from a Header message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof plexus.interop.transport.protocol.Header
                     * @static
                     * @param {plexus.interop.transport.protocol.Header} m Header
                     * @param {$protobuf.IConversionOptions} [o] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Header.toObject = function toObject(m, o) {
                        if (!o)
                            o = {};
                        var d = {};
                        if (m.messageFrame != null && m.hasOwnProperty("messageFrame")) {
                            d.messageFrame = $root.plexus.interop.transport.protocol.MessageFrameHeader.toObject(m.messageFrame, o);
                            if (o.oneofs)
                                d.content = "messageFrame";
                        }
                        if (m.channelOpen != null && m.hasOwnProperty("channelOpen")) {
                            d.channelOpen = $root.plexus.interop.transport.protocol.ChannelOpenHeader.toObject(m.channelOpen, o);
                            if (o.oneofs)
                                d.content = "channelOpen";
                        }
                        if (m.channelClose != null && m.hasOwnProperty("channelClose")) {
                            d.channelClose = $root.plexus.interop.transport.protocol.ChannelCloseHeader.toObject(m.channelClose, o);
                            if (o.oneofs)
                                d.content = "channelClose";
                        }
                        if (m.open != null && m.hasOwnProperty("open")) {
                            d.open = $root.plexus.interop.transport.protocol.ConnectionOpenHeader.toObject(m.open, o);
                            if (o.oneofs)
                                d.content = "open";
                        }
                        if (m.close != null && m.hasOwnProperty("close")) {
                            d.close = $root.plexus.interop.transport.protocol.ConnectionCloseHeader.toObject(m.close, o);
                            if (o.oneofs)
                                d.content = "close";
                        }
                        return d;
                    };

                    /**
                     * Converts this Header to JSON.
                     * @function toJSON
                     * @memberof plexus.interop.transport.protocol.Header
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Header.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Header;
                })();

                return protocol;
            })();

            return transport;
        })();

        return interop;
    })();

    plexus.UniqueId = (function() {

        /**
         * Properties of an UniqueId.
         * @memberof plexus
         * @interface IUniqueId
         * @property {Long} [lo] UniqueId lo
         * @property {Long} [hi] UniqueId hi
         */

        /**
         * Constructs a new UniqueId.
         * @memberof plexus
         * @classdesc Represents an UniqueId.
         * @constructor
         * @param {plexus.IUniqueId=} [p] Properties to set
         */
        function UniqueId(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * UniqueId lo.
         * @member {Long}lo
         * @memberof plexus.UniqueId
         * @instance
         */
        UniqueId.prototype.lo = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UniqueId hi.
         * @member {Long}hi
         * @memberof plexus.UniqueId
         * @instance
         */
        UniqueId.prototype.hi = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Encodes the specified UniqueId message. Does not implicitly {@link plexus.UniqueId.verify|verify} messages.
         * @function encode
         * @memberof plexus.UniqueId
         * @static
         * @param {plexus.IUniqueId} m UniqueId message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UniqueId.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.lo != null && m.hasOwnProperty("lo"))
                w.uint32(9).fixed64(m.lo);
            if (m.hi != null && m.hasOwnProperty("hi"))
                w.uint32(17).fixed64(m.hi);
            return w;
        };

        /**
         * Decodes an UniqueId message from the specified reader or buffer.
         * @function decode
         * @memberof plexus.UniqueId
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {plexus.UniqueId} UniqueId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UniqueId.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.UniqueId();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.lo = r.fixed64();
                    break;
                case 2:
                    m.hi = r.fixed64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Creates an UniqueId message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof plexus.UniqueId
         * @static
         * @param {Object.<string,*>} d Plain object
         * @returns {plexus.UniqueId} UniqueId
         */
        UniqueId.fromObject = function fromObject(d) {
            if (d instanceof $root.plexus.UniqueId)
                return d;
            var m = new $root.plexus.UniqueId();
            if (d.lo != null) {
                if ($util.Long)
                    (m.lo = $util.Long.fromValue(d.lo)).unsigned = false;
                else if (typeof d.lo === "string")
                    m.lo = parseInt(d.lo, 10);
                else if (typeof d.lo === "number")
                    m.lo = d.lo;
                else if (typeof d.lo === "object")
                    m.lo = new $util.LongBits(d.lo.low >>> 0, d.lo.high >>> 0).toNumber();
            }
            if (d.hi != null) {
                if ($util.Long)
                    (m.hi = $util.Long.fromValue(d.hi)).unsigned = false;
                else if (typeof d.hi === "string")
                    m.hi = parseInt(d.hi, 10);
                else if (typeof d.hi === "number")
                    m.hi = d.hi;
                else if (typeof d.hi === "object")
                    m.hi = new $util.LongBits(d.hi.low >>> 0, d.hi.high >>> 0).toNumber();
            }
            return m;
        };

        /**
         * Creates a plain object from an UniqueId message. Also converts values to other types if specified.
         * @function toObject
         * @memberof plexus.UniqueId
         * @static
         * @param {plexus.UniqueId} m UniqueId
         * @param {$protobuf.IConversionOptions} [o] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UniqueId.toObject = function toObject(m, o) {
            if (!o)
                o = {};
            var d = {};
            if (o.defaults) {
                if ($util.Long) {
                    var n = new $util.Long(0, 0, false);
                    d.lo = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
                } else
                    d.lo = o.longs === String ? "0" : 0;
                if ($util.Long) {
                    var n = new $util.Long(0, 0, false);
                    d.hi = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
                } else
                    d.hi = o.longs === String ? "0" : 0;
            }
            if (m.lo != null && m.hasOwnProperty("lo")) {
                if (typeof m.lo === "number")
                    d.lo = o.longs === String ? String(m.lo) : m.lo;
                else
                    d.lo = o.longs === String ? $util.Long.prototype.toString.call(m.lo) : o.longs === Number ? new $util.LongBits(m.lo.low >>> 0, m.lo.high >>> 0).toNumber() : m.lo;
            }
            if (m.hi != null && m.hasOwnProperty("hi")) {
                if (typeof m.hi === "number")
                    d.hi = o.longs === String ? String(m.hi) : m.hi;
                else
                    d.hi = o.longs === String ? $util.Long.prototype.toString.call(m.hi) : o.longs === Number ? new $util.LongBits(m.hi.low >>> 0, m.hi.high >>> 0).toNumber() : m.hi;
            }
            return d;
        };

        /**
         * Converts this UniqueId to JSON.
         * @function toJSON
         * @memberof plexus.UniqueId
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UniqueId.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UniqueId;
    })();

    plexus.Error = (function() {

        /**
         * Properties of an Error.
         * @memberof plexus
         * @interface IError
         * @property {string} [message] Error message
         * @property {string} [details] Error details
         */

        /**
         * Constructs a new Error.
         * @memberof plexus
         * @classdesc Represents an Error.
         * @constructor
         * @param {plexus.IError=} [p] Properties to set
         */
        function Error(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Error message.
         * @member {string}message
         * @memberof plexus.Error
         * @instance
         */
        Error.prototype.message = "";

        /**
         * Error details.
         * @member {string}details
         * @memberof plexus.Error
         * @instance
         */
        Error.prototype.details = "";

        /**
         * Encodes the specified Error message. Does not implicitly {@link plexus.Error.verify|verify} messages.
         * @function encode
         * @memberof plexus.Error
         * @static
         * @param {plexus.IError} m Error message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Error.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.message != null && m.hasOwnProperty("message"))
                w.uint32(10).string(m.message);
            if (m.details != null && m.hasOwnProperty("details"))
                w.uint32(18).string(m.details);
            return w;
        };

        /**
         * Decodes an Error message from the specified reader or buffer.
         * @function decode
         * @memberof plexus.Error
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {plexus.Error} Error
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Error.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.Error();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.message = r.string();
                    break;
                case 2:
                    m.details = r.string();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Creates an Error message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof plexus.Error
         * @static
         * @param {Object.<string,*>} d Plain object
         * @returns {plexus.Error} Error
         */
        Error.fromObject = function fromObject(d) {
            if (d instanceof $root.plexus.Error)
                return d;
            var m = new $root.plexus.Error();
            if (d.message != null) {
                m.message = String(d.message);
            }
            if (d.details != null) {
                m.details = String(d.details);
            }
            return m;
        };

        /**
         * Creates a plain object from an Error message. Also converts values to other types if specified.
         * @function toObject
         * @memberof plexus.Error
         * @static
         * @param {plexus.Error} m Error
         * @param {$protobuf.IConversionOptions} [o] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Error.toObject = function toObject(m, o) {
            if (!o)
                o = {};
            var d = {};
            if (o.defaults) {
                d.message = "";
                d.details = "";
            }
            if (m.message != null && m.hasOwnProperty("message")) {
                d.message = m.message;
            }
            if (m.details != null && m.hasOwnProperty("details")) {
                d.details = m.details;
            }
            return d;
        };

        /**
         * Converts this Error to JSON.
         * @function toJSON
         * @memberof plexus.Error
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Error.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Error;
    })();

    plexus.Completion = (function() {

        /**
         * Properties of a Completion.
         * @memberof plexus
         * @interface ICompletion
         * @property {plexus.Completion.Status} [status] Completion status
         * @property {plexus.IError} [error] Completion error
         */

        /**
         * Constructs a new Completion.
         * @memberof plexus
         * @classdesc Represents a Completion.
         * @constructor
         * @param {plexus.ICompletion=} [p] Properties to set
         */
        function Completion(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Completion status.
         * @member {plexus.Completion.Status}status
         * @memberof plexus.Completion
         * @instance
         */
        Completion.prototype.status = 0;

        /**
         * Completion error.
         * @member {(plexus.IError|null|undefined)}error
         * @memberof plexus.Completion
         * @instance
         */
        Completion.prototype.error = null;

        /**
         * Encodes the specified Completion message. Does not implicitly {@link plexus.Completion.verify|verify} messages.
         * @function encode
         * @memberof plexus.Completion
         * @static
         * @param {plexus.ICompletion} m Completion message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Completion.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.status != null && m.hasOwnProperty("status"))
                w.uint32(8).int32(m.status);
            if (m.error != null && m.hasOwnProperty("error"))
                $root.plexus.Error.encode(m.error, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a Completion message from the specified reader or buffer.
         * @function decode
         * @memberof plexus.Completion
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {plexus.Completion} Completion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Completion.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.plexus.Completion();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.status = r.int32();
                    break;
                case 2:
                    m.error = $root.plexus.Error.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Creates a Completion message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof plexus.Completion
         * @static
         * @param {Object.<string,*>} d Plain object
         * @returns {plexus.Completion} Completion
         */
        Completion.fromObject = function fromObject(d) {
            if (d instanceof $root.plexus.Completion)
                return d;
            var m = new $root.plexus.Completion();
            switch (d.status) {
            case "Completed":
            case 0:
                m.status = 0;
                break;
            case "Canceled":
            case 1:
                m.status = 1;
                break;
            case "Failed":
            case 2:
                m.status = 2;
                break;
            }
            if (d.error != null) {
                if (typeof d.error !== "object")
                    throw TypeError(".plexus.Completion.error: object expected");
                m.error = $root.plexus.Error.fromObject(d.error);
            }
            return m;
        };

        /**
         * Creates a plain object from a Completion message. Also converts values to other types if specified.
         * @function toObject
         * @memberof plexus.Completion
         * @static
         * @param {plexus.Completion} m Completion
         * @param {$protobuf.IConversionOptions} [o] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Completion.toObject = function toObject(m, o) {
            if (!o)
                o = {};
            var d = {};
            if (o.defaults) {
                d.status = o.enums === String ? "Completed" : 0;
                d.error = null;
            }
            if (m.status != null && m.hasOwnProperty("status")) {
                d.status = o.enums === String ? $root.plexus.Completion.Status[m.status] : m.status;
            }
            if (m.error != null && m.hasOwnProperty("error")) {
                d.error = $root.plexus.Error.toObject(m.error, o);
            }
            return d;
        };

        /**
         * Converts this Completion to JSON.
         * @function toJSON
         * @memberof plexus.Completion
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Completion.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Status enum.
         * @enum {string}
         * @property {number} Completed=0 Completed value
         * @property {number} Canceled=1 Canceled value
         * @property {number} Failed=2 Failed value
         */
        Completion.Status = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Completed"] = 0;
            values[valuesById[1] = "Canceled"] = 1;
            values[valuesById[2] = "Failed"] = 2;
            return values;
        })();

        return Completion;
    })();

    return plexus;
})();

module.exports = $root;

},{"protobufjs/minimal":85}],305:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Long = require("long");
var protobufjs_1 = require("protobufjs");
// make sure protobufjs uses Long implementation, to keep guids compatible with .Net broker
// https://github.com/dcodeIO/protobuf.js/issues/730
protobufjs_1.util.Long = Long;
protobufjs_1.configure();
var internal_transport_protocol_1 = require("./gen/internal-transport-protocol");
exports.transportProtocol = internal_transport_protocol_1.plexus;
var internal_client_protocol_1 = require("./gen/internal-client-protocol");
exports.clientProtocol = internal_client_protocol_1.plexus;
tslib_1.__exportStar(require("./util/ClientProtocolHelper"), exports);
tslib_1.__exportStar(require("./dto"), exports);
;

},{"./dto":302,"./gen/internal-client-protocol":303,"./gen/internal-transport-protocol":304,"./util/ClientProtocolHelper":306,"long":82,"protobufjs":83,"tslib":180}],306:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _1 = require("../.");
var UniqueId_1 = require("../dto/UniqueId");
var Long = require("long");
var common_1 = require("@plexus-interop/common");
var protocol = _1.clientProtocol.interop.protocol;
var ClientProtocolHelper = /** @class */ (function () {
    function ClientProtocolHelper() {
    }
    ClientProtocolHelper.isSuccessCompletion = function (completion) {
        return _1.ClientProtocolUtils.isSuccessCompletion(completion);
    };
    ClientProtocolHelper.invocationInfoToConsumedMethodReference = function (invocationInfo) {
        return {
            methodId: invocationInfo.methodId,
            consumedService: {
                serviceId: invocationInfo.serviceId,
                serviceAlias: invocationInfo.serviceAlias
            }
        };
    };
    ClientProtocolHelper.invocationStartRequestPayload = function (invocationInfo) {
        return encodeClientToBrokerEnvelop({
            invocationStartRequest: {
                consumedMethod: ClientProtocolHelper.invocationInfoToConsumedMethodReference(invocationInfo)
            }
        });
    };
    ClientProtocolHelper.discoveredInvocationStartRequestPayload = function (providerMethodReference) {
        return encodeClientToBrokerEnvelop({
            invocationStartRequest: {
                providedMethod: providerMethodReference
            }
        });
    };
    ClientProtocolHelper.connectRequestPayload = function (connectRequest) {
        return common_1.Arrays.toArrayBuffer(protocol.ConnectRequest.encode(connectRequest).finish());
    };
    ClientProtocolHelper.discoveryServiceRequestPayload = function (serviceDiscoveryRequest) {
        return encodeClientToBrokerEnvelop({
            serviceDiscoveryRequest: serviceDiscoveryRequest
        });
    };
    ClientProtocolHelper.discoveryMethodRequestPayload = function (methodDiscoveryRequest) {
        return encodeClientToBrokerEnvelop({
            methodDiscoveryRequest: methodDiscoveryRequest
        });
    };
    ClientProtocolHelper.discoveryMethodResponsePayload = function (header) {
        return common_1.Arrays.toArrayBuffer(protocol.MethodDiscoveryResponse.encode(header).finish());
    };
    ClientProtocolHelper.discoveryResponsePayload = function (request) {
        return common_1.Arrays.toArrayBuffer(protocol.ServiceDiscoveryResponse.encode(request).finish());
    };
    ClientProtocolHelper.decodeConnectRequest = function (data) {
        var envelop = _1.clientProtocol.interop.protocol.ConnectRequest.decode(new Uint8Array(data));
        return _1.clientProtocol.interop.protocol.ConnectRequest.toObject(envelop);
    };
    ClientProtocolHelper.decodeMethodDiscoveryResponse = function (data) {
        var envelop = _1.clientProtocol.interop.protocol.MethodDiscoveryResponse.decode(new Uint8Array(data));
        return _1.clientProtocol.interop.protocol.MethodDiscoveryResponse.toObject(envelop);
    };
    ClientProtocolHelper.decodeMethodDiscoveryRequest = function (data) {
        var envelop = _1.clientProtocol.interop.protocol.MethodDiscoveryResponse.decode(new Uint8Array(data));
        return _1.clientProtocol.interop.protocol.MethodDiscoveryResponse.toObject(envelop);
    };
    ClientProtocolHelper.decodeServiceDiscoveryResponse = function (data) {
        var envelop = _1.clientProtocol.interop.protocol.ServiceDiscoveryResponse.decode(new Uint8Array(data));
        return _1.clientProtocol.interop.protocol.ServiceDiscoveryResponse.toObject(envelop);
    };
    ClientProtocolHelper.decodeServiceDiscoveryRequest = function (data) {
        var clientToBroker = ClientProtocolHelper.decodeClientToBrokerRequest(data);
        return clientToBroker.serviceDiscoveryRequest;
    };
    ClientProtocolHelper.decodeClientToBrokerRequest = function (data) {
        var envelop = _1.clientProtocol.interop.protocol.ClientToBrokerRequestEnvelope.decode(new Uint8Array(data));
        return _1.clientProtocol.interop.protocol.ClientToBrokerRequestEnvelope.toObject(envelop);
    };
    ClientProtocolHelper.decodeConnectResponse = function (data) {
        var envelop = _1.clientProtocol.interop.protocol.ConnectResponse.decode(new Uint8Array(data));
        return _1.clientProtocol.interop.protocol.ConnectResponse.toObject(envelop);
    };
    ClientProtocolHelper.decodeBrokerEnvelop = function (data) {
        var envelop = _1.clientProtocol.interop.protocol.BrokerToClientRequestEnvelope.decode(new Uint8Array(data));
        return _1.clientProtocol.interop.protocol.BrokerToClientRequestEnvelope.toObject(envelop);
    };
    ClientProtocolHelper.decodeInvocationStartRequest = function (data) {
        var envelop = _1.clientProtocol.interop.protocol.ClientToBrokerRequestEnvelope.decode(new Uint8Array(data));
        var clientToBroker = _1.clientProtocol.interop.protocol.ClientToBrokerRequestEnvelope.toObject(envelop);
        return clientToBroker.invocationStartRequest;
    };
    ClientProtocolHelper.decodeInvocationStarting = function (data) {
        var envelop = _1.clientProtocol.interop.protocol.InvocationStarting.decode(new Uint8Array(data));
        return _1.clientProtocol.interop.protocol.InvocationStarting.toObject(envelop);
    };
    ClientProtocolHelper.decodeInvocationStarted = function (data) {
        var envelop = _1.clientProtocol.interop.protocol.InvocationStarted.decode(new Uint8Array(data));
        return _1.clientProtocol.interop.protocol.InvocationStarted.toObject(envelop);
    };
    ClientProtocolHelper.connectResponsePayload = function (connectResponse) {
        return common_1.Arrays.toArrayBuffer(protocol.ConnectResponse.encode(connectResponse).finish());
    };
    ClientProtocolHelper.invocationRequestedPayload = function (invocationStartRequested) {
        return encodeBrokerToClientEnvelop({
            invocationStartRequested: invocationStartRequested
        });
    };
    ClientProtocolHelper.messageHeaderPayload = function (message) {
        return encodeInvocationEnvelop({
            message: message
        });
    };
    ClientProtocolHelper.messageReceivedPayload = function (confirmation) {
        return encodeInvocationEnvelop({
            confirmation: confirmation
        });
    };
    ClientProtocolHelper.sendCompletionPayload = function (sendCompletion) {
        return encodeInvocationEnvelop({
            sendCompletion: sendCompletion
        });
    };
    ClientProtocolHelper.invocationStartedMessagePayload = function (header) {
        return common_1.Arrays.toArrayBuffer(protocol.InvocationStarted.encode(header).finish());
    };
    ClientProtocolHelper.invocationStartingMessagePayload = function (header) {
        return common_1.Arrays.toArrayBuffer(protocol.InvocationStarting.encode(header).finish());
    };
    ClientProtocolHelper.toInvocationInfo = function (header) {
        return {
            methodId: header.methodId,
            serviceId: header.serviceId,
            serviceAlias: header.serviceAlias,
            consumerApplicationId: header.consumerApplicationId,
            consumerConnectionId: UniqueId_1.UniqueId.fromProperties(header.consumerConnectionId)
        };
    };
    ClientProtocolHelper.decodeInvocationEnvelop = function (data) {
        var envelop = _1.clientProtocol.interop.protocol.InvocationMessageEnvelope.decode(new Uint8Array(data));
        return _1.clientProtocol.interop.protocol.InvocationMessageEnvelope.toObject(envelop);
    };
    ClientProtocolHelper.longToNumber = function (value) {
        return (value instanceof Long) ? value.toNumber() : value;
    };
    return ClientProtocolHelper;
}());
exports.ClientProtocolHelper = ClientProtocolHelper;
function encodeBrokerToClientEnvelop(header) {
    return common_1.Arrays.toArrayBuffer(protocol.BrokerToClientRequestEnvelope.encode(header).finish());
}
function encodeClientToBrokerEnvelop(header) {
    return common_1.Arrays.toArrayBuffer(protocol.ClientToBrokerRequestEnvelope.encode(header).finish());
}
function encodeInvocationEnvelop(header) {
    return common_1.Arrays.toArrayBuffer(protocol.InvocationMessageEnvelope.encode(header).finish());
}

},{"../.":305,"../dto/UniqueId":301,"@plexus-interop/common":243,"long":82}],307:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Observable_1 = require("rxjs/Observable");
require("rxjs/add/observable/throw");
require("superagent");
var request = require("superagent");
var common_1 = require("@plexus-interop/common");
var HttpDataLoader = /** @class */ (function () {
    function HttpDataLoader() {
        this.log = common_1.LoggerFactory.getLogger('HttpDataLoader');
    }
    HttpDataLoader.prototype.fetchData = function (url) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.log.trace("Fetching data from [" + url + "]");
                        return [4 /*yield*/, request.get(url).withCredentials()];
                    case 1:
                        response = _a.sent();
                        this.log.trace("Received response with " + response.status + " status");
                        return [2 /*return*/, response.text];
                }
            });
        });
    };
    HttpDataLoader.prototype.fetchWithInterval = function (url, interval) {
        var _this = this;
        if (interval <= 0) {
            return Observable_1.Observable.throw(new Error('Interval must be positive'));
        }
        this.log.trace("Starting to fetch data from [" + url + "] using " + interval + " interval");
        return new Observable_1.Observable(function (observer) {
            var intervalId = setInterval(function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                var response, e_1;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 2, , 3]);
                            return [4 /*yield*/, this.fetchData(url)];
                        case 1:
                            response = _a.sent();
                            observer.next(response);
                            return [3 /*break*/, 3];
                        case 2:
                            e_1 = _a.sent();
                            this.log.error("Error received while fetching data from " + url, e_1);
                            observer.error(e_1);
                            clearInterval(intervalId);
                            return [3 /*break*/, 3];
                        case 3: return [2 /*return*/, function () { return clearInterval(intervalId); }];
                    }
                });
            }); }, interval);
        });
    };
    return HttpDataLoader;
}());
exports.HttpDataLoader = HttpDataLoader;
},{"@plexus-interop/common":243,"rxjs/Observable":121,"rxjs/add/observable/throw":131,"superagent":175,"tslib":180}],308:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
tslib_1.__exportStar(require("./HttpDataLoader"), exports);
},{"./HttpDataLoader":307,"tslib":180}],309:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
tslib_1.__exportStar(require("./http"), exports);
tslib_1.__exportStar(require("./ws"), exports);
},{"./http":308,"./ws":311,"tslib":180}],310:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var webSocket_1 = require("rxjs/observable/dom/webSocket");
var WebSocketDataProvider = /** @class */ (function () {
    function WebSocketDataProvider(wsCtor) {
        if (wsCtor === void 0) { wsCtor = WebSocket; }
        this.wsCtor = wsCtor;
    }
    WebSocketDataProvider.prototype.getData = function (url) {
        return webSocket_1.webSocket(this.config(url));
    };
    WebSocketDataProvider.prototype.getSingleMessage = function (url) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var resolved = false;
            var subscription = _this.getData(url).subscribe({
                next: function (message) {
                    resolved = true;
                    resolve(message);
                },
                error: function (e) { return reject(e); },
                complete: function () {
                    if (!resolved) {
                        reject(new Error('No data received'));
                    }
                }
            });
        });
    };
    WebSocketDataProvider.prototype.config = function (url) {
        return {
            url: url,
            WebSocketCtor: this.wsCtor,
            // override default behavior, which invokes JSON.parse
            resultSelector: function (e) { return e.data; }
        };
    };
    return WebSocketDataProvider;
}());
exports.WebSocketDataProvider = WebSocketDataProvider;
},{"rxjs/observable/dom/webSocket":139}],311:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
tslib_1.__exportStar(require("./WebSocketDataProvider"), exports);
},{"./WebSocketDataProvider":310,"tslib":180}],312:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Defaults = /** @class */ (function () {
    function Defaults() {
    }
    Defaults.OPERATION_TIMEOUT = 60000;
    Defaults.STATUS_CHECK_INTERVAL = 0;
    Defaults.DEFAULT_BUFFER_SIZE = 10240;
    Defaults.DEFAULT_FRAME_SIZE = 60000;
    return Defaults;
}());
exports.Defaults = Defaults;

},{}],313:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DelegateChannelObserver = /** @class */ (function () {
    function DelegateChannelObserver(baseObserver, subscriptionHandler, startFailedHandler) {
        if (startFailedHandler === void 0) { startFailedHandler = function () { }; }
        this.baseObserver = baseObserver;
        this.subscriptionHandler = subscriptionHandler;
        this.startFailedHandler = startFailedHandler;
    }
    DelegateChannelObserver.prototype.started = function (subscription) {
        this.subscriptionHandler(subscription);
    };
    DelegateChannelObserver.prototype.next = function (value) {
        this.baseObserver.next(value);
    };
    DelegateChannelObserver.prototype.error = function (err) {
        this.baseObserver.error(err);
    };
    DelegateChannelObserver.prototype.complete = function () {
        this.baseObserver.complete();
    };
    DelegateChannelObserver.prototype.startFailed = function (error) {
        this.startFailedHandler(error);
    };
    return DelegateChannelObserver;
}());
exports.DelegateChannelObserver = DelegateChannelObserver;

},{}],314:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./Defaults"), exports);
tslib_1.__exportStar(require("./DelegateChannelObserver"), exports);
tslib_1.__exportStar(require("./Defaults"), exports);

},{"./Defaults":312,"./DelegateChannelObserver":313,"tslib":180}],315:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
tslib_1.__exportStar(require("./transport"), exports);
tslib_1.__exportStar(require("./common"), exports);

},{"./common":314,"./transport":335,"tslib":180}],316:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var common_1 = require("@plexus-interop/common");
var _1 = require("../.");
var InMemoryFramedTransport_1 = require("./InMemoryFramedTransport");
/**
 * Creates pair of coupled in memory connections for each Client's connect request
 */
var InMemoryConnectionFactory = /** @class */ (function () {
    function InMemoryConnectionFactory() {
        this.log = common_1.LoggerFactory.getLogger('InMemoryConnectionFactory');
        this.serverConnectionsObserver = new common_1.BufferedObserver(_1.Defaults.DEFAULT_BUFFER_SIZE, this.log);
    }
    InMemoryConnectionFactory.prototype.connect = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var client;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.connectBoth()];
                    case 1:
                        client = (_a.sent())[0];
                        return [2 /*return*/, client];
                }
            });
        });
    };
    InMemoryConnectionFactory.prototype.connectBoth = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var clientInObserver, serverInObserver, serverTransportConnection, clientTransportConnection;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        clientInObserver = new common_1.BufferedObserver(_1.Defaults.DEFAULT_BUFFER_SIZE, this.log);
                        serverInObserver = new common_1.BufferedObserver(_1.Defaults.DEFAULT_BUFFER_SIZE, this.log);
                        serverTransportConnection = new _1.FramedTransportConnection(new InMemoryFramedTransport_1.InMemoryFramedTransport(serverInObserver, clientInObserver));
                        clientTransportConnection = new _1.FramedTransportConnection(new InMemoryFramedTransport_1.InMemoryFramedTransport(clientInObserver, serverInObserver));
                        if (this.log.isDebugEnabled()) {
                            this.log.debug("Created pair of connections: \n                Client [" + clientTransportConnection.uuid().toString() + "] \n                Server [" + serverTransportConnection.uuid().toString() + "]");
                        }
                        return [4 /*yield*/, clientTransportConnection.connect()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, serverTransportConnection.acceptingConnection()];
                    case 2:
                        _a.sent();
                        this.serverConnectionsObserver.next(serverTransportConnection);
                        return [2 /*return*/, [clientTransportConnection, serverTransportConnection]];
                }
            });
        });
    };
    InMemoryConnectionFactory.prototype.acceptConnections = function (connectionsObserver) {
        this.log.debug('Received accept connections request');
        this.serverConnectionsObserver.setObserver(connectionsObserver);
        return new common_1.AnonymousSubscription();
    };
    return InMemoryConnectionFactory;
}());
exports.InMemoryConnectionFactory = InMemoryConnectionFactory;

},{"../.":315,"./InMemoryFramedTransport":317,"@plexus-interop/common":243,"tslib":180}],317:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _1 = require("../.");
var common_1 = require("@plexus-interop/common");
var InMemoryFramedTransport = /** @class */ (function () {
    function InMemoryFramedTransport(inObserver, outObserver) {
        this.inObserver = inObserver;
        this.outObserver = outObserver;
        this.id = _1.UniqueId.generateNew();
        this.cancellationToken = new common_1.ReadWriteCancellationToken();
        this.log = common_1.LoggerFactory.getLogger("InMemoryFramedTransport [" + this.id.toString() + "]");
        this.log.trace('Created');
    }
    InMemoryFramedTransport.prototype.connected = function () {
        return !this.cancellationToken.isCancelled();
    };
    InMemoryFramedTransport.prototype.disconnect = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                this.log.trace('Received disconnect');
                this.cancellationToken.cancel();
                this.inObserver.complete();
                return [2 /*return*/];
            });
        });
    };
    InMemoryFramedTransport.prototype.uuid = function () {
        return this.id;
    };
    InMemoryFramedTransport.prototype.getMaxFrameSize = function () {
        return _1.Defaults.DEFAULT_FRAME_SIZE;
    };
    InMemoryFramedTransport.prototype.writeFrame = function (frame) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                this.cancellationToken.throwIfCanceled();
                if (this.log.isTraceEnabled()) {
                    if (frame.isDataFrame) {
                        this.log.trace("Received data frame");
                    }
                    else {
                        this.log.trace("Received header frame");
                    }
                }
                this.outObserver.next(frame);
                return [2 /*return*/];
            });
        });
    };
    InMemoryFramedTransport.prototype.open = function (observer) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                this.log.trace('Transport opened');
                this.inObserver.setObserver(observer);
                return [2 /*return*/];
            });
        });
    };
    return InMemoryFramedTransport;
}());
exports.InMemoryFramedTransport = InMemoryFramedTransport;

},{"../.":315,"@plexus-interop/common":243,"tslib":180}],318:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var common_1 = require("@plexus-interop/common");
var Defaults_1 = require("../../common/Defaults");
/**
 * Collects all read events until client opened connection
 */
var BufferedReadFramedTransport = /** @class */ (function () {
    function BufferedReadFramedTransport(log) {
        this.log = log;
        this.framesObserver = null;
        this.completed = false;
        this.inBuffer = new common_1.LimitedBufferQueue(Defaults_1.Defaults.DEFAULT_BUFFER_SIZE);
    }
    BufferedReadFramedTransport.prototype.open = function (framesObserver) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                this.log.trace('Opening transport');
                if (this.framesObserver) {
                    throw new Error('Already opened');
                }
                this.framesObserver = framesObserver;
                while (!this.inBuffer.isEmpty()) {
                    this.framesObserver.next(this.inBuffer.dequeue());
                }
                if (this.receivedError) {
                    this.framesObserver.error(this.receivedError);
                }
                else if (this.completed) {
                    this.framesObserver.complete();
                }
                return [2 /*return*/];
            });
        });
    };
    BufferedReadFramedTransport.prototype.clear = function () {
        this.inBuffer.clear();
    };
    BufferedReadFramedTransport.prototype.next = function (frame) {
        /* istanbul ignore if */
        if (this.log.isTraceEnabled()) {
            this.log.trace("Received frame");
        }
        if (this.framesObserver) {
            this.framesObserver.next(frame);
        }
        else {
            this.inBuffer.enqueue(frame);
        }
    };
    BufferedReadFramedTransport.prototype.error = function (transportError) {
        this.log.debug('Received error', transportError);
        if (this.framesObserver) {
            this.framesObserver.error(transportError);
        }
        else {
            this.receivedError = transportError;
        }
    };
    BufferedReadFramedTransport.prototype.complete = function () {
        this.log.debug('Receive complete message');
        if (this.framesObserver) {
            this.framesObserver.complete();
        }
        else {
            this.completed = true;
        }
    };
    return BufferedReadFramedTransport;
}());
exports.BufferedReadFramedTransport = BufferedReadFramedTransport;

},{"../../common/Defaults":312,"@plexus-interop/common":243,"tslib":180}],319:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var BufferedReadFramedTransport_1 = require("./BufferedReadFramedTransport");
/**
 * Collects all read events until client opened connection, delegates all write events to source
 */
var BufferedTransportProxy = /** @class */ (function (_super) {
    tslib_1.__extends(BufferedTransportProxy, _super);
    function BufferedTransportProxy(innerTransport, writeCancellationToken, log) {
        var _this = _super.call(this, log) || this;
        _this.innerTransport = innerTransport;
        _this.writeCancellationToken = writeCancellationToken;
        return _this;
    }
    BufferedTransportProxy.prototype.uuid = function () {
        return this.innerTransport.uuid();
    };
    BufferedTransportProxy.prototype.clear = function () {
        this.inBuffer.clear();
    };
    BufferedTransportProxy.prototype.getMaxFrameSize = function () {
        return this.innerTransport.getMaxFrameSize();
    };
    BufferedTransportProxy.prototype.writeFrame = function (frame) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                this.writeCancellationToken.throwIfCanceled();
                return [2 /*return*/, this.innerTransport.writeFrame(frame)];
            });
        });
    };
    return BufferedTransportProxy;
}(BufferedReadFramedTransport_1.BufferedReadFramedTransport));
exports.BufferedTransportProxy = BufferedTransportProxy;

},{"./BufferedReadFramedTransport":318,"tslib":180}],320:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var model_1 = require("./model");
var common_1 = require("@plexus-interop/common");
var Subscription_1 = require("rxjs/Subscription");
var common_2 = require("@plexus-interop/common");
var protocol_1 = require("@plexus-interop/protocol");
var SafeMessageBuffer_1 = require("./SafeMessageBuffer");
var Defaults_1 = require("../../common/Defaults");
var ChannelState;
(function (ChannelState) {
    ChannelState["CREATED"] = "CREATED";
    ChannelState["OPEN"] = "OPEN";
    ChannelState["CLOSED"] = "CLOSED";
    ChannelState["CLOSE_RECEIVED"] = "CLOSE_RECEIVED";
    ChannelState["CLOSE_REQUESTED"] = "CLOSE_REQUESTED";
})(ChannelState = exports.ChannelState || (exports.ChannelState = {}));
var FramedTransportChannel = /** @class */ (function () {
    function FramedTransportChannel(id, framedTransport, dispose, baseReadToken) {
        var _this = this;
        this.id = id;
        this.framedTransport = framedTransport;
        this.dispose = dispose;
        this.messageId = 0;
        this.log = common_2.LoggerFactory.getLogger("FramedTransportChannel [" + id.toString() + "]");
        this.writeExecutor = new common_2.SequencedExecutor(this.log);
        this.channelCancellationToken = new common_1.ReadWriteCancellationToken(new common_2.CancellationToken(baseReadToken));
        this.log.debug('Created');
        this.stateMachine = new common_2.StateMaschineBase(ChannelState.CREATED, [
            {
                from: ChannelState.CREATED, to: ChannelState.OPEN
            },
            // client requested to complete channel, waiting for response
            {
                from: ChannelState.OPEN, to: ChannelState.CLOSE_REQUESTED
            },
            // remote side requested to complete channel
            {
                from: ChannelState.OPEN, to: ChannelState.CLOSE_RECEIVED
            },
            // client confirmed channel closure
            {
                from: ChannelState.CLOSE_RECEIVED, to: ChannelState.CLOSED
            },
            // remote confirmed channel closure
            {
                from: ChannelState.CLOSE_REQUESTED, to: ChannelState.CLOSED
            },
            // forced channel closure
            {
                from: ChannelState.OPEN, to: ChannelState.CLOSED, preHandler: function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                    return tslib_1.__generator(this, function (_a) {
                        this.log.warn('Channel forced OPEN -> CLOSED');
                        return [2 /*return*/];
                    });
                }); }
            },
            {
                from: ChannelState.CREATED, to: ChannelState.CLOSED, preHandler: function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                    return tslib_1.__generator(this, function (_a) {
                        this.log.warn('Channel forced CREATED -> CLOSED');
                        return [2 /*return*/];
                    });
                }); }
            }
        ], this.log);
    }
    FramedTransportChannel.prototype.open = function (channelObserver) {
        var _this = this;
        this.log.debug('Opening channel');
        this.stateMachine.throwIfNot(ChannelState.CREATED);
        this.channelObserver = channelObserver;
        var subscription = new Subscription_1.Subscription(function () {
            _this.log.debug('Closing on unsubscribe');
            _this.close();
        });
        this.stateMachine.goAsync(ChannelState.OPEN)
            .then(function () {
            _this.subscribeToMessages(channelObserver);
            channelObserver.started(subscription);
        });
    };
    FramedTransportChannel.prototype.uuid = function () {
        return this.id;
    };
    FramedTransportChannel.prototype.close = function (completion) {
        if (completion === void 0) { completion = new protocol_1.SuccessCompletion(); }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                this.stateMachine.throwIfNot(ChannelState.OPEN, ChannelState.CLOSE_RECEIVED);
                // wait for remote side if required and report result
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        (function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                            return tslib_1.__generator(this, function (_a) {
                                // handler called when remote side also sent its completion
                                this.onCloseHandler = function (summarizedCompletion) {
                                    resolve(summarizedCompletion);
                                };
                                if (this.stateMachine.is(ChannelState.OPEN)) {
                                    // wait for remote side response
                                    this.sendChannelClosedRequest(completion);
                                    this.stateMachine.go(ChannelState.CLOSE_REQUESTED);
                                }
                                else {
                                    // remote is completed already, send message and clean up
                                    this.sendChannelClosedRequest(completion);
                                    this.closeInternal('Remote completed, confirmation sent');
                                }
                                return [2 /*return*/];
                            });
                        }); })()
                            .catch(function (e) {
                            _this.log.error('Error during sending close channel request', e);
                            reject(e);
                        });
                    })];
            });
        });
    };
    FramedTransportChannel.prototype.onChannelClose = function (channelCloseFrame) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            var error;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.log.isDebugEnabled()) {
                            this.log.debug("Channel close received, current state is " + this.stateMachine.getCurrent());
                        }
                        this.stateMachine.throwIfNot(ChannelState.CLOSE_REQUESTED, ChannelState.OPEN);
                        this.remoteCompletion = channelCloseFrame.getHeaderData().completion || new protocol_1.SuccessCompletion();
                        /* istanbul ignore if */
                        if (this.remoteCompletion && this.log.isDebugEnabled()) {
                            this.log.debug("Remote completed with " + JSON.stringify(this.remoteCompletion));
                        }
                        if (!(this.safeMessagesBuffer && this.safeMessagesBuffer.hasPendingChunks())) return [3 /*break*/, 2];
                        return [4 /*yield*/, common_1.AsyncHelper.waitFor(function () { return !_this.safeMessagesBuffer.hasPendingChunks(); }, new common_2.CancellationToken(), Defaults_1.Defaults.STATUS_CHECK_INTERVAL, Defaults_1.Defaults.OPERATION_TIMEOUT)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        if (!protocol_1.ClientProtocolUtils.isSuccessCompletion(this.remoteCompletion)) {
                            error = this.remoteCompletionToError(this.remoteCompletion);
                            this.closeInternal('Channel Close with error received', error);
                        }
                        else {
                            this.channelObserver.complete();
                            switch (this.stateMachine.getCurrent()) {
                                case ChannelState.OPEN:
                                    this.channelCancellationToken.cancelRead('Channel close received');
                                    this.stateMachine.go(ChannelState.CLOSE_RECEIVED);
                                    break;
                                case ChannelState.CLOSE_REQUESTED:
                                    this.closeInternal('Remote channel close received');
                                    break;
                                default:
                                    throw new Error("Can't handle close, invalid state " + this.stateMachine.getCurrent());
                            }
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    FramedTransportChannel.prototype.closeInternal = function (reason, error) {
        if (reason === void 0) { reason = 'Channel closed'; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var completion;
            return tslib_1.__generator(this, function (_a) {
                if (this.stateMachine.is(ChannelState.CLOSED)) {
                    this.log.error('Channel already closed');
                    return [2 /*return*/, Promise.reject('Channel already closed')];
                }
                this.log.debug("Closing channel resources, reason - " + reason);
                this.channelCancellationToken.cancel(reason);
                this.stateMachine.go(ChannelState.CLOSED);
                this.dispose();
                if (this.onCloseHandler) {
                    this.log.debug('Reporting summarized completion');
                    completion = protocol_1.ClientProtocolUtils.createSummarizedCompletion(this.clientCompletion, this.remoteCompletion || new protocol_1.ErrorCompletion(new protocol_1.ClientError('Remote side not completed')));
                    if (!protocol_1.ClientProtocolUtils.isSuccessCompletion(completion)) {
                        this.channelObserver.error(error || completion.error);
                    }
                    this.onCloseHandler(completion);
                    this.onCloseHandler = null;
                }
                else if (this.channelObserver) {
                    this.log.debug('Close not requested, reporting forced close');
                    this.channelObserver.error(error || new protocol_1.ClientError(reason));
                }
                return [2 /*return*/];
            });
        });
    };
    FramedTransportChannel.prototype.sendLastMessage = function (data) {
        var _this = this;
        this.stateMachine.throwIfNot(ChannelState.OPEN, ChannelState.CLOSE_RECEIVED);
        return this.sendMessage(data).then(function () {
            return _this.close();
        });
    };
    FramedTransportChannel.prototype.sendMessage = function (data) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            var currentMessageIndex;
            return tslib_1.__generator(this, function (_a) {
                this.stateMachine.throwIfNot(ChannelState.OPEN, ChannelState.CLOSE_RECEIVED);
                currentMessageIndex = ++this.messageId;
                /* istanbul ignore if */
                if (this.log.isTraceEnabled()) {
                    this.log.trace("Scheduling sending [" + currentMessageIndex + "] message of " + data.byteLength + " bytes");
                }
                return [2 /*return*/, this.writeExecutor.submit(function () { return _this.sendMessageInternal(data, currentMessageIndex); })];
            });
        });
    };
    FramedTransportChannel.prototype.subscribeToMessages = function (channelObserver) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            var messageHandler, errorHandler;
            return tslib_1.__generator(this, function (_a) {
                messageHandler = function (m) {
                    _this.log.trace("Received message of " + m.byteLength + " bytes");
                    channelObserver.next(m);
                };
                errorHandler = function (e) { return channelObserver.error(e); };
                this.safeMessagesBuffer = new SafeMessageBuffer_1.SafeMessageBuffer(messageHandler, errorHandler);
                this.framedTransport.open({
                    next: function (frame) { return _this.handleIncomingFrame(channelObserver, frame, _this.safeMessagesBuffer); },
                    complete: function () { return _this.log.debug('Received complete from transport'); },
                    error: function (e) { return _this.handleConnectionError(channelObserver, e); }
                })
                    .catch(function (connectionError) { return channelObserver.error(connectionError); });
                return [2 /*return*/];
            });
        });
    };
    FramedTransportChannel.prototype.sendChannelClosedRequest = function (completion) {
        if (completion === void 0) { completion = new protocol_1.SuccessCompletion(); }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                this.clientCompletion = completion;
                this.channelCancellationToken.cancelWrite('Close requested');
                this.log.debug('Sending channel close frame');
                this.writeExecutor.submit(function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                    return tslib_1.__generator(this, function (_a) {
                        this.framedTransport.writeFrame(model_1.ChannelCloseFrame.fromHeaderData({
                            channelId: this.id,
                            completion: completion
                        }));
                        return [2 /*return*/];
                    });
                }); });
                return [2 /*return*/];
            });
        });
    };
    FramedTransportChannel.prototype.handleIncomingFrame = function (channelObserver, frame, safeBuffer) {
        if (this.channelCancellationToken.isReadCancelled()) {
            this.log.warn('Read cancelled, dropping frame');
            return;
        }
        if (!frame) {
            this.log.warn('Empty frame, dropping it');
        }
        else if (frame.internalHeaderProperties.messageFrame) {
            var messageFrame = frame;
            var isLast = !messageFrame.getHeaderData().hasMore;
            /* istanbul ignore if */
            if (this.log.isTraceEnabled()) {
                this.log.trace("Received " + (isLast ? 'last' : '') + " message frame, " + messageFrame.body.byteLength + " bytes");
            }
            safeBuffer.addChunk(messageFrame.body, isLast);
        }
        else if (frame.internalHeaderProperties.channelClose) {
            this.onChannelClose(frame);
        }
        else {
            this.log.warn('Unknown frame received', frame);
        }
    };
    FramedTransportChannel.prototype.remoteCompletionToError = function (completion) {
        if (completion) {
            return completion.error || new protocol_1.ClientError("Remote completed with status " + this.remoteCompletion.status);
        }
        else {
            return new protocol_1.ClientError('Channel closed unexpectedly');
        }
    };
    FramedTransportChannel.prototype.handleConnectionError = function (channelObserver, error) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                if (!this.channelCancellationToken.isReadCancelled()) {
                    this.log.error('Transport connection error received', error);
                    this.closeInternal('Transport connection error', error);
                }
                return [2 /*return*/];
            });
        });
    };
    FramedTransportChannel.prototype.sendMessageInternal = function (data, messageIndex) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var sentBytesCount, totalBytesCount, hasMoreFrames, framesCounter, frameLength, frameBody, frameHeader;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.log.debug("Sending message [" + messageIndex + "] of " + data.byteLength + " bytes");
                        sentBytesCount = 0;
                        totalBytesCount = data.byteLength;
                        hasMoreFrames = false;
                        framesCounter = 0;
                        _a.label = 1;
                    case 1:
                        frameLength = totalBytesCount - sentBytesCount;
                        if (frameLength > this.framedTransport.getMaxFrameSize()) {
                            frameLength = this.framedTransport.getMaxFrameSize();
                        }
                        frameBody = data.slice(sentBytesCount, sentBytesCount + frameLength);
                        sentBytesCount += frameLength;
                        hasMoreFrames = sentBytesCount < totalBytesCount;
                        frameHeader = {
                            channelId: this.id,
                            length: frameLength,
                            hasMore: hasMoreFrames
                        };
                        return [4 /*yield*/, this.framedTransport.writeFrame(model_1.MessageFrame.fromHeaderData(frameHeader, frameBody))];
                    case 2:
                        _a.sent();
                        framesCounter++;
                        _a.label = 3;
                    case 3:
                        if (hasMoreFrames && !this.channelCancellationToken.isWriteCancelled()) return [3 /*break*/, 1];
                        _a.label = 4;
                    case 4:
                        this.log.trace("Sent message [" + messageIndex + "], consist of " + framesCounter + " frames, " + data.byteLength + " bytes");
                        return [2 /*return*/];
                }
            });
        });
    };
    return FramedTransportChannel;
}());
exports.FramedTransportChannel = FramedTransportChannel;

},{"../../common/Defaults":312,"./SafeMessageBuffer":322,"./model":334,"@plexus-interop/common":243,"@plexus-interop/protocol":305,"rxjs/Subscription":129,"tslib":180}],321:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var model_1 = require("./model");
var model_2 = require("./model");
var FramedTransportChannel_1 = require("./FramedTransportChannel");
var BufferedTransportProxy_1 = require("./BufferedTransportProxy");
var protocol_1 = require("@plexus-interop/protocol");
var TransportFrameHandler_1 = require("./TransportFrameHandler");
var common_1 = require("@plexus-interop/common");
var ConnectionState;
(function (ConnectionState) {
    ConnectionState["CREATED"] = "CREATED";
    ConnectionState["ACCEPT"] = "ACCEPT";
    ConnectionState["OPEN"] = "OPEN";
    ConnectionState["CLOSE_RECEIVED"] = "CLOSE_RECEIVED";
    ConnectionState["CLOSE_REQUESTED"] = "CLOSE_REQUESTED";
    ConnectionState["CLOSED"] = "CLOSED";
})(ConnectionState = exports.ConnectionState || (exports.ConnectionState = {}));
var FramedTransportConnection = /** @class */ (function () {
    function FramedTransportConnection(framedTransport) {
        this.framedTransport = framedTransport;
        this.connectionCancellationToken = new common_1.ReadWriteCancellationToken();
        this.channelsHolder = new Map();
        this.framesHandler = new TransportFrameHandler_1.TransportFrameHandler();
        this.log = common_1.LoggerFactory.getLogger("FramedTransportConnection [" + this.uuid().toString() + "]");
        this.channelObserver = new common_1.BufferedObserver(1024, this.log);
        this.stateMachine = this.createStateMaschine();
        this.log.debug('Created');
    }
    FramedTransportConnection.prototype.disconnect = function (completion) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.stateMachine.getCurrent();
                        switch (_a) {
                            case ConnectionState.OPEN: return [3 /*break*/, 1];
                            case ConnectionState.CLOSE_RECEIVED: return [3 /*break*/, 3];
                        }
                        return [3 /*break*/, 5];
                    case 1:
                        this.log.debug('Current state is OPEN, requesting connection close');
                        return [4 /*yield*/, this.stateMachine.goAsync(ConnectionState.CLOSE_REQUESTED, {
                                preHandler: function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                                    return tslib_1.__generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, this.sendConnectionCloseMessage(completion)];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }); }
                            })];
                    case 2:
                        _b.sent();
                        return [3 /*break*/, 6];
                    case 3:
                        this.log.debug('Current state is CLOSE_RECEIVED, closing all');
                        return [4 /*yield*/, this.sendConnectionCloseMessage(completion)];
                    case 4:
                        _b.sent();
                        this.closeAndCleanUp();
                        return [3 /*break*/, 6];
                    case 5: throw new Error("Can't close, invalid state " + this.stateMachine.getCurrent());
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    FramedTransportConnection.prototype.getManagedChannels = function () {
        var result = [];
        this.channelsHolder.forEach(function (value) {
            result.push(value.channel);
        });
        return result;
    };
    FramedTransportConnection.prototype.getManagedChannel = function (id) {
        var descriptor = this.channelsHolder.get(id);
        return descriptor ? descriptor.channel : undefined;
    };
    FramedTransportConnection.prototype.createChannel = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var uuid, channel;
            return tslib_1.__generator(this, function (_a) {
                this.stateMachine.throwIfNot(ConnectionState.OPEN);
                uuid = protocol_1.UniqueId.generateNew();
                channel = this.createOutChannel(uuid).channel;
                this.framedTransport.writeFrame(model_2.ChannelOpenFrame.fromHeaderData({
                    channelId: uuid
                }));
                return [2 /*return*/, channel];
            });
        });
    };
    FramedTransportConnection.prototype.uuid = function () {
        return this.framedTransport.uuid();
    };
    FramedTransportConnection.prototype.isConnected = function () {
        return !this.stateMachine.isOneOf(ConnectionState.CREATED, ConnectionState.CLOSED);
    };
    FramedTransportConnection.prototype.subscribeToChannels = function (channelObserver) {
        this.log.debug('Received channels observer');
        this.channelObserver.setObserver(channelObserver);
        return new common_1.AnonymousSubscription();
    };
    FramedTransportConnection.prototype.connect = function (channelObserver) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                this.log.debug("Opening connection, channel observer " + (!!channelObserver ? 'provided' : 'not provided'));
                if (channelObserver) {
                    this.channelObserver.setObserver(channelObserver);
                }
                return [2 /*return*/, this.stateMachine.goAsync(ConnectionState.OPEN)];
            });
        });
    };
    FramedTransportConnection.prototype.acceptingConnection = function (channelObserver) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                this.log.debug("Accepting connection, channel observer " + (!!channelObserver ? 'provided' : 'not provided'));
                if (channelObserver) {
                    this.channelObserver.setObserver(channelObserver);
                }
                return [2 /*return*/, this.stateMachine.goAsync(ConnectionState.ACCEPT)];
            });
        });
    };
    FramedTransportConnection.prototype.closeAndCleanUp = function () {
        var _this = this;
        if (this.stateMachine.is(ConnectionState.CLOSED)) {
            this.log.debug('Already closed');
            return;
        }
        /* istanbul ignore if */
        if (this.log.isDebugEnabled()) {
            this.log.debug("Closing connection, current state is " + this.stateMachine.getCurrent());
        }
        this.connectionCancellationToken.cancel('Connection is closed');
        this.stateMachine.go(ConnectionState.CLOSED);
        this.channelsHolder.forEach(function (value, key) {
            _this.log.debug("Cleaning channel " + key);
            value.channel.closeInternal('Transport connection closed');
            value.channelTransportProxy.clear();
        });
        this.channelsHolder.clear();
        this.disconnectFromSource()
            .catch(function (e) { return _this.log.error('Failed to disconnect from source', e); });
    };
    FramedTransportConnection.prototype.handleConnectionCloseFrame = function (frame) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var completion;
            return tslib_1.__generator(this, function (_a) {
                completion = frame.getHeaderData().completion || new protocol_1.SuccessCompletion();
                /* istanbul ignore if */
                if (this.log.isDebugEnabled()) {
                    this.log.debug('Received connection close', JSON.stringify(completion));
                }
                if (!protocol_1.ClientProtocolUtils.isSuccessCompletion(completion)) {
                    this.log.error('Received connection close with error', JSON.stringify(completion));
                    this.reportErrorToChannels(completion.error || new protocol_1.ClientError('Transport closed with error'));
                    this.closeAndCleanUp();
                }
                else {
                    switch (this.stateMachine.getCurrent()) {
                        case ConnectionState.OPEN:
                            this.log.debug('Close received, waiting for client to close it');
                            this.stateMachine.go(ConnectionState.CLOSE_RECEIVED);
                            this.channelObserver.complete();
                            break;
                        case ConnectionState.CLOSE_REQUESTED:
                            this.log.debug('Close already requested, closing connection');
                            this.channelObserver.complete();
                            this.closeAndCleanUp();
                            break;
                        default:
                            throw new Error("Can't handle close, invalid state " + this.stateMachine.getCurrent());
                    }
                }
                return [2 /*return*/];
            });
        });
    };
    FramedTransportConnection.prototype.handleChannelOpenFrame = function (frame) {
        this.log.trace('Received channel open frame');
        var channelId = protocol_1.UniqueId.fromProperties(frame.getHeaderData().channelId);
        this.log.debug("Received open channel request " + channelId);
        if (!this.channelsHolder.has(channelId.toString())) {
            this.createInChannel(channelId);
        }
        else {
            this.log.debug("Channel " + channelId.toString() + " already exist");
        }
    };
    FramedTransportConnection.prototype.handleChannelCloseFrame = function (frame) {
        var channelId = protocol_1.UniqueId.fromProperties(frame.getHeaderData().channelId);
        var strChannelId = channelId.toString();
        /* istanbul ignore if */
        if (this.log.isTraceEnabled()) {
            this.log.trace("Received channel close frame, channelId " + strChannelId);
        }
        if (this.channelsHolder.has(strChannelId)) {
            var channelDescriptor = this.channelsHolder.get(strChannelId);
            this.log.debug('Pass close frame to channel', strChannelId);
            channelDescriptor.channelTransportProxy.next(frame);
            channelDescriptor.channelTransportProxy.complete();
        }
        else {
            this.log.warn("Received close channel frame for not existing uuid " + strChannelId);
        }
    };
    FramedTransportConnection.prototype.handleConnectionOpenFrame = function (frame) {
        this.log.trace('Received connection open frame');
        if (this.stateMachine.is(ConnectionState.OPEN)) {
            this.log.debug("Received connection open confimation");
        }
        else if (this.stateMachine.is(ConnectionState.ACCEPT)) {
            this.log.debug("Received connection open request");
            this.stateMachine.go(ConnectionState.OPEN);
        }
    };
    FramedTransportConnection.prototype.handleMessageFrame = function (frame) {
        var channelIdProps = frame.getHeaderData().channelId;
        var channelId = protocol_1.UniqueId.fromProperties(channelIdProps);
        var strChannelId = channelId.toString();
        /* istanbul ignore if */
        if (this.log.isTraceEnabled()) {
            this.log.trace("Received message frame, channelId " + strChannelId);
        }
        var channelExists = this.channelsHolder.has(strChannelId);
        if (!channelExists) {
            // not first frame, however no buffer exist
            this.log.error("Dropped frame, no incoming buffer exist for " + strChannelId);
        }
        else {
            // add frame to incoming buffer
            /* istanbul ignore if */
            if (this.log.isDebugEnabled()) {
                this.log.debug("Received data frame for channel " + strChannelId);
            }
            var channelDescriptor = this.channelsHolder.get(strChannelId);
            channelDescriptor.channelTransportProxy.next(frame);
        }
    };
    FramedTransportConnection.prototype.createStateMaschine = function () {
        var _this = this;
        return new common_1.StateMaschineBase(ConnectionState.CREATED, [
            // initializing connection
            {
                from: ConnectionState.CREATED, to: ConnectionState.OPEN,
                preHandler: this.openConnectionInternal.bind(this),
                postHandler: function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                    return tslib_1.__generator(this, function (_a) {
                        this.listenForIncomingFrames();
                        return [2 /*return*/];
                    });
                }); }
            },
            // accepting connection
            {
                from: ConnectionState.CREATED, to: ConnectionState.ACCEPT,
                postHandler: function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                    return tslib_1.__generator(this, function (_a) {
                        this.listenForIncomingFrames();
                        return [2 /*return*/];
                    });
                }); }
            },
            // connection accepted
            {
                from: ConnectionState.ACCEPT, to: ConnectionState.OPEN,
                preHandler: this.openConnectionInternal.bind(this)
            },
            // closing connection message requested
            {
                from: ConnectionState.OPEN, to: ConnectionState.CLOSE_REQUESTED
            },
            // forced connection closure
            {
                from: ConnectionState.OPEN, to: ConnectionState.CLOSED
            },
            {
                from: ConnectionState.CLOSE_RECEIVED, to: ConnectionState.CLOSED
            },
            {
                from: ConnectionState.OPEN, to: ConnectionState.CLOSE_RECEIVED, preHandler: function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                    return tslib_1.__generator(this, function (_a) {
                        this.connectionCancellationToken.cancelRead('Connection close received');
                        return [2 /*return*/];
                    });
                }); }
            },
            // graceful connection closure
            {
                from: ConnectionState.CLOSE_REQUESTED, to: ConnectionState.CLOSED
            }
        ], this.log);
    };
    FramedTransportConnection.prototype.sendConnectionCloseMessage = function (completion) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                this.log.debug('Requesting close connection');
                this.framedTransport.writeFrame(model_1.ConnectionCloseFrame.fromHeaderData({ completion: completion }));
                return [2 /*return*/];
            });
        });
    };
    FramedTransportConnection.prototype.openConnectionInternal = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var id;
            return tslib_1.__generator(this, function (_a) {
                this.log.trace('Opening connection');
                id = this.framedTransport.uuid();
                this.framedTransport.writeFrame(model_1.ConnectionOpenFrame.fromHeaderData({
                    connectionId: id
                }));
                return [2 /*return*/];
            });
        });
    };
    FramedTransportConnection.prototype.disconnectFromSource = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                this.log.debug('Disconnecting from source transport');
                return [2 /*return*/, this.framedTransport
                        .disconnect()
                        .then(function () {
                        _this.log.debug('Transport disconnected');
                    }, function (error) {
                        _this.log.error('Transport disconnect error', error);
                    })];
            });
        });
    };
    FramedTransportConnection.prototype.listenForIncomingFrames = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                this.log.debug('Start listening of incoming frames');
                this.framedTransport.open({
                    next: function (frame) {
                        if (_this.stateMachine.isOneOf(ConnectionState.CLOSE_REQUESTED, ConnectionState.OPEN, ConnectionState.ACCEPT)) {
                            _this.framesHandler.handleFrame(frame, _this.log, _this);
                        }
                        else {
                            _this.log.warn('Not connected, dropping frame');
                        }
                    },
                    error: function (transportError) {
                        _this.log.error('Error from source transport', transportError);
                        _this.reportErrorToChannels(transportError);
                        _this.closeAndCleanUp();
                    },
                    complete: function () {
                        _this.log.debug('Source connection completed');
                        _this.closeAndCleanUp();
                    }
                });
                return [2 /*return*/];
            });
        });
    };
    FramedTransportConnection.prototype.reportErrorToChannels = function (error) {
        this.channelsHolder.forEach(function (value, key) {
            value.channelTransportProxy.error(error);
        });
    };
    FramedTransportConnection.prototype.createOutChannel = function (channelId) {
        return this.createChannelInternal(channelId, false);
    };
    FramedTransportConnection.prototype.createInChannel = function (channelId) {
        return this.createChannelInternal(channelId, true);
    };
    FramedTransportConnection.prototype.createChannelInternal = function (channelId, isIncomingChannel) {
        var _this = this;
        var strChannelId = channelId.toString();
        this.log.debug("Creating new channel " + strChannelId);
        var proxyLogger = common_1.LoggerFactory.getLogger("ChannelTranportProxy [" + strChannelId + "]");
        var channelTransportProxy = new BufferedTransportProxy_1.BufferedTransportProxy(this.framedTransport, this.connectionCancellationToken.getWriteToken(), proxyLogger);
        var dispose = function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var channelDescriptor;
            return tslib_1.__generator(this, function (_a) {
                /* istanbul ignore if */
                if (this.log.isDebugEnabled()) {
                    this.log.debug("Dispose called on " + strChannelId + " channel");
                }
                if (this.channelsHolder.has(strChannelId)) {
                    channelDescriptor = this.channelsHolder.get(strChannelId);
                    channelDescriptor.channelTransportProxy.clear();
                    this.channelsHolder.delete(strChannelId);
                }
                return [2 /*return*/];
            });
        }); };
        var channel = new FramedTransportChannel_1.FramedTransportChannel(channelId, channelTransportProxy, dispose, this.connectionCancellationToken.getWriteToken());
        this.channelsHolder.set(strChannelId, { channel: channel, channelTransportProxy: channelTransportProxy });
        if (isIncomingChannel) {
            this.channelObserver.next(channel);
        }
        return { channel: channel, channelTransportProxy: channelTransportProxy };
    };
    return FramedTransportConnection;
}());
exports.FramedTransportConnection = FramedTransportConnection;

},{"./BufferedTransportProxy":319,"./FramedTransportChannel":320,"./TransportFrameHandler":323,"./model":334,"@plexus-interop/common":243,"@plexus-interop/protocol":305,"tslib":180}],322:[function(require,module,exports){
(function (global){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = require("@plexus-interop/common");
var globalObj = typeof window !== 'undefined' ? window : global;
/**
 * To mitigate browser issues with concatenating of multiple small chunks into huge one
 */
var SafeMessageBuffer = /** @class */ (function () {
    function SafeMessageBuffer(onMessage, onError, syncSizeThreshold, throttlingPeriod, batchSize) {
        if (onError === void 0) { onError = function () { }; }
        if (syncSizeThreshold === void 0) { syncSizeThreshold = 1024 * 1024; }
        if (throttlingPeriod === void 0) { throttlingPeriod = 500; }
        if (batchSize === void 0) { batchSize = 50; }
        this.onMessage = onMessage;
        this.onError = onError;
        this.syncSizeThreshold = syncSizeThreshold;
        this.throttlingPeriod = throttlingPeriod;
        this.batchSize = batchSize;
        this.log = common_1.LoggerFactory.getLogger('SafeMessageBuffer');
        this.maxChunksQueueSize = 10 * 1024;
        this.buffer = new ArrayBuffer(0);
        this.chunksQueue = new common_1.LimitedBufferQueue(this.maxChunksQueueSize);
        this.syncTimeoutId = null;
        this.failure = null;
    }
    SafeMessageBuffer.prototype.getCurrentBuffer = function () {
        return this.buffer;
    };
    SafeMessageBuffer.prototype.addChunk = function (buffer, isLast) {
        if (this.failure) {
            throw this.failure;
        }
        var queueEmpty = this.chunksQueue.isEmpty();
        var reachedLimit = !queueEmpty || buffer.byteLength + this.buffer.byteLength > this.syncSizeThreshold;
        try {
            if (reachedLimit) {
                this.log.trace("Reached limit of " + this.syncSizeThreshold + " bytes, adding chunk to queue");
                this.chunksQueue.enqueue({ buffer: buffer, isLast: isLast });
                this.scheduleFlush();
            }
            else if (isLast) {
                this.onMessage(common_1.Arrays.concatenateBuffers(this.buffer, buffer));
                this.buffer = new ArrayBuffer(0);
            }
            else {
                this.buffer = common_1.Arrays.concatenateBuffers(this.buffer, buffer);
            }
        }
        catch (error) {
            this.handleError(error);
        }
    };
    SafeMessageBuffer.prototype.hasPendingChunks = function () {
        return !this.chunksQueue.isEmpty();
    };
    SafeMessageBuffer.prototype.scheduleFlush = function () {
        var _this = this;
        if (!this.syncTimeoutId) {
            this.syncTimeoutId = globalObj.setTimeout(function () {
                try {
                    _this.syncTimeoutId = null;
                    _this.log.info("Increasing buffer with " + (_this.chunksQueue.size() < _this.batchSize ? _this.chunksQueue.size() : _this.batchSize) + " chunks");
                    _this.buffer = _this.flushChunks(_this.buffer, _this.chunksQueue, _this.batchSize);
                    _this.log.info("Current buffer size - " + _this.buffer.byteLength + " bytes, " + _this.chunksQueue.size() + " chunks in queue");
                    if (!_this.chunksQueue.isEmpty()) {
                        _this.scheduleFlush();
                    }
                }
                catch (error) {
                    _this.handleError(error);
                }
            }, this.throttlingPeriod);
        }
    };
    SafeMessageBuffer.prototype.flushChunks = function (resultBuffer, chunksQueue, batchSize) {
        var chunksBuffer = new ArrayBuffer(0);
        var last = false;
        // concatenate small chunks together first
        while (!last && !chunksQueue.isEmpty() && batchSize > 0) {
            var _a = chunksQueue.dequeue(), buffer = _a.buffer, isLast = _a.isLast;
            last = isLast;
            chunksBuffer = common_1.Arrays.concatenateBuffers(chunksBuffer, buffer);
            batchSize--;
        }
        // now we can append to result buffer
        if (last) {
            this.onMessage(common_1.Arrays.concatenateBuffers(resultBuffer, chunksBuffer));
            return new ArrayBuffer(0);
        }
        else {
            resultBuffer = common_1.Arrays.concatenateBuffers(resultBuffer, chunksBuffer);
            return resultBuffer;
        }
    };
    SafeMessageBuffer.prototype.handleError = function (e) {
        this.log.error('Failed on updating the buffer', e);
        this.failure = e;
        this.buffer = new ArrayBuffer(0);
        this.onError(e);
    };
    return SafeMessageBuffer;
}());
exports.SafeMessageBuffer = SafeMessageBuffer;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"@plexus-interop/common":243}],323:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TransportFrameHandler = /** @class */ (function () {
    function TransportFrameHandler() {
    }
    TransportFrameHandler.prototype.handleFrame = function (baseFrame, log, typedFramesListener) {
        if (!baseFrame) {
            log.warn('Empty frame header, dropping frame');
        }
        else if (baseFrame.internalHeaderProperties.messageFrame) {
            typedFramesListener.handleMessageFrame(baseFrame);
        }
        else if (baseFrame.internalHeaderProperties.close) {
            typedFramesListener.handleConnectionCloseFrame(baseFrame);
        }
        else if (baseFrame.internalHeaderProperties.channelOpen) {
            typedFramesListener.handleChannelOpenFrame(baseFrame);
        }
        else if (baseFrame.internalHeaderProperties.channelClose) {
            typedFramesListener.handleChannelCloseFrame(baseFrame);
        }
        else if (baseFrame.internalHeaderProperties.open) {
            typedFramesListener.handleConnectionOpenFrame(baseFrame);
        }
        else {
            throw new Error('Unsupported frame type');
        }
    };
    return TransportFrameHandler;
}());
exports.TransportFrameHandler = TransportFrameHandler;

},{}],324:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
tslib_1.__exportStar(require("./model"), exports);
tslib_1.__exportStar(require("./FramedTransportChannel"), exports);
tslib_1.__exportStar(require("./FramedTransportConnection"), exports);
tslib_1.__exportStar(require("./SafeMessageBuffer"), exports);

},{"./FramedTransportChannel":320,"./FramedTransportConnection":321,"./SafeMessageBuffer":322,"./model":334,"tslib":180}],325:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var ServiceFrame_1 = require("./ServiceFrame");
var ChannelCloseFrame = /** @class */ (function (_super) {
    tslib_1.__extends(ChannelCloseFrame, _super);
    function ChannelCloseFrame(header) {
        var _this = _super.call(this) || this;
        _this._header = header;
        return _this;
    }
    ChannelCloseFrame.fromHeaderData = function (headerData) {
        return new ChannelCloseFrame({
            channelClose: headerData
        });
    };
    ChannelCloseFrame.prototype.getHeaderData = function () {
        return this._header.channelClose;
    };
    return ChannelCloseFrame;
}(ServiceFrame_1.ServiceFrame));
exports.ChannelCloseFrame = ChannelCloseFrame;

},{"./ServiceFrame":333,"tslib":180}],326:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var ServiceFrame_1 = require("./ServiceFrame");
var ChannelOpenFrame = /** @class */ (function (_super) {
    tslib_1.__extends(ChannelOpenFrame, _super);
    function ChannelOpenFrame(header) {
        var _this = _super.call(this) || this;
        _this._header = header;
        return _this;
    }
    ChannelOpenFrame.fromHeaderData = function (headerData) {
        return new ChannelOpenFrame({
            channelOpen: headerData
        });
    };
    ChannelOpenFrame.prototype.getHeaderData = function () {
        return this._header.channelOpen;
    };
    return ChannelOpenFrame;
}(ServiceFrame_1.ServiceFrame));
exports.ChannelOpenFrame = ChannelOpenFrame;

},{"./ServiceFrame":333,"tslib":180}],327:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var ServiceFrame_1 = require("./ServiceFrame");
var ConnectionCloseFrame = /** @class */ (function (_super) {
    tslib_1.__extends(ConnectionCloseFrame, _super);
    function ConnectionCloseFrame(header) {
        var _this = _super.call(this) || this;
        _this._header = header;
        return _this;
    }
    ConnectionCloseFrame.fromHeaderData = function (headerData) {
        return new ConnectionCloseFrame({
            close: headerData
        });
    };
    ConnectionCloseFrame.prototype.getHeaderData = function () {
        return this._header.close;
    };
    return ConnectionCloseFrame;
}(ServiceFrame_1.ServiceFrame));
exports.ConnectionCloseFrame = ConnectionCloseFrame;

},{"./ServiceFrame":333,"tslib":180}],328:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var protocol_1 = require("@plexus-interop/protocol");
var ServiceFrame_1 = require("./ServiceFrame");
var ConnectionOpenFrame = /** @class */ (function (_super) {
    tslib_1.__extends(ConnectionOpenFrame, _super);
    function ConnectionOpenFrame(header) {
        var _this = _super.call(this) || this;
        _this._header = header;
        return _this;
    }
    ConnectionOpenFrame.fromHeaderData = function (headerData) {
        return new ConnectionOpenFrame({
            open: headerData
        });
    };
    ConnectionOpenFrame.prototype.getInternalHeader = function () {
        return new protocol_1.transportProtocol.interop.transport.protocol.Header({
            open: this.getHeaderData()
        });
    };
    ConnectionOpenFrame.prototype.getHeaderData = function () {
        return this._header.open;
    };
    return ConnectionOpenFrame;
}(ServiceFrame_1.ServiceFrame));
exports.ConnectionOpenFrame = ConnectionOpenFrame;

},{"./ServiceFrame":333,"@plexus-interop/protocol":305,"tslib":180}],329:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Frame_1 = require("./Frame");
var DataFrame = /** @class */ (function (_super) {
    tslib_1.__extends(DataFrame, _super);
    function DataFrame() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DataFrame.prototype.isDataFrame = function () {
        return true;
    };
    return DataFrame;
}(Frame_1.BaseFrame));
exports.DataFrame = DataFrame;

},{"./Frame":330,"tslib":180}],330:[function(require,module,exports){
"use strict";
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var protocol_1 = require("@plexus-interop/protocol");
var Frame = /** @class */ (function () {
    function Frame() {
    }
    Object.defineProperty(Frame.prototype, "internalHeaderProperties", {
        get: function () {
            return this._header;
        },
        enumerable: true,
        configurable: true
    });
    Frame.prototype.getInternalHeader = function () {
        return new protocol_1.transportProtocol.interop.transport.protocol.Header(this._header);
    };
    return Frame;
}());
exports.Frame = Frame;
var BaseFrame = /** @class */ (function (_super) {
    tslib_1.__extends(BaseFrame, _super);
    function BaseFrame() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(BaseFrame.prototype, "body", {
        get: function () {
            return this._body;
        },
        set: function (body) {
            this._body = body;
        },
        enumerable: true,
        configurable: true
    });
    return BaseFrame;
}(Frame));
exports.BaseFrame = BaseFrame;

},{"@plexus-interop/protocol":305,"tslib":180}],331:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var protocol_1 = require("@plexus-interop/protocol");
var _1 = require(".");
var ConnectionOpenFrame_1 = require("./ConnectionOpenFrame");
var common_1 = require("@plexus-interop/common");
var InternalMessagesConverter = /** @class */ (function () {
    function InternalMessagesConverter() {
    }
    InternalMessagesConverter.prototype.deserialize = function (data) {
        var protoFrame = protocol_1.transportProtocol.interop.transport.protocol.Header.decode(data);
        var plainData = protocol_1.transportProtocol.interop.transport.protocol.Header.toObject(protoFrame);
        if (plainData.channelClose) {
            return new _1.ChannelCloseFrame(plainData);
        }
        else if (plainData.channelOpen) {
            return new _1.ChannelOpenFrame(plainData);
        }
        else if (plainData.close) {
            return new _1.ConnectionCloseFrame(plainData);
        }
        else if (plainData.messageFrame) {
            return new _1.MessageFrame(plainData);
        }
        else if (plainData.open) {
            return new ConnectionOpenFrame_1.ConnectionOpenFrame(plainData);
        }
        else {
            throw new Error('Unsupported frame type');
        }
    };
    InternalMessagesConverter.prototype.serialize = function (frame) {
        return common_1.Arrays.toArrayBuffer(protocol_1.transportProtocol.interop.transport.protocol.Header.encode(frame.internalHeaderProperties).finish());
    };
    return InternalMessagesConverter;
}());
exports.InternalMessagesConverter = InternalMessagesConverter;

},{".":334,"./ConnectionOpenFrame":328,"@plexus-interop/common":243,"@plexus-interop/protocol":305}],332:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var DataFrame_1 = require("./DataFrame");
var MessageFrame = /** @class */ (function (_super) {
    tslib_1.__extends(MessageFrame, _super);
    function MessageFrame(header, body) {
        if (body === void 0) { body = new Uint8Array([]).buffer; }
        var _this = _super.call(this) || this;
        _this._header = header;
        _this.body = body;
        return _this;
    }
    MessageFrame.fromHeaderData = function (headerData, body) {
        return new MessageFrame({
            messageFrame: headerData
        }, body);
    };
    MessageFrame.prototype.isLast = function () {
        return !this.getHeaderData().hasMore;
    };
    MessageFrame.prototype.getHeaderData = function () {
        return this._header.messageFrame;
    };
    return MessageFrame;
}(DataFrame_1.DataFrame));
exports.MessageFrame = MessageFrame;

},{"./DataFrame":329,"tslib":180}],333:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Frame_1 = require("./Frame");
var ServiceFrame = /** @class */ (function (_super) {
    tslib_1.__extends(ServiceFrame, _super);
    function ServiceFrame() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ServiceFrame.prototype.isDataFrame = function () {
        return false;
    };
    return ServiceFrame;
}(Frame_1.BaseFrame));
exports.ServiceFrame = ServiceFrame;

},{"./Frame":330,"tslib":180}],334:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
tslib_1.__exportStar(require("./MessageFrame"), exports);
tslib_1.__exportStar(require("./ConnectionOpenFrame"), exports);
tslib_1.__exportStar(require("./ConnectionCloseFrame"), exports);
tslib_1.__exportStar(require("./ChannelOpenFrame"), exports);
tslib_1.__exportStar(require("./ChannelCloseFrame"), exports);
tslib_1.__exportStar(require("./Frame"), exports);
tslib_1.__exportStar(require("./InternalMessagesConverter"), exports);

},{"./ChannelCloseFrame":325,"./ChannelOpenFrame":326,"./ConnectionCloseFrame":327,"./ConnectionOpenFrame":328,"./Frame":330,"./InternalMessagesConverter":331,"./MessageFrame":332,"tslib":180}],335:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
require('long');
tslib_1.__exportStar(require("./frame"), exports);
tslib_1.__exportStar(require("./InMemoryConnectionFactory"), exports);
tslib_1.__exportStar(require("./InMemoryFramedTransport"), exports);
var protocol_1 = require("@plexus-interop/protocol");
exports.UniqueId = protocol_1.UniqueId;

},{"./InMemoryConnectionFactory":316,"./InMemoryFramedTransport":317,"./frame":324,"@plexus-interop/protocol":305,"long":82,"tslib":180}],336:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
tslib_1.__exportStar(require("./transport"), exports);
},{"./transport":339,"tslib":180}],337:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var transport_common_1 = require("@plexus-interop/transport-common");
var WebSocketFramedTransport_1 = require("./WebSocketFramedTransport");
var WebSocketConnectionFactory = /** @class */ (function () {
    function WebSocketConnectionFactory(socket) {
        this.socket = socket;
    }
    WebSocketConnectionFactory.prototype.connect = function (connectionDetails) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var webSocketTransport = new WebSocketFramedTransport_1.WebSocketFramedTransport(_this.socket);
            webSocketTransport.connectionEstablished().then(function () {
                var connection = new transport_common_1.FramedTransportConnection(webSocketTransport);
                connection.connect(connectionDetails ? connectionDetails.incomingChannelsObserver : undefined)
                    .then(function () { return resolve(connection); })
                    .catch(reject);
            }, function (error) {
                reject(error);
            });
        });
    };
    return WebSocketConnectionFactory;
}());
exports.WebSocketConnectionFactory = WebSocketConnectionFactory;
},{"./WebSocketFramedTransport":338,"@plexus-interop/transport-common":315}],338:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var transport_common_1 = require("@plexus-interop/transport-common");
var common_1 = require("@plexus-interop/common");
var WebSocketFramedTransport = /** @class */ (function () {
    function WebSocketFramedTransport(socket, guid, messagesConverter) {
        if (guid === void 0) { guid = transport_common_1.UniqueId.generateNew(); }
        if (messagesConverter === void 0) { messagesConverter = new transport_common_1.InternalMessagesConverter(); }
        this.socket = socket;
        this.guid = guid;
        this.messagesConverter = messagesConverter;
        this.socketOpenToken = new common_1.CancellationToken();
        this.terminateSent = false;
        this.terminateReceived = false;
        this.socket.binaryType = 'arraybuffer';
        this.log = common_1.LoggerFactory.getLogger("WebSocketFramedTransport [" + this.uuid().toString() + "]");
        this.connectionObserver = new common_1.BufferedObserver(transport_common_1.Defaults.DEFAULT_BUFFER_SIZE, this.log);
        this.connectionEstablishedPromise = this.createConnectionReadyPromise();
        this.bindToSocketEvents();
        this.log.debug('Created');
    }
    WebSocketFramedTransport.prototype.connectionEstablished = function () {
        return this.connectionEstablishedPromise;
    };
    WebSocketFramedTransport.prototype.disconnect = function () {
        if (this.socketOpenToken.isCancelled()) {
            this.log.warn('Already disconnected');
            return Promise.resolve();
        }
        if (this.isSocketClosed()) {
            this.log.warn('Socket is CLOSED, cancelling connection');
            this.cancelConnectionAndCleanUp();
            return Promise.resolve();
        }
        else {
            this.throwIfNotConnected();
            return this.closeConnectionInternal();
        }
    };
    WebSocketFramedTransport.prototype.connected = function () {
        return this.socket.readyState === WebSocketFramedTransport.OPEN;
    };
    WebSocketFramedTransport.prototype.open = function (connectionObserver) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                this.throwIfNotConnectedOrDisconnectRequested();
                this.connectionObserver.setObserver(connectionObserver);
                return [2 /*return*/];
            });
        });
    };
    WebSocketFramedTransport.prototype.writeFrame = function (frame) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data;
            return tslib_1.__generator(this, function (_a) {
                this.throwIfNotConnectedOrDisconnectRequested();
                data = this.messagesConverter.serialize(frame);
                /* istanbul ignore if */
                if (this.log.isDebugEnabled()) {
                    this.log.debug("Sending header frame of " + data.byteLength + " bytes to server");
                }
                this.socket.send(data);
                if (frame.isDataFrame()) {
                    /* istanbul ignore if */
                    if (this.log.isDebugEnabled()) {
                        this.log.debug("Sending data frame of " + frame.body.byteLength + " bytes to server");
                    }
                    this.socket.send(frame.body);
                }
                else if (frame.internalHeaderProperties.close) {
                    this.sendTerminateMessage();
                }
                return [2 /*return*/];
            });
        });
    };
    WebSocketFramedTransport.prototype.closeSocket = function () {
        this.socket.close();
    };
    WebSocketFramedTransport.prototype.getMaxFrameSize = function () {
        return transport_common_1.Defaults.DEFAULT_FRAME_SIZE;
    };
    WebSocketFramedTransport.prototype.uuid = function () {
        return this.guid;
    };
    WebSocketFramedTransport.prototype.sendTerminateMessage = function () {
        this.log.debug('Sending terminate message');
        this.socket.send(WebSocketFramedTransport.TERMINATE_MESSAGE);
        this.terminateSent = true;
    };
    WebSocketFramedTransport.prototype.createConnectionReadyPromise = function () {
        var _this = this;
        var opened = false;
        return new Promise(function (resolve, reject) {
            _this.socket.onopen = function () {
                opened = true;
                _this.handleOpen();
                resolve();
            };
            _this.socket.addEventListener('error', function (e) {
                if (!opened) {
                    reject('Connection error');
                }
                else {
                    _this.log.warn('Connection error', e);
                }
            });
        });
    };
    WebSocketFramedTransport.prototype.isSocketClosed = function () {
        return this.socket.readyState === WebSocketFramedTransport.CLOSED
            || this.socket.readyState === WebSocketFramedTransport.CLOSING;
    };
    WebSocketFramedTransport.prototype.bindToSocketEvents = function () {
        this.socket.onmessage = this.handleMessageEvent.bind(this);
        this.socket.onerror = this.handleError.bind(this);
        this.socket.onclose = this.handleCloseEvent.bind(this);
    };
    WebSocketFramedTransport.prototype.closeConnectionInternal = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.log.debug('Closing connection');
                        this.cancelConnectionAndCleanUp();
                        if (!(this.terminateSent && this.terminateReceived)) return [3 /*break*/, 1];
                        this.scheduleSocketDisconnect();
                        return [3 /*break*/, 4];
                    case 1:
                        if (!this.terminateSent) return [3 /*break*/, 3];
                        this.log.debug('Server terminate event not received, waiting to close connection gracefully');
                        return [4 /*yield*/, this.waitForTerminateMessage()];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        if (this.terminateReceived) {
                            this.sendTerminateMessage();
                            this.scheduleSocketDisconnect();
                        }
                        else {
                            this.sendTerminateMessage();
                        }
                        _a.label = 4;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    WebSocketFramedTransport.prototype.waitForTerminateMessage = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            var error_1, errorMsg;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, common_1.AsyncHelper.waitFor(function () { return _this.terminateReceived; }, new common_1.CancellationToken(), WebSocketFramedTransport.TERMINATE_MESSAGE_CHECK_TIMEOUT, WebSocketFramedTransport.TERMINATE_MESSAGE_RECEIVED_TIMEOUT)];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        error_1 = _a.sent();
                        errorMsg = "WebSocket Terminate message not received within " + WebSocketFramedTransport.TERMINATE_MESSAGE_RECEIVED_TIMEOUT + "ms";
                        this.log.error(errorMsg, error_1);
                        throw new Error(errorMsg);
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    WebSocketFramedTransport.prototype.scheduleSocketDisconnect = function () {
        var _this = this;
        this.log.debug('Scheduling socket close action');
        setTimeout(function () {
            try {
                if (_this.connected()) {
                    _this.log.debug('Closing socket');
                    _this.socket.close();
                }
                else {
                    _this.log.debug('Already closed');
                }
            }
            catch (error) {
                _this.log.error('Error on closing the socket', error);
            }
        }, WebSocketFramedTransport.SOCKET_CLOSE_TIMEOUT);
    };
    WebSocketFramedTransport.prototype.cancelConnectionAndCleanUp = function (reason) {
        if (reason === void 0) { reason = 'Connection closed'; }
        this.log.debug("Cancelling connection with reason: " + reason);
        this.socketOpenToken.cancel(reason);
        this.connectionObserver.clear();
    };
    WebSocketFramedTransport.prototype.handleCloseEvent = function (socket, ev) {
        this.log.debug('Connection closed event received', ev);
        this.connectionObserver.complete();
    };
    WebSocketFramedTransport.prototype.handleMessageEvent = function (ev) {
        /* istanbul ignore if */
        if (this.log.isDebugEnabled()) {
            this.log.debug('Message event received');
        }
        if (this.isTerminateMessage(ev)) {
            /* istanbul ignore if */
            if (this.log.isDebugEnabled()) {
                this.log.debug('Terminate message received');
            }
            this.terminateReceived = true;
        }
        else if (this.terminateReceived) {
            this.log.warn('Terminate message already received, dropping frame', ev.data);
        }
        else {
            var data = this.readEventData(ev);
            /* istanbul ignore if */
            if (this.log.isDebugEnabled()) {
                this.log.debug("Received message of " + data.byteLength + " bytes");
            }
            if (this.dataFrame) {
                this.dataFrame.body = data.buffer;
                this.connectionObserver.next(this.dataFrame);
                this.dataFrame = null;
            }
            else {
                var frame = this.messagesConverter.deserialize(data);
                if (frame.isDataFrame()) {
                    /* istanbul ignore if */
                    if (this.log.isDebugEnabled()) {
                        this.log.debug('Message header frame, waiting for data frame');
                    }
                    this.dataFrame = frame;
                }
                else {
                    this.connectionObserver.next(frame);
                }
            }
        }
    };
    WebSocketFramedTransport.prototype.isTerminateMessage = function (ev) {
        return ev.data === WebSocketFramedTransport.TERMINATE_MESSAGE;
    };
    WebSocketFramedTransport.prototype.readEventData = function (ev) {
        if (ev.data instanceof Array) {
            return new Uint8Array(ev.data);
        }
        else if (this.isArrayBuffer(ev.data)) {
            /* istanbul ignore if */
            if (this.log.isDebugEnabled()) {
                this.log.debug('Array Buffer message');
            }
            return new Uint8Array(ev.data);
        }
        else if (this.isArrayBufferView(ev.data)) {
            /* istanbul ignore if */
            if (this.log.isDebugEnabled()) {
                this.log.debug('ArrayBufferView Buffer message');
            }
            return new Uint8Array(ev.data);
        }
        else {
            this.log.error('Unknown payload type', ev.data);
            throw new Error('Unknown payload type');
        }
    };
    WebSocketFramedTransport.prototype.isArrayBuffer = function (value) {
        return value && value.byteLength !== undefined;
    };
    WebSocketFramedTransport.prototype.isArrayBufferView = function (value) {
        return value && value.buffer && value.buffer.byteLength !== undefined;
    };
    WebSocketFramedTransport.prototype.handleError = function (socket, ev) {
        this.log.error('Connection error received', ev);
        this.cancelConnectionAndCleanUp('Connection error received');
        if (this.connectionObserver) {
            this.connectionObserver.error('Web Socket Connection Error received');
        }
    };
    WebSocketFramedTransport.prototype.handleOpen = function () {
        this.log.debug('Connection opened');
    };
    WebSocketFramedTransport.prototype.throwIfNotConnected = function () {
        if (!this.connected()) {
            throw new Error('Web Socket is not connected');
        }
    };
    WebSocketFramedTransport.prototype.throwIfNotConnectedOrDisconnectRequested = function () {
        this.throwIfNotConnected();
        if (this.terminateSent) {
            throw new Error('Terminate socket requested');
        }
    };
    WebSocketFramedTransport.TERMINATE_MESSAGE = '<END>';
    WebSocketFramedTransport.SOCKET_CLOSE_TIMEOUT = 5000;
    WebSocketFramedTransport.TERMINATE_MESSAGE_RECEIVED_TIMEOUT = 10000;
    WebSocketFramedTransport.TERMINATE_MESSAGE_CHECK_TIMEOUT = 300;
    WebSocketFramedTransport.CONNECTING = 0;
    WebSocketFramedTransport.OPEN = 1;
    WebSocketFramedTransport.CLOSING = 2;
    WebSocketFramedTransport.CLOSED = 3;
    return WebSocketFramedTransport;
}());
exports.WebSocketFramedTransport = WebSocketFramedTransport;
},{"@plexus-interop/common":243,"@plexus-interop/transport-common":315,"tslib":180}],339:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Copyright 2017-2018 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
tslib_1.__exportStar(require("./WebSocketConnectionFactory"), exports);
tslib_1.__exportStar(require("./WebSocketFramedTransport"), exports);
},{"./WebSocketConnectionFactory":337,"./WebSocketFramedTransport":338,"tslib":180}]},{},[233])(233)
});
